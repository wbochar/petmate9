[{"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\index.ts":"1","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\electronImports.js":"2","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\store\\configureStore.js":"3","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\redux\\settings.ts":"4","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\redux\\toolbar.ts":"5","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\redux\\root.ts":"6","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\redux\\types.ts":"7","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\redux\\screens.ts":"8","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\containers\\Root.tsx":"9","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\store\\configureStore.prod.js":"10","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\store\\configureStore.dev.js":"11","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\redux\\utils.js":"12","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\index.ts":"13","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\redux\\typeUtils.ts":"14","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\fp.ts":"15","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\redux\\editor.ts":"16","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\redux\\screensSelectors.ts":"17","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\redux\\settingsSelectors.ts":"18","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\redux\\selectors.ts":"19","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\redux\\brush.ts":"20","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\matrix.ts":"21","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\redux\\workspace.ts":"22","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\redux\\typesExport.ts":"23","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\containers\\App.tsx":"24","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\palette.ts":"25","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\line.ts":"26","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\external\\react-sortable-hoc\\index.js":"27","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\redux\\customFonts.ts":"28","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\containers\\Toolbar.tsx":"29","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\containers\\FramebufferTabs.tsx":"30","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\containers\\Settings.tsx":"31","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\containers\\ProgressModal.tsx":"32","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\containers\\ImportModal.tsx":"33","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\containers\\ResizeSettings.tsx":"34","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\containers\\ExportModal.tsx":"35","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\containers\\FileDrop.tsx":"36","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\containers\\CustomFontsModal.tsx":"37","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\containers\\Editor.tsx":"38","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\reducers\\index.ts":"39","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\external\\react-sortable-hoc\\utils.js":"40","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\importers\\index.ts":"41","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\exporters\\index.ts":"42","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\components\\formHelpers.js":"43","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\importers\\png2petscii.ts":"44","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\containers\\hoc.tsx":"45","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\containers\\ContextMenuArea.tsx":"46","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\containers\\CharSelect.tsx":"47","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\components\\ColorPicker.tsx":"48","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\components\\CharGrid.tsx":"49","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\components\\GridOverlay.tsx":"50","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\components\\FontSelector.tsx":"51","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\components\\Statusbar.tsx":"52","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\components\\Modal.tsx":"53","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\components\\CharPosOverlay.tsx":"54","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\redux\\framebufList.ts":"55","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\external\\react-sortable-hoc\\SortableElement\\index.js":"56","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\external\\react-sortable-hoc\\SortableContainer\\index.js":"57","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\external\\react-sortable-hoc\\SortableHandle\\index.js":"58","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\importers\\cbase2petscii.ts":"59","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\importers\\seq2petscii.ts":"60","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\importers\\d64.ts":"61","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\exporters\\basic.ts":"62","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\exporters\\gif.ts":"63","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\exporters\\asm.ts":"64","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\exporters\\seq.ts":"65","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\exporters\\png.ts":"66","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\exporters\\json.ts":"67","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\exporters\\d64.ts":"68","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\exporters\\player.ts":"69","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\exporters\\pet.ts":"70","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\exporters\\cbase.ts":"71","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\external\\react-sortable-hoc\\Manager.js":"72","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\x1541.ts":"73","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\exporters\\util.ts":"74"},{"size":11522,"mtime":1734032722516,"results":"75","hashOfConfig":"76"},{"size":255,"mtime":1724888712120,"results":"77","hashOfConfig":"76"},{"size":247,"mtime":1702505915801,"results":"78","hashOfConfig":"76"},{"size":4232,"mtime":1702505915798,"results":"79","hashOfConfig":"76"},{"size":44181,"mtime":1727711758267,"results":"80","hashOfConfig":"76"},{"size":7510,"mtime":1725941815617,"results":"81","hashOfConfig":"76"},{"size":4147,"mtime":1725889699126,"results":"82","hashOfConfig":"76"},{"size":10727,"mtime":1725201496275,"results":"83","hashOfConfig":"76"},{"size":416,"mtime":1702505915790,"results":"84","hashOfConfig":"76"},{"size":294,"mtime":1702505915801,"results":"85","hashOfConfig":"76"},{"size":1170,"mtime":1702505915801,"results":"86","hashOfConfig":"76"},{"size":1007,"mtime":1702505915800,"results":"87","hashOfConfig":"76"},{"size":21611,"mtime":1727535336186,"results":"88","hashOfConfig":"76"},{"size":953,"mtime":1702505915799,"results":"89","hashOfConfig":"76"},{"size":997,"mtime":1702505915805,"results":"90","hashOfConfig":"76"},{"size":14804,"mtime":1726159921690,"results":"91","hashOfConfig":"76"},{"size":444,"mtime":1702505915798,"results":"92","hashOfConfig":"76"},{"size":1230,"mtime":1702505915798,"results":"93","hashOfConfig":"76"},{"size":7840,"mtime":1725028028158,"results":"94","hashOfConfig":"76"},{"size":4554,"mtime":1702505915796,"results":"95","hashOfConfig":"76"},{"size":2607,"mtime":1727719100797,"results":"96","hashOfConfig":"76"},{"size":3698,"mtime":1725942251964,"results":"97","hashOfConfig":"76"},{"size":3224,"mtime":1727534987690,"results":"98","hashOfConfig":"76"},{"size":4067,"mtime":1727533946148,"results":"99","hashOfConfig":"76"},{"size":1585,"mtime":1702505915807,"results":"100","hashOfConfig":"76"},{"size":486,"mtime":1702505915807,"results":"101","hashOfConfig":"76"},{"size":398,"mtime":1702505915794,"results":"102","hashOfConfig":"76"},{"size":984,"mtime":1702505915796,"results":"103","hashOfConfig":"76"},{"size":15891,"mtime":1726080164940,"results":"104","hashOfConfig":"76"},{"size":19800,"mtime":1725043053353,"results":"105","hashOfConfig":"76"},{"size":6931,"mtime":1702505915790,"results":"106","hashOfConfig":"76"},{"size":2432,"mtime":1725941786800,"results":"107","hashOfConfig":"76"},{"size":9511,"mtime":1726102584197,"results":"108","hashOfConfig":"76"},{"size":3604,"mtime":1725832251202,"results":"109","hashOfConfig":"76"},{"size":16612,"mtime":1727535164746,"results":"110","hashOfConfig":"76"},{"size":2315,"mtime":1702505915788,"results":"111","hashOfConfig":"76"},{"size":4382,"mtime":1702505915787,"results":"112","hashOfConfig":"76"},{"size":42690,"mtime":1727719090950,"results":"113","hashOfConfig":"76"},{"size":2445,"mtime":1702505915795,"results":"114","hashOfConfig":"76"},{"size":4112,"mtime":1702505915794,"results":"115","hashOfConfig":"76"},{"size":2591,"mtime":1717525285375,"results":"116","hashOfConfig":"76"},{"size":7209,"mtime":1727117093068,"results":"117","hashOfConfig":"76"},{"size":3999,"mtime":1727117402896,"results":"118","hashOfConfig":"76"},{"size":7293,"mtime":1702505915805,"results":"119","hashOfConfig":"76"},{"size":2409,"mtime":1702505915791,"results":"120","hashOfConfig":"76"},{"size":1344,"mtime":1702505915787,"results":"121","hashOfConfig":"76"},{"size":9295,"mtime":1726162682655,"results":"122","hashOfConfig":"76"},{"size":4863,"mtime":1726080369802,"results":"123","hashOfConfig":"76"},{"size":7570,"mtime":1724850775214,"results":"124","hashOfConfig":"76"},{"size":1570,"mtime":1702505915783,"results":"125","hashOfConfig":"76"},{"size":2651,"mtime":1724726135616,"results":"126","hashOfConfig":"76"},{"size":5162,"mtime":1706205180495,"results":"127","hashOfConfig":"76"},{"size":2916,"mtime":1725634886005,"results":"128","hashOfConfig":"76"},{"size":2115,"mtime":1705239422099,"results":"129","hashOfConfig":"76"},{"size":2023,"mtime":1725629422363,"results":"130","hashOfConfig":"76"},{"size":2594,"mtime":1702505915793,"results":"131","hashOfConfig":"76"},{"size":26031,"mtime":1702505915792,"results":"132","hashOfConfig":"76"},{"size":924,"mtime":1702505915794,"results":"133","hashOfConfig":"76"},{"size":7788,"mtime":1727532797516,"results":"134","hashOfConfig":"76"},{"size":5759,"mtime":1703175868000,"results":"135","hashOfConfig":"76"},{"size":1166,"mtime":1708791556510,"results":"136","hashOfConfig":"76"},{"size":2166,"mtime":1702505915803,"results":"137","hashOfConfig":"76"},{"size":2485,"mtime":1702505915803,"results":"138","hashOfConfig":"76"},{"size":5204,"mtime":1726166585966,"results":"139","hashOfConfig":"76"},{"size":6206,"mtime":1724796676297,"results":"140","hashOfConfig":"76"},{"size":1529,"mtime":1725033539038,"results":"141","hashOfConfig":"76"},{"size":3035,"mtime":1724944738045,"results":"142","hashOfConfig":"76"},{"size":4172,"mtime":1724872061784,"results":"143","hashOfConfig":"76"},{"size":6748,"mtime":1727722212574,"results":"144","hashOfConfig":"76"},{"size":1026,"mtime":1702505915804,"results":"145","hashOfConfig":"76"},{"size":6978,"mtime":1727537925128,"results":"146","hashOfConfig":"76"},{"size":912,"mtime":1702505915792,"results":"147","hashOfConfig":"76"},{"size":7004,"mtime":1724869288268,"results":"148","hashOfConfig":"76"},{"size":3903,"mtime":1702505915805,"results":"149","hashOfConfig":"76"},{"filePath":"150","messages":"151","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"x7y730",{"filePath":"152","messages":"153","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"154"},{"filePath":"155","messages":"156","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"154"},{"filePath":"157","messages":"158","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"154"},{"filePath":"159","messages":"160","errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"161","usedDeprecatedRules":"154"},{"filePath":"162","messages":"163","errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"164","usedDeprecatedRules":"154"},{"filePath":"165","messages":"166","errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"167","usedDeprecatedRules":"154"},{"filePath":"168","messages":"169","errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"170","usedDeprecatedRules":"154"},{"filePath":"171","messages":"172","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"154"},{"filePath":"173","messages":"174","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"154"},{"filePath":"175","messages":"176","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"154"},{"filePath":"177","messages":"178","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"154"},{"filePath":"179","messages":"180","errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"181","usedDeprecatedRules":"154"},{"filePath":"182","messages":"183","errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"184","usedDeprecatedRules":"154"},{"filePath":"185","messages":"186","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"154"},{"filePath":"187","messages":"188","errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"189","usedDeprecatedRules":"154"},{"filePath":"190","messages":"191","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"154"},{"filePath":"192","messages":"193","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"154"},{"filePath":"194","messages":"195","errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"196","usedDeprecatedRules":"154"},{"filePath":"197","messages":"198","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"154"},{"filePath":"199","messages":"200","errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"201","usedDeprecatedRules":"154"},{"filePath":"202","messages":"203","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"154"},{"filePath":"204","messages":"205","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"154"},{"filePath":"206","messages":"207","errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"208","usedDeprecatedRules":"154"},{"filePath":"209","messages":"210","errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"211","usedDeprecatedRules":"154"},{"filePath":"212","messages":"213","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"154"},{"filePath":"214","messages":"215","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"154"},{"filePath":"216","messages":"217","errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"218","usedDeprecatedRules":"154"},{"filePath":"219","messages":"220","errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"221","usedDeprecatedRules":"154"},{"filePath":"222","messages":"223","errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"224","usedDeprecatedRules":"154"},{"filePath":"225","messages":"226","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"154"},{"filePath":"227","messages":"228","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"154"},{"filePath":"229","messages":"230","errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"231","usedDeprecatedRules":"154"},{"filePath":"232","messages":"233","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"154"},{"filePath":"234","messages":"235","errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"236","usedDeprecatedRules":"154"},{"filePath":"237","messages":"238","errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"239","usedDeprecatedRules":"154"},{"filePath":"240","messages":"241","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"154"},{"filePath":"242","messages":"243","errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"244","usedDeprecatedRules":"154"},{"filePath":"245","messages":"246","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"154"},{"filePath":"247","messages":"248","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"154"},{"filePath":"249","messages":"250","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"154"},{"filePath":"251","messages":"252","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"154"},{"filePath":"253","messages":"254","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"154"},{"filePath":"255","messages":"256","errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"257","usedDeprecatedRules":"154"},{"filePath":"258","messages":"259","errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"260","usedDeprecatedRules":"154"},{"filePath":"261","messages":"262","errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"263","usedDeprecatedRules":"154"},{"filePath":"264","messages":"265","errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"266","usedDeprecatedRules":"154"},{"filePath":"267","messages":"268","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"154"},{"filePath":"269","messages":"270","errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"271","usedDeprecatedRules":"154"},{"filePath":"272","messages":"273","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"154"},{"filePath":"274","messages":"275","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"154"},{"filePath":"276","messages":"277","errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"278","usedDeprecatedRules":"154"},{"filePath":"279","messages":"280","errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"281","usedDeprecatedRules":"154"},{"filePath":"282","messages":"283","errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"284","usedDeprecatedRules":"154"},{"filePath":"285","messages":"286","errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"287","usedDeprecatedRules":"154"},{"filePath":"288","messages":"289","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"154"},{"filePath":"290","messages":"291","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"154"},{"filePath":"292","messages":"293","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"154"},{"filePath":"294","messages":"295","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"154"},{"filePath":"296","messages":"297","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"154"},{"filePath":"298","messages":"299","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"154"},{"filePath":"300","messages":"301","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"154"},{"filePath":"302","messages":"303","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"154"},{"filePath":"304","messages":"305","errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"306","usedDeprecatedRules":"154"},{"filePath":"307","messages":"308","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"154"},{"filePath":"309","messages":"310","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"154"},{"filePath":"311","messages":"312","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"154"},{"filePath":"313","messages":"314","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"154"},{"filePath":"315","messages":"316","errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"317","messages":"318","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"154"},{"filePath":"319","messages":"320","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"154"},{"filePath":"321","messages":"322","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"154"},{"filePath":"323","messages":"324","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"154"},{"filePath":"325","messages":"326","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"154"},"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\index.ts",[],"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\electronImports.js",[],[],"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\store\\configureStore.js",[],"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\redux\\settings.ts",[],"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\redux\\toolbar.ts",["327"],"\nimport { bindActionCreators, Dispatch } from 'redux'\n\nimport { Framebuffer } from './editor'\nimport * as Screens from './screens'\nimport { Toolbar as IToolbar, Transform, RootStateThunk, Coord2, Pixel, BrushRegion, Font, Brush, Tool, Angle360, FramebufUIState, DEFAULT_FB_WIDTH, DEFAULT_FB_HEIGHT } from './types'\n\nimport * as selectors from './selectors'\nimport * as screensSelectors from '../redux/screensSelectors'\nimport {\n  getSettingsPaletteRemap\n} from '../redux/settingsSelectors'\nimport * as utils from '../utils'\nimport * as brush from './brush'\nimport { ActionsUnion, createAction, updateField, DispatchPropsFromActions } from './typeUtils'\nimport { FileFormat } from './typesExport';\nimport * as matrix from '../utils/matrix';\n\n\n\nimport { electron } from '../utils/electronImports'\n\n\n\nconst defaultFramebufUIState: FramebufUIState = {\n  canvasTransform: matrix.ident(),\n  canvasFit: 'nofit'\n};\n\nconst emptyTransform: Transform = {\n  mirror: 0,\n  rotate: 0\n}\n\nfunction rotate(transform: Transform, dir: number): Transform {\n\n  let currentRotation = transform.rotate\n  let newRotation = currentRotation - 90 * dir\n\n  if (newRotation < 0)\n    newRotation = 270;\n  if (newRotation > 270)\n    newRotation = 0;\n\n\n  return {\n    ...transform,\n    rotate: ((newRotation) % 360) as Angle360\n  }\n}\n\nfunction mirror(transform: Transform, mirror: number) {\n  return {\n    ...transform,\n    mirror: transform.mirror ^ mirror\n  }\n}\n\nfunction dispatchForCurrentFramebuf(\n  f: (dispatch: Dispatch, framebufIndex: number) => void\n): RootStateThunk {\n  return (dispatch, getState) => {\n    const state = getState();\n    const framebufIndex = screensSelectors.getCurrentScreenFramebufIndex(state);\n    if (framebufIndex == null) {\n      return;\n    }\n    f(dispatch, framebufIndex);\n  }\n}\n\nconst initialBrushValue = {\n  brush: null as (Brush | null),\n  brushRegion: null as (BrushRegion | null),\n  brushTransform: emptyTransform\n}\n\nfunction moveTextCursor(curPos: Coord2, dir: Coord2, width: number, height: number) {\n  const idx = (curPos.row + dir.row) * width + (curPos.col + dir.col) + width * height\n  const wrapped = idx % (width * height)\n  return {\n    row: Math.floor(wrapped / width),\n    col: Math.floor(wrapped % width)\n  }\n}\n\nfunction asc2int(asc: string) {\n  return asc.charCodeAt(0)\n}\n\nfunction convertAsciiToScreencode(asc: string) {\n  if (asc.length !== 1) {\n    return null\n  }\n  if (asc >= 'a' && asc <= 'z') {\n    return asc2int(asc) - asc2int('a') + 1\n  }\n  if (asc >= 'A' && asc <= 'Z') {\n    return asc2int(asc) - asc2int('A') + 0x41\n  }\n  if (asc >= '0' && asc <= '9') {\n    return asc2int(asc) - asc2int('0') + 0x30\n  }\n  const otherChars: { [index: string]: number } = {\n    '@': 0,\n    ' ': 0x20,\n    '!': 0x21,\n    '\"': 0x22,\n    '#': 0x23,\n    '$': 0x24,\n    '%': 0x25,\n    '&': 0x26,\n    '\\'': 0x27,\n    '(': 0x28,\n    ')': 0x29,\n    '*': 0x2a,\n    '+': 0x2b,\n    ',': 0x2c,\n    '-': 0x2d,\n    '.': 0x2e,\n    '/': 0x2f,\n    ':': 0x3a,\n    ';': 0x3b,\n    '<': 0x3c,\n    '=': 0x3d,\n    '>': 0x3e,\n    '?': 0x3f\n  }\n  if (asc in otherChars) {\n    return otherChars[asc]\n  }\n  return null\n}\n\nconst SET_SELECTED_CHAR = 'Toolbar/SET_SELECTED_CHAR'\nconst RESET_BRUSH = 'Toolbar/RESET_BRUSH'\nconst CAPTURE_BRUSH = 'Toolbar/CAPTURE_BRUSH'\nconst MIRROR_BRUSH = 'Toolbar/MIRROR_BRUSH'\nconst ROTATE_BRUSH = 'Toolbar/ROTATE_BRUSH'\nconst MIRROR_CHAR = 'Toolbar/MIRROR_CHAR'\nconst ROTATE_CHAR = 'Toolbar/ROTATE_CHAR'\nconst NEXT_CHARCODE = 'Toolbar/NEXT_CHARCODE'\nconst NEXT_COLOR = 'Toolbar/NEXT_COLOR'\nconst INVERT_CHAR = 'Toolbar/INVERT_CHAR'\nconst INVERT_SINGLE_CHAR = 'Toolbar/INVERT_SINGLE_CHAR'\nconst CLEAR_MOD_KEY_STATE = 'Toolbar/CLEAR_MOD_KEY_STATE'\nconst INC_UNDO_ID = 'Toolbar/INC_UNDO_ID'\nconst SET_FRAMEBUF_UI_STATE = 'Toolbar/SET_FRAMEBUF_UI_STATE'\nconst SET_COLOR = 'Toolbar/SET_COLOR'\nconst PASTE_TEXT = 'Toolbar/PASTE_TEXT'\nconst SELECT_ALL = 'Toolbar/SELECT_ALL'\nconst INVERT_BRUSH = 'Toolbar/INVERT_BRUSH'\nconst BRUSH_TO_NEW = 'Toolbar/BRUSH_TO_NEW'\nconst SET_ZOOM = 'Toolbar/SET_ZOOM'\nconst SET_ALLBORDER_ON = 'Toolbar/SET_ALLBORDER_ON'\n\nlet CAPS = false\n\nfunction captureBrush(framebuf: Pixel[][], brushRegion: BrushRegion) {\n  const { min, max } = utils.sortRegion(brushRegion)\n  const h = max.row - min.row + 1\n  const w = max.col - min.col + 1\n  const capfb = Array(h)\n  for (var y = 0; y < h; y++) {\n    capfb[y] = framebuf[y + min.row].slice(min.col, max.col + 1)\n  }\n  return createAction(CAPTURE_BRUSH, {\n    framebuf: capfb,\n    brushRegion: {\n      min: { row: 0, col: 0 },\n      max: { row: h - 1, col: w - 1 }\n    }\n  })\n}\n\nconst actionCreators = {\n  incUndoId: () => createAction(INC_UNDO_ID),\n  resetBrush: () => createAction(RESET_BRUSH),\n  brushToNew: () => createAction(BRUSH_TO_NEW),\n  selectAll: () => createAction(SELECT_ALL),\n  setSelectedChar: (coord: Coord2) => createAction(SET_SELECTED_CHAR, coord),\n  nextCharcodeAction: (dir: Coord2, font: Font) => createAction(NEXT_CHARCODE, { dir, font }),\n  nextColorAction: (dir: number, paletteRemap: number[]) => createAction(NEXT_COLOR, { dir, paletteRemap }),\n  setColorAction: (slot: number, paletteRemap: number[]) => createAction(SET_COLOR, { slot, paletteRemap }),\n  invertCharAction: (font: Font) => createAction(INVERT_CHAR, font),\n  invertSingleCharAction: (font: Font, code: number) => createAction(INVERT_SINGLE_CHAR, { font, code }),\n  invertBrushAction: (brush: Brush) => createAction(INVERT_BRUSH, brush),\n  clearModKeyState: () => createAction(CLEAR_MOD_KEY_STATE),\n  captureBrush,\n  mirrorBrush: (axis: number) => createAction(MIRROR_BRUSH, axis),\n  rotateBrush: (dir: number) => createAction(ROTATE_BRUSH, dir),\n  mirrorChar: (axis: number) => createAction(MIRROR_CHAR, axis),\n  rotateChar: (dir: number) => createAction(ROTATE_CHAR, dir),\n  pasteText: () => createAction(PASTE_TEXT),\n  setZoom: (level: number, alignment: string) => createAction(SET_ZOOM, { level, alignment }),\n  setAllZoom: (level: number, alignment: string) => createAction(SET_ZOOM, { level, alignment }),\n  setFramebufUIState: (framebufIndex: number, uiState?: FramebufUIState) => createAction(SET_FRAMEBUF_UI_STATE, { framebufIndex, uiState }),\n  setTextColor: (c: number) => createAction('Toolbar/SET_TEXT_COLOR', c),\n  setTextCursorPos: (pos: Coord2 | null) => createAction('Toolbar/SET_TEXT_CURSOR_POS', pos),\n  setSelectedTool: (t: Tool) => createAction('Toolbar/SET_SELECTED_TOOL', t),\n  setBrushRegion: (br: BrushRegion) => createAction('Toolbar/SET_BRUSH_REGION', br),\n  setBrush: (b: Brush) => createAction('Toolbar/SET_BRUSH', b),\n  setWorkspaceFilename: (fname: string | null) => createAction('Toolbar/SET_WORKSPACE_FILENAME', fname),\n  setAltKey: (flag: boolean) => createAction('Toolbar/SET_ALT_KEY', flag),\n  setCtrlKey: (flag: boolean) => createAction('Toolbar/SET_CTRL_KEY', flag),\n  setTabKey: (flag: boolean) => createAction('Toolbar/SET_TAB_KEY', flag),\n  setMetaKey: (flag: boolean) => createAction('Toolbar/SET_META_KEY', flag),\n  setShiftKey: (flag: boolean) => createAction('Toolbar/SET_SHIFT_KEY', flag),\n  setCAPSLockKey: (flag: boolean) => createAction('Toolbar/SET_CAPSLOCK_KEY', flag),\n  setSpacebarKey: (flag: boolean) => createAction('Toolbar/SET_SPACEBAR_KEY', flag),\n  setShowSettings: (flag: boolean) => createAction('Toolbar/SET_SHOW_SETTINGS', flag),\n  setShowResizeSettings: (flag: boolean) => createAction('Toolbar/SET_SHOW_RESIZESETTINGS', flag),\n  setShowProgressModal: (flag: boolean) => createAction('Toolbar/SET_SHOW_PROGRESSMODAL', flag),\n  setProgressTitle: (progressTitle: string) => createAction('Toolbar/SET_PROGRESSTITLE', progressTitle),\n  setProgressValue: (progressValue: number) => createAction('Toolbar/SET_PROGRESSVALUE', progressValue),\n  setResizeWidth: (width: number) => createAction('Toolbar/SET_RESIZEWIDTH', width),\n  setResizeHeight: (height: number) => createAction('Toolbar/SET_RESIZEHEIGHT', height),\n  setResizeCrop: (resizeCrop: boolean) => createAction('Toolbar/SET_RESIZECROP', resizeCrop),\n  setShowCustomFonts: (flag: boolean) => createAction('Toolbar/SET_SHOW_CUSTOM_FONTS', flag),\n  setShowExport: (show: { show: boolean, fmt?: FileFormat }) => createAction('Toolbar/SET_SHOW_EXPORT', show),\n  setShowImport: (show: { show: boolean, fmt?: FileFormat }) => createAction('Toolbar/SET_SHOW_IMPORT', show),\n  setSelectedPaletteRemap: (remapIdx: number) => createAction('Toolbar/SET_SELECTED_PALETTE_REMAP', remapIdx),\n  setCanvasGrid: (flag: boolean) => createAction('Toolbar/SET_CANVAS_GRID', flag),\n  setShortcutsActive: (flag: boolean) => createAction('Toolbar/SET_SHORTCUTS_ACTIVE', flag),\n  setNewScreenSize: (dims: { width: number, height: number }) => createAction('Toolbar/SET_NEW_SCREEN_SIZE', dims),\n  swapColors:(colors:{srcColor:number, destColor:number}) => createAction('Toolbar/SWAP_COLORS',colors),\n  swapChars:(chars:{srcChar:number, destChar:number}) => createAction('Toolbar/SWAP_CHARS',chars),\n};\n\nexport type Actions = ActionsUnion<typeof actionCreators>;\n\nexport type PropsFromDispatch = DispatchPropsFromActions<typeof Toolbar.actions>;\n\nexport class Toolbar {\n\n  static MIRROR_X = 1\n  static MIRROR_Y = 2\n\n  static actions = {\n    ...actionCreators,\n\n    keyDown: (k: string): RootStateThunk => {\n      // Lower-case single keys in case the caps-lock is on.\n      // Doing this for single char keys only to keep the other\n      // keys (like 'ArrowLeft') in their original values.\n      const key = k.length == 1 ? k.toLowerCase() : k;\n\n      return (dispatch, getState) => {\n        const state = getState()\n        if (!state.toolbar.shortcutsActive) {\n          return\n        }\n        const {\n          shiftKey,\n          altKey,\n          metaKey,\n          ctrlKey,\n          tabKey,\n          selectedTool,\n          showSettings,\n          showCustomFonts,\n          showResizeSettings,\n          showProgressModal,\n          progressTitle,\n          progressValue,\n          resizeWidth,\n          resizeHeight,\n          resizeCrop,\n          showExport,\n          showImport,\n\n        } = state.toolbar\n        const noMods = !shiftKey && !metaKey && !ctrlKey && !tabKey && !altKey\n        const metaOrCtrl = metaKey || ctrlKey\n\n        const inModal =\n          state.toolbar.showExport.show ||\n          state.toolbar.showImport.show ||\n          state.toolbar.showSettings ||\n          state.toolbar.showResizeSettings ||\n          state.toolbar.showCustomFonts;\n\n        if (inModal) {\n          // These shouldn't early exit this function since we check for other\n          // conditions for Esc later.\n          if (key == 'Escape') {\n            if (showSettings) {\n              dispatch(Toolbar.actions.setShowSettings(false));\n            }\n            if (showResizeSettings) {\n\n              dispatch(Toolbar.actions.setShowResizeSettings(false));\n            }\n            if (showCustomFonts) {\n              dispatch(Toolbar.actions.setShowCustomFonts(false));\n            }\n            if (showExport) {\n              dispatch(Toolbar.actions.setShowExport({ show: false }));\n            }\n            if (showImport) {\n              dispatch(Toolbar.actions.setShowImport({ show: false }));\n            }\n          }\n          return;\n        }\n\n\n\n        let width = 1;\n        let height = 1;\n        const framebufIndex = screensSelectors.getCurrentScreenFramebufIndex(state)\n        if (framebufIndex !== null) {\n          const { width: w, height: h } = selectors.getFramebufByIndex(state, framebufIndex)!;\n          width = w;\n          height = h;\n\n\n\n        }\n\n\n\n\n        let inTextInput = selectedTool == Tool.Text && state.toolbar.textCursorPos !== null\n\n\n        var ParentCanvas = document.getElementById(\"MainCanvas\")?.parentElement;\n        var xCanvas = document.getElementById(\"MainCanvas\");\n        let framebufUIState = selectors.getFramebufUIState(state, framebufIndex);\n\n        var currentScale = Number(xCanvas?.style.transform.split(',')[3]);\n\n\n\n        // These shortcuts should work regardless of what drawing tool is selected.\n        if (noMods) {\n          if (!inTextInput) {\n            if (!altKey && key == 'ArrowLeft') {\n              dispatch(Screens.actions.nextScreen(-1))\n              return\n            } else if (!altKey && key == 'ArrowRight') {\n              dispatch(Screens.actions.nextScreen(+1))\n              return\n            } else if (key == 'q') {\n              dispatch(Toolbar.actions.nextColor(-1))\n              return\n            } else if (key == 'e') {\n              dispatch(Toolbar.actions.nextColor(+1))\n              return\n            } else if (key == 'x') {\n              dispatch(Toolbar.actions.setSelectedTool(Tool.Draw))\n              return\n            } else if (key == 'c') {\n              dispatch(Toolbar.actions.setSelectedTool(Tool.Colorize))\n              return\n            } else if (key == '0') {\n              dispatch(Toolbar.actions.setSelectedTool(Tool.CharDraw))\n              return\n            } else if (key == 'b') {\n              dispatch(Toolbar.actions.setSelectedTool(Tool.Brush))\n              return\n            } else if (key == 't') {\n              dispatch(Toolbar.actions.setSelectedTool(Tool.Text))\n              return\n            } else if (key == 'z') {\n              dispatch(Toolbar.actions.setSelectedTool(Tool.PanZoom))\n              return\n            } else if (key == 'g') {\n              /*\n              return dispatch((dispatch, getState) => {\n                const { canvasGrid } = getState().toolbar\n                dispatch(Toolbar.actions.setCanvasGrid(!canvasGrid))\n              })\n              */\n            }\n          }\n        }\n\n\n\n\n        if (altKey) {\n          if (altKey && key == '1') {\n            dispatch(Toolbar.actions.setColor(0))\n            return\n          } else if (altKey && key == '2') {\n            dispatch(Toolbar.actions.setColor(1))\n            return\n          } else if (altKey && key == '3') {\n            dispatch(Toolbar.actions.setColor(2))\n            return\n          } else if (altKey && key == '4') {\n            dispatch(Toolbar.actions.setColor(3))\n            return\n          } else if (altKey && key == '5') {\n            dispatch(Toolbar.actions.setColor(4))\n            return\n          } else if (altKey && key == '6') {\n            dispatch(Toolbar.actions.setColor(5))\n            return\n          } else if (altKey && key == '7') {\n            dispatch(Toolbar.actions.setColor(6))\n            return\n          } else if (altKey && key == '8') {\n            dispatch(Toolbar.actions.setColor(7))\n            return\n\n          }\n\n        }\n\n\n\n        if (ctrlKey) {\n\n          if (ctrlKey && key == '1') {\n            dispatch(Toolbar.actions.setColor(8))\n            return\n          }\n          else if (ctrlKey && key == '2') {\n            dispatch(Toolbar.actions.setColor(9))\n            return\n          } else if (ctrlKey && key == '3') {\n            dispatch(Toolbar.actions.setColor(10))\n            return\n          } else if (ctrlKey && key == '4') {\n            dispatch(Toolbar.actions.setColor(11))\n            return\n          } else if (ctrlKey && key == '5') {\n            dispatch(Toolbar.actions.setColor(12))\n            return\n          } else if (ctrlKey && key == '6') {\n            dispatch(Toolbar.actions.setColor(13))\n            return\n          } else if (ctrlKey && key == '7') {\n            dispatch(Toolbar.actions.setColor(14))\n            return\n          } else if (ctrlKey && key == '8') {\n            dispatch(Toolbar.actions.setColor(15))\n            return\n          }\n\n          if (key == 'a') {\n            dispatch(Toolbar.actions.selectAll());\n            dispatch(Toolbar.actions.setSelectedTool(Tool.Brush))\n          }\n          if (key == 'v') {\n            //ipcRenderer.send('set-title', \"x:\"+electron.clipboard.readText())\n            //const formats = electron.clipboard.availableFormats();\n\n\n            dispatch(Toolbar.actions.pasteText())\n          }\n        }\n\n        if (selectedTool == Tool.Brush) {\n          if (key == 'Escape' && state.toolbar.brush == null) {\n            dispatch(Toolbar.actions.setSelectedTool(Tool.Draw))\n          }\n        }\n\n        if (selectedTool == Tool.FloodFill) {\n          if (key == 'Escape') {\n            dispatch(Toolbar.actions.setSelectedTool(Tool.Draw))\n          }\n        }\n        if (selectedTool == Tool.Text) {\n          if (key == 'Escape') {\n            dispatch(Toolbar.actions.setTextCursorPos(null))\n          }\n\n\n          if (key == 'Escape' && state.toolbar.textCursorPos == null) {\n            dispatch(Toolbar.actions.setSelectedTool(Tool.Draw))\n          }\n\n\n          if (key == 'CapsLock') {\n            CAPS = !CAPS\n            return\n          }\n\n          if (state.toolbar.textCursorPos != null && !metaOrCtrl) {\n            // Don't match shortcuts if we're in \"text tool\" mode.\n            const { textCursorPos, textColor } = state.toolbar\n            //const c = convertAsciiToScreencode(shiftKey ? key.toUpperCase() : key)\n            let c = convertAsciiToScreencode(shiftKey ? key.toUpperCase() : key)\n\n            if (c != null)\n              c = c + (Number(CAPS) * 128)\n\n\n\n\n\n\n            if (framebufIndex != null) {\n              if (c !== null) {\n                dispatch(Framebuffer.actions.setPixel({\n                  ...textCursorPos,\n                  screencode: c,\n                  color: textColor,\n                }, null, framebufIndex));\n                const newCursorPos = moveTextCursor(\n                  textCursorPos,\n                  { col: 1, row: 0 },\n                  width, height\n                )\n                dispatch(Toolbar.actions.setTextCursorPos(newCursorPos))\n              }\n              if (key == 'Backspace') {\n                const newCursorPos = moveTextCursor(\n                  textCursorPos,\n                  { col: -1, row: 0 },\n                  width, height\n                )\n                dispatch(Toolbar.actions.setTextCursorPos(newCursorPos));\n                dispatch(Framebuffer.actions.setPixel({\n                  ...newCursorPos,\n                  screencode: 0x20, // space\n                  color: textColor,\n                }, null, framebufIndex));\n              }\n            }\n            if (key == 'ArrowLeft' || key == 'ArrowRight') {\n              dispatch(Toolbar.actions.setTextCursorPos(\n                moveTextCursor(\n                  textCursorPos,\n                  { col: key == 'ArrowLeft' ? -1 : 1, row: 0 },\n                  width, height\n                )\n              ))\n            } else if (key == 'ArrowUp' || key == 'ArrowDown') {\n              dispatch(Toolbar.actions.setTextCursorPos(\n                moveTextCursor(\n                  textCursorPos,\n                  { row: key == 'ArrowUp' ? -1 : 1, col: 0 },\n                  width, height\n                )\n              ))\n            }\n            else if (key == 'Enter') {\n              dispatch(Toolbar.actions.setTextCursorPos(\n                moveTextCursor(\n                  textCursorPos,\n                  { row: 1, col: -textCursorPos.col },\n                  width, height\n                )\n              ))\n            }\n            else if (key == 'Home') {\n              if (shiftKey) {\n                dispatch(Toolbar.actions.clearCanvas())\n              }\n              dispatch(Toolbar.actions.setTextCursorPos(\n                moveTextCursor(\n                  textCursorPos,\n                  { row: -textCursorPos.row, col: -textCursorPos.col },\n                  width, height\n                )\n              ))\n\n            }\n\n\n          }\n        } else if (noMods) {\n          if (key == 'Escape') {\n            if (selectedTool == Tool.Brush) {\n              dispatch(Toolbar.actions.resetBrush())\n            }\n          } else if (key == 'a') {\n            dispatch(Toolbar.actions.nextCharcode({ row: 0, col: -1 }))\n          } else if (key == 'd') {\n            dispatch(Toolbar.actions.nextCharcode({ row: 0, col: +1 }))\n          } else if (key == 's') {\n            dispatch(Toolbar.actions.nextCharcode({ row: +1, col: 0 }))\n          } else if (key == 'w') {\n            dispatch(Toolbar.actions.nextCharcode({ row: -1, col: 0 }))\n          }\n\n          else if (key == 'v' || key == 'h') {\n            let mirror = Toolbar.MIRROR_Y\n            if (key == 'h') {\n              mirror = Toolbar.MIRROR_X\n            }\n            if (selectedTool == Tool.Brush) {\n              dispatch(Toolbar.actions.mirrorBrush(mirror))\n            } else if (selectedTool == Tool.Draw || selectedTool == Tool.CharDraw) {\n              dispatch(Toolbar.actions.mirrorChar(mirror))\n            }\n          }\n\n          else if (key == 'f') {\n            dispatch(Toolbar.actions.invertChar())\n          } else if (key == 'r') {\n            if (selectedTool == Tool.Brush) {\n\n              dispatch(Toolbar.actions.rotateBrush(-1))\n\n            } else if (selectedTool == Tool.Draw || selectedTool == Tool.CharDraw) {\n              dispatch(Toolbar.actions.rotateChar(-1))\n            }\n          }\n        }\n\n        if (key == 'Shift') {\n          dispatch(Toolbar.actions.setShiftKey(true))\n        } else if (key == 'Meta') {\n          dispatch(Toolbar.actions.setMetaKey(true))\n        } else if (key == 'Control') {\n          dispatch(Toolbar.actions.setCtrlKey(true))\n        } else if (key == 'Alt') {\n          dispatch(Toolbar.actions.setAltKey(true))\n        } else if (key == ' ') {\n          dispatch(Toolbar.actions.setSpacebarKey(true))\n        } else if (key == 'Tab') {\n          dispatch(Toolbar.actions.setTabKey(true))\n        }\n\n\n        if (metaOrCtrl) {\n          switch (key) {\n\n\n            default:\n              break;\n          }\n        }\n\n\n      }\n    },\n\n    keyUp: (key: string): RootStateThunk => {\n      return (dispatch, _getState) => {\n        if (key == 'Shift') {\n          dispatch(Toolbar.actions.setShiftKey(false))\n        } else if (key == 'Meta') {\n          dispatch(Toolbar.actions.setMetaKey(false))\n        } else if (key == 'Control') {\n          dispatch(Toolbar.actions.setCtrlKey(false))\n        } else if (key == 'Tab') {\n          dispatch(Toolbar.actions.setTabKey(false))\n        } else if (key == 'Alt') {\n          dispatch(Toolbar.actions.setAltKey(false))\n        } else if (key == ' ') {\n          dispatch(Toolbar.actions.setSpacebarKey(false))\n        }\n      }\n    },\n\n    clearCanvas: (): RootStateThunk => {\n      return dispatchForCurrentFramebuf((dispatch, framebufIndex) => {\n        dispatch(Framebuffer.actions.clearCanvas(framebufIndex))\n      });\n    },\n    swapColors: (colors:{srcColor:number,destColor:number}): RootStateThunk => {\n      return dispatchForCurrentFramebuf((dispatch, framebufIndex) => {\n        dispatch(Framebuffer.actions.swapColors(colors,framebufIndex))\n      });\n    },\n    swapChars: (chars:{srcChar:number,destChar:number}): RootStateThunk => {\n      return dispatchForCurrentFramebuf((dispatch, framebufIndex) => {\n        dispatch(Framebuffer.actions.swapChars(chars,framebufIndex))\n      });\n    },\n\n    resizeCanvas: (width: number, height: number, dir: Coord2, isCrop:boolean): RootStateThunk => {\n      return dispatchForCurrentFramebuf((dispatch, framebufIndex) => {\n        dispatch(Framebuffer.actions.resizeCanvas({ rWidth: width, rHeight: height, rDir: dir, isCrop:isCrop}, framebufIndex,))\n      });\n      console.log(\"toolbar.ts: end resizeCanvas:\")\n    },\n\n    resizeDims: (): RootStateThunk => {\n\n      return (dispatch, getState) => {\n        const state = getState()\n\n\n        const framebufIndex = screensSelectors.getCurrentScreenFramebufIndex(state)\n\n        if (framebufIndex !== null) {\n          const { width,height } = selectors.getFramebufByIndex(state, framebufIndex)!;\n\n          state.toolbar.resizeWidth = width;\n          state.toolbar.resizeHeight = height;\n\n        }\n\n      }\n\n    },\n\n\n    nextCharcode: (dir: Coord2): RootStateThunk => {\n      return (dispatch, getState) => {\n        const { font } = selectors.getCurrentFramebufFont(getState());\n        dispatch(actionCreators.nextCharcodeAction(dir, font));\n      }\n    },\n\n    invertChar: (): RootStateThunk => {\n      return (dispatch, getState) => {\n        const { font } = selectors.getCurrentFramebufFont(getState());\n        dispatch(actionCreators.invertCharAction(font));\n      }\n    },\n    invertSingleChar: (code: number): RootStateThunk => {\n      return (dispatch, getState) => {\n        const { font } = selectors.getCurrentFramebufFont(getState());\n        dispatch(actionCreators.invertSingleCharAction(font, code));\n      }\n    },\n\n    invertBrush: (): RootStateThunk => {\n      return (dispatch, getState) => {\n        const state = getState()\n        const { font } = selectors.getCurrentFramebufFont(getState());\n\n        let srcBrush = state.toolbar.brush as (Brush | null)\n\n        if (srcBrush != null) {\n\n\n\n\n          const invertedFramebuf = srcBrush.framebuf.map((pixelRow: any) => {\n            return pixelRow.map((pix: any) => {\n              const newcode = pix.code < 128 ? pix.code + 128 : pix.code - 128\n              return { ...pix, code: newcode }\n            })\n          });\n\n          const newBrush = {\n            ...srcBrush,\n            framebuf: invertedFramebuf\n          }\n\n\n          dispatch(actionCreators.invertBrushAction(newBrush));\n\n        }\n      }\n    },\n\n\n    setColor: (slot: number): RootStateThunk => {\n      return (dispatch, getState) => {\n        const state = getState()\n        dispatch(actionCreators.setColorAction(slot, getSettingsPaletteRemap(state)));\n      }\n    },\n\n\n    nextColor: (dir: number): RootStateThunk => {\n      return (dispatch, getState) => {\n        const state = getState()\n        dispatch(actionCreators.nextColorAction(dir, getSettingsPaletteRemap(state)));\n      }\n    },\n\n    setScreencode: (code: number): RootStateThunk => {\n      return (dispatch, getState) => {\n        const state = getState();\n        const { font } = selectors.getCurrentFramebufFont(state);\n        const charPos = utils.rowColFromScreencode(font, code);\n        dispatch(Toolbar.actions.setSelectedChar(charPos));\n      }\n    },\n\n    setCurrentColor: (color: number): RootStateThunk => {\n      return (dispatch, getState) => {\n        const state = getState();\n        dispatch(Toolbar.actions.setTextColor(color))\n        /*\n        if (state.toolbar.selectedTool == Tool.Brush ||\n            state.toolbar.selectedTool == Tool.PanZoom) {\n          dispatch(Toolbar.actions.setSelectedTool(Tool.Draw));\n        }\n*/\n      }\n    },\n\n    setCurrentChar: (charPos: Coord2): RootStateThunk => {\n      return (dispatch, getState) => {\n        const state = getState()\n        dispatch(Toolbar.actions.setSelectedChar(charPos))\n        /*\n        if (state.toolbar.selectedTool == Tool.Brush ||\n          state.toolbar.selectedTool == Tool.Colorize ||\n          state.toolbar.selectedTool == Tool.Text ||\n          state.toolbar.selectedTool == Tool.PanZoom) {\n          dispatch(Toolbar.actions.setSelectedTool(Tool.Draw))\n        }\n        */\n      }\n    },\n\n    setCurrentScreencodeAndColor: (pix: Pixel): RootStateThunk => {\n      return (dispatch, getState) => {\n        const state = getState()\n        dispatch(Toolbar.actions.setTextColor(pix.color))\n        dispatch(Toolbar.actions.setScreencode(pix.code))\n        if (state.toolbar.selectedTool == Tool.Brush ||\n          state.toolbar.selectedTool == Tool.Text) {\n          dispatch(Toolbar.actions.setSelectedTool(Tool.Draw))\n        }\n      }\n    },\n\n    shiftHorizontal: (dir: -1 | 1): RootStateThunk => {\n      return dispatchForCurrentFramebuf((dispatch, framebufIndex) => {\n        dispatch(Framebuffer.actions.shiftHorizontal(dir, framebufIndex))\n      });\n    },\n\n    shiftVertical: (dir: -1 | 1) => {\n      return dispatchForCurrentFramebuf((dispatch, framebufIndex) => {\n        dispatch(Framebuffer.actions.shiftVertical(dir, framebufIndex))\n      });\n    },\n\n    setCurrentFramebufUIState: (uiState: FramebufUIState): RootStateThunk => {\n      return dispatchForCurrentFramebuf((dispatch, framebufIndex) => {\n        dispatch(Toolbar.actions.setFramebufUIState(framebufIndex, uiState));\n      });\n    },\n    toggleBorder: (): RootStateThunk => {\n      return (dispatch, getState) => {\n        const state = getState()\n        const framebufIndex = screensSelectors.getCurrentScreenFramebufIndex(state)\n        let xborderOn = false;\n        if (framebufIndex !== null) {\n          const { borderOn: borderOn } = selectors.getFramebufByIndex(state, framebufIndex)!;\n          xborderOn = borderOn;\n\n        }\n\n\n\n        dispatch(Framebuffer.actions.setBorderOn(!xborderOn, framebufIndex!))\n      };\n    },\n\n\n    toggleGrid: (): RootStateThunk => {\n      return (dispatch, getState) => {\n        const state = getState()\n\n\n        const { canvasGrid } = getState().toolbar\n        dispatch(Toolbar.actions.setCanvasGrid(!canvasGrid))\n      }\n    },\n    selectAll: (): RootStateThunk => {\n      return (dispatch, getState) => {\n        const state = getState()\n\n        let width = 1;\n        let height = 1;\n        const framebufIndex = screensSelectors.getCurrentScreenFramebufIndex(state)\n        if (framebufIndex !== null) {\n          const { width: w, height: h } = selectors.getFramebufByIndex(state, framebufIndex)!;\n          width = w;\n          height = h;\n\n          const { framebuf } = selectors.getFramebufByIndex(state, framebufIndex)!;\n\n          const selectAllBrushRegion = {\n            min: { row: 0, col: 0 },\n            max: { row: height - 1, col: width - 1 }\n          }\n\n\n          dispatch(Toolbar.actions.captureBrush(framebuf, selectAllBrushRegion))\n\n\n\n\n        }\n      }\n    },\n\n\n    brushToNew: (): RootStateThunk => {\n      return (dispatch, getState) => {\n\n\n        const state = getState()\n        let colors = {\n          backgroundColor: 0,\n          borderColor: 0\n        }\n        const framebuf = selectors.getCurrentFramebuf(state);\n        if (framebuf !== null) {\n          colors = {\n            backgroundColor: framebuf.backgroundColor,\n            borderColor: framebuf.borderColor\n          }\n        }\n\n\n\n        if (state.toolbar.brush != null) {\n          const brushFramebuf = state.toolbar.brush.framebuf\n          dispatch(Screens.actions.addScreenAndFramebuf());\n          dispatch((dispatch, getState) => {\n            const state = getState()\n            const newFramebufIdx = screensSelectors.getCurrentScreenFramebufIndex(state)\n            if (newFramebufIdx === null) {\n              return;\n            }\n            dispatch(Framebuffer.actions.setFields({\n              ...colors,\n              name: 'Clip_' + newFramebufIdx,\n              borderOn: false,\n            }, newFramebufIdx))\n\n            dispatch(Framebuffer.actions.setDims({\n              width: brushFramebuf[0].length, height: brushFramebuf.length,\n\n            }, newFramebufIdx))\n\n            dispatch(Framebuffer.actions.setFields({\n              framebuf: brushFramebuf\n            }, newFramebufIdx))\n\n          })\n        }\n\n      }\n    },\n\n    setAllBorder: (borderOn: boolean): RootStateThunk => {\n      return (dispatch, getState) => {\n        const state = getState()\n        const currentIndex = screensSelectors.getCurrentScreenFramebufIndex(state)!\n\n\n        const lis = screensSelectors.getScreens(state).map((framebufId, i) => {\n\n          dispatch(Screens.actions.setCurrentScreenIndex(framebufId))\n          dispatch(Framebuffer.actions.setBorderOn(borderOn, framebufId))\n\n\n        })\n        dispatch(Screens.actions.setCurrentScreenIndex(currentIndex))\n      }\n    },\n    setAllBorderFlip: (): RootStateThunk => {\n      return (dispatch, getState) => {\n        const state = getState()\n        const currentIndex = screensSelectors.getCurrentScreenFramebufIndex(state)!\n        const lis = screensSelectors.getScreens(state).map((framebufId, i) => {\n          dispatch(Screens.actions.setCurrentScreenIndex(framebufId));\n          dispatch(Framebuffer.actions.setBorderOn(!state.framebufList[framebufId].present.borderOn, framebufId))\n        })\n        dispatch(Screens.actions.setCurrentScreenIndex(currentIndex))\n      }\n    },\n    setZoom: (level: number, alignment: string): RootStateThunk => {\n      return (dispatch, getState) => {\n        const state = getState()\n\n\n\n        var xCanvas = document.getElementById(\"MainCanvas\");\n        var ParentCanvas = document.getElementById(\"MainCanvas\")?.parentElement;\n        var currentScale = Number(xCanvas?.style.transform.split(',')[3]);\n\n\n\n\n\n\n        let scaleLevel = level + currentScale;\n\n\n        if (ParentCanvas != null) {\n\n          if (scaleLevel > 8)\n            scaleLevel = 8\n\n          if (scaleLevel < .5)\n            scaleLevel = .5\n\n\n\n          if (level > 100)\n            scaleLevel = level - 100;\n\n\n\n\n\n\n          const framebufIndex = screensSelectors.getCurrentScreenFramebufIndex(state)\n          if (framebufIndex != null) {\n            var translateWidth = 0;\n            var translateHeight = 0;\n            let framebufUIState = selectors.getFramebufUIState(state, framebufIndex);\n\n\n            if (alignment == 'center') {\n              translateWidth = (ParentCanvas.offsetWidth / 2) - ((ParentCanvas.getElementsByTagName(\"canvas\")[0].offsetWidth * (scaleLevel)) / 2);\n              translateHeight = (ParentCanvas.offsetHeight / 2) - ((ParentCanvas.getElementsByTagName(\"canvas\")[0].offsetHeight * (scaleLevel)) / 2);\n            }\n\n            let xform = matrix.mult(\n              matrix.translate(Math.trunc(translateWidth), Math.trunc(translateHeight)),\n              matrix.scale(scaleLevel)\n            ) as matrix.Matrix3x3;\n\n            currentScale = Number(xCanvas?.style.transform.split(',')[3]);\n\n            let zoom = {\n              zoomLevel: currentScale,\n              alignment: alignment,\n            };\n\n            dispatch(Framebuffer.actions.setZoom(zoom, framebufIndex));\n\n\n\n            dispatch(Toolbar.actions.setCurrentFramebufUIState({\n              ...framebufUIState,\n              canvasFit: \"nofit\",\n              canvasTransform: xform,\n            }));\n          }\n\n        }\n\n      }\n\n\n    },\n\n    setAllZoom: (level: number, alignment: string): RootStateThunk => {\n      return (dispatch, getState) => {\n        const state = getState()\n\n        const currentIndex = screensSelectors.getCurrentScreenFramebufIndex(state)!\n\n\n        const lis = screensSelectors.getScreens(state).map((framebufId, i) => {\n\n          dispatch(Screens.actions.setCurrentScreenIndex(framebufId))\n          dispatch(Toolbar.actions.setZoom(level, alignment))\n\n        })\n        dispatch(Screens.actions.setCurrentScreenIndex(currentIndex))\n\n      }\n\n\n\n\n    },\n\n    pasteText: (): RootStateThunk => {\n      return (dispatch, getState) => {\n        const state = getState()\n\n        //TEST TEXT 1234567898\n\n        let width = 1;\n        let height = 1;\n        const framebufIndex = screensSelectors.getCurrentScreenFramebufIndex(state)\n        if (framebufIndex !== null) {\n          const { width: w, height: h } = selectors.getFramebufByIndex(state, framebufIndex)!;\n          width = w;\n          height = h;\n        }\n\n\n        if (state.toolbar.textCursorPos != null) {\n          const { textCursorPos, textColor } = state.toolbar\n          const clip = \"\" + electron.clipboard.readText().toString()\n\n          if (clip != null) {\n            if (electron.clipboard.availableFormats().includes(\"text/plain\")) {\n              if (state.toolbar.selectedTool == Tool.Text) {\n\n                let coords = { col: 0, row: 0 }\n                let enters = 0;\n                let charcount = 0;\n                [...clip].forEach(char => {\n                  if (asc2int(char) == 13) {\n                    enters++;\n                    charcount = 0;\n                  }\n                  coords = { col: textCursorPos.col + charcount, row: textCursorPos.row + enters }\n                  let c = convertAsciiToScreencode(state.toolbar.shiftKey ? char.toUpperCase() : char)\n                  if (c != null) {\n                    dispatch(Framebuffer.actions.setPixel({\n                      ...coords,\n                      screencode: c,\n                      color: textColor,\n                    }, null, framebufIndex));\n                    charcount++;\n                  }\n                });\n                const newCursorPos = moveTextCursor(\n                  textCursorPos,\n                  { col: charcount, row: enters },\n                  width, height\n                )\n                dispatch(Toolbar.actions.setTextCursorPos(newCursorPos))\n\n              }\n\n            }\n\n          }\n        }\n\n\n      }\n    },\n\n  }\n\n  static reducer(state: IToolbar = {\n    ...initialBrushValue,\n    selectedChar: { row: 8, col: 0 },\n    charTransform: emptyTransform,\n    undoId: 0,\n    textColor: 14,\n    textCursorPos: null as (Coord2 | null),\n    selectedTool: Tool.Draw,\n    brushRegion: null as (BrushRegion | null),\n    brush: null as (Brush | null),\n    workspaceFilename: null as (string | null),\n    altKey: false,\n    ctrlKey: false,\n    tabKey: false,\n    metaKey: false,\n    shiftKey: false,\n    spacebarKey: false,\n    capslockKey: false,\n    showSettings: false,\n    showResizeSettings: false,\n    resizeWidth: 40,\n    resizeHeight: 25,\n    resizeCrop: true,\n    showProgressModal: false,\n    progressTitle:'',\n    progressValue:0,\n    showCustomFonts: false,\n    showExport: { show: false },\n    showImport: { show: false },\n    selectedPaletteRemap: 0,\n    canvasGrid: false,\n    shortcutsActive: true,\n    newScreenSize: { width: DEFAULT_FB_WIDTH, height: DEFAULT_FB_HEIGHT },\n    framebufUIState: {}\n  }, action: Actions) {\n    switch (action.type) {\n      case RESET_BRUSH:\n        return {\n          ...state,\n          ...initialBrushValue\n        }\n      case CAPTURE_BRUSH:\n        return {\n          ...state,\n          ...initialBrushValue,\n          brush: action.data\n        }\n\n      case SET_SELECTED_CHAR:\n        const rc = action.data\n        return {\n          ...state,\n          selectedChar: rc,\n          charTransform: emptyTransform\n        }\n      case NEXT_CHARCODE: {\n        const { dir, font } = action.data\n        const rc = selectors.getCharRowColWithTransform(state.selectedChar, font, state.charTransform)\n        return {\n          ...state,\n          selectedChar: {\n            row: Math.max(0, Math.min(15, rc.row + dir.row)),\n            col: Math.max(0, Math.min(15, rc.col + dir.col)),\n          },\n          charTransform: emptyTransform\n        }\n      }\n      case INVERT_CHAR: {\n        const font = action.data\n        const curScreencode = selectors.getScreencodeWithTransform(state.selectedChar, font, state.charTransform)\n        const inverseRowCol = utils.rowColFromScreencode(font, brush.findInverseChar(font, curScreencode))\n        return {\n          ...state,\n          selectedChar: inverseRowCol,\n          charTransform: emptyTransform\n        }\n      }\n      case INVERT_SINGLE_CHAR: {\n        const { font, code } = action.data\n        const curScreencode = code\n        const inverseRowCol = utils.rowColFromScreencode(font, brush.findInverseChar(font, curScreencode))\n        return {\n          ...state,\n          selectedChar: inverseRowCol,\n          charTransform: emptyTransform\n        }\n      }\n      case INVERT_BRUSH: {\n        return {\n          ...state,\n          ...initialBrushValue,\n          brush: action.data\n        }\n\n      }\n      case NEXT_COLOR: {\n        const remap = action.data.paletteRemap;\n        const idx = remap.indexOf(state.textColor);\n        const dir = action.data.dir;\n        const nextIdx = Math.max(0, Math.min(15, idx + dir));\n        return {\n          ...state,\n          textColor: remap[nextIdx]\n        }\n      }\n      case SET_COLOR: {\n        const remap = action.data.paletteRemap;\n        const slot = action.data.slot;\n        return {\n          ...state,\n          textColor: remap[slot]\n        }\n      }\n      case INC_UNDO_ID:\n        return {\n          ...state,\n          undoId: state.undoId + 1\n        }\n      case SET_FRAMEBUF_UI_STATE: {\n        return {\n          ...state,\n          framebufUIState: {\n            ...state.framebufUIState,\n            [action.data.framebufIndex]: action.data.uiState || defaultFramebufUIState\n          }\n        }\n      }\n      case MIRROR_BRUSH:\n        return {\n          ...state,\n          brushTransform: mirror(state.brushTransform, action.data)\n        }\n      case ROTATE_BRUSH:\n        return {\n          ...state,\n          brushTransform: rotate(state.brushTransform, action.data)\n        }\n      case MIRROR_CHAR:\n        return {\n          ...state,\n          charTransform: mirror(state.charTransform, action.data)\n        }\n      case ROTATE_CHAR:\n        return {\n          ...state,\n          charTransform: rotate(state.charTransform, action.data)\n        }\n      case CLEAR_MOD_KEY_STATE:\n        return {\n          ...state,\n          altKey: false,\n          ctrlKey: false,\n          tabKey: false,\n          metaKey: false,\n          shiftKey: false,\n          capsLockKey: false,\n        }\n      case 'Toolbar/SET_TEXT_COLOR':\n        return updateField(state, 'textColor', action.data);\n      case 'Toolbar/SET_TEXT_CURSOR_POS':\n        return updateField(state, 'textCursorPos', action.data);\n      case 'Toolbar/SET_SELECTED_TOOL':\n        return updateField(state, 'selectedTool', action.data);\n      case 'Toolbar/SET_BRUSH_REGION':\n        return updateField(state, 'brushRegion', action.data);\n      case 'Toolbar/SET_BRUSH':\n        return updateField(state, 'brush', action.data);\n      case 'Toolbar/SET_WORKSPACE_FILENAME':\n        return updateField(state, 'workspaceFilename', action.data);\n      case 'Toolbar/SET_ALT_KEY':\n        return updateField(state, 'altKey', action.data);\n      case 'Toolbar/SET_CTRL_KEY':\n        return updateField(state, 'ctrlKey', action.data);\n      case 'Toolbar/SET_TAB_KEY':\n        return updateField(state, 'tabKey', action.data);\n      case 'Toolbar/SET_META_KEY':\n        return updateField(state, 'metaKey', action.data);\n      case 'Toolbar/SET_SHIFT_KEY':\n        return updateField(state, 'shiftKey', action.data);\n      case 'Toolbar/SET_CAPSLOCK_KEY':\n        return updateField(state, 'capslockKey', action.data);\n\n      case 'Toolbar/SET_SPACEBAR_KEY':\n        return updateField(state, 'spacebarKey', action.data);\n      case 'Toolbar/SET_SHOW_SETTINGS':\n        return updateField(state, 'showSettings', action.data);\n      case 'Toolbar/SET_SHOW_PROGRESSMODAL':\n        return updateField(state, 'showProgressModal', action.data);\n        case 'Toolbar/SET_PROGRESSTITLE':\n          return updateField(state, 'progressTitle', action.data);\n          case 'Toolbar/SET_PROGRESSVALUE':\n            return updateField(state, 'progressValue', action.data);\n            case 'Toolbar/SET_SHOW_RESIZESETTINGS':\n              return updateField(state, 'showResizeSettings', action.data);\n\n\n      case 'Toolbar/SET_RESIZEWIDTH':\n        console.log('Toolbar/SET_RESIZEWIDTH', action.data)\n        return updateField(state, 'resizeWidth', action.data);\n      case 'Toolbar/SET_RESIZEHEIGHT':\n        return updateField(state, 'resizeHeight', action.data);\n      case 'Toolbar/SET_RESIZECROP':\n        return updateField(state, 'resizeCrop', action.data);\n      case 'Toolbar/SET_SHOW_CUSTOM_FONTS':\n        return updateField(state, 'showCustomFonts', action.data);\n      case 'Toolbar/SET_SHOW_EXPORT':\n        return updateField(state, 'showExport', action.data);\n      case 'Toolbar/SET_SHOW_IMPORT':\n        return updateField(state, 'showImport', action.data);\n      case 'Toolbar/SET_SELECTED_PALETTE_REMAP':\n        return updateField(state, 'selectedPaletteRemap', action.data);\n      case 'Toolbar/SET_CANVAS_GRID':\n        return updateField(state, 'canvasGrid', action.data);\n      case 'Toolbar/SET_SHORTCUTS_ACTIVE':\n        return updateField(state, 'shortcutsActive', action.data);\n      case 'Toolbar/SET_NEW_SCREEN_SIZE':\n        return updateField(state, 'newScreenSize', action.data);\n\n      default:\n        return state;\n    }\n  }\n\n  static bindDispatch(dispatch: Dispatch) {\n    return bindActionCreators(Toolbar.actions, dispatch)\n  }\n}\n","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\redux\\root.ts",["328"],"\nimport { Action } from 'redux'\nimport { ThunkAction } from 'redux-thunk';\nimport { ActionCreators } from 'redux-undo';\n\nimport * as selectors from './selectors'\nimport {\n  getSettingsCurrentColorPalette\n} from '../redux/settingsSelectors'\n\nimport {\n  Framebuf,\n  RootState,\n  FileFormat,\n  SettingsJson,\n  RootStateThunk\n} from './types'\nimport { ActionsUnion, createAction } from './typeUtils'\nimport { Framebuffer } from './editor'\nimport * as settings from './settings'\nimport * as workspace from './workspace'\nimport * as screensSelectors from '../redux/screensSelectors'\nimport { Toolbar } from './toolbar'\nimport {\n  dialogLoadWorkspace,\n  dialogSaveAsWorkspace,\n  dialogExportFile,\n  dialogImportFile,\n  saveWorkspace,\n  xImportFile,\n  loadSettings,\n  promptProceedWithUnsavedChanges,\n  setWorkspaceFilenameWithTitle\n} from '../utils'\n\nimport { importFramebufs } from './workspace'\n\nimport { fs, electron } from '../utils/electronImports'\n\nexport const RESET_STATE = 'RESET_STATE'\nexport const LOAD_WORKSPACE = 'LOAD_WORKSPACE'\nexport const UPDATE_LAST_SAVED_SNAPSHOT = 'UPDATE_LAST_SAVED_SNAPSHOT'\n\nfunction saveAsWorkspace(): ThunkAction<void, RootState, undefined, Action> {\n  return (dispatch, getState) => {\n    const state = getState();\n    const screens = screensSelectors.getScreens(state);\n    const getFramebufByIndex = (idx: number) => selectors.getFramebufByIndex(state, idx)!;\n    const customFontMap = selectors.getCustomFonts(state);\n    dialogSaveAsWorkspace(\n      screens,\n      getFramebufByIndex,\n      customFontMap,\n      (filename: string) => dispatch(Toolbar.actions.setWorkspaceFilename(filename)),\n      () => dispatch(actionCreators.updateLastSavedSnapshot())\n    );\n  }\n}\n\nexport const actionCreators = {\n  loadWorkspace: (data: any) => createAction(LOAD_WORKSPACE, data),\n  // Snapshot current framebuf and screens state for \"ask for unsaved changed\"\n  // dialog when loading or resetting Petmate workspace.\n  updateLastSavedSnapshot: () => createAction(UPDATE_LAST_SAVED_SNAPSHOT),\n  resetStateAction: () => createAction(RESET_STATE)\n};\n\nexport type Actions = ActionsUnion<typeof actionCreators>\n\nexport const actions = {\n  ...actionCreators,\n\n  // Load workspace but with specific file name and no dialogs\n  openWorkspace: (filename: string): RootStateThunk => {\n    return (dispatch, getState) => {\n      if (promptProceedWithUnsavedChanges(getState(), {\n        title: 'Continue',\n        detail: 'Proceed with loading a Petmate workspace?  This cannot be undone.'\n      })) {\n        try {\n          const content = fs.readFileSync(filename, 'utf-8')\n          const c = JSON.parse(content);\n          dispatch(workspace.load(c));\n          setWorkspaceFilenameWithTitle(\n            () => dispatch(Toolbar.actions.setWorkspaceFilename(filename)),\n            filename\n          );\n\n        } catch(e) {\n          console.error(e)\n          alert(`Failed to load workspace '${filename}'!`)\n        }\n      }\n    }\n  },\n\n\n  openImportFile: (type: FileFormat,filename: string): RootStateThunk => {\n    return (dispatch, getState) => {\n\n        try {\n         // const content = fs.readFileSync(filename, 'utf-8')\n        //  const c = JSON.parse(content);\n          //dispatch(workspace.load(c));\n\n         const state = getState()\n         const framebufIndex = screensSelectors.getCurrentScreenFramebufIndex(state)\n          xImportFile(filename,type, (framebufs: Framebuf[]) => {\n            dispatch(importFramebufs(framebufs, true));\n          })\n\n        } catch(e) {\n          console.error(e)\n          alert(`Failed import '${filename}'!`)\n        }\n\n    }\n  },\n  // Same as openWorkspace but pop a dialog asking for the filename\n  fileOpenWorkspace: (): RootStateThunk => {\n    return (dispatch, _getState) => {\n      dialogLoadWorkspace(dispatch);\n    }\n  },\n\n  fileSaveAsWorkspace: saveAsWorkspace,\n\n  fileSaveWorkspace: (): RootStateThunk => {\n    return (dispatch, getState) => {\n      const state = getState();\n      const screens = screensSelectors.getScreens(state);\n      const getFramebufByIndex = (idx: number) => selectors.getFramebufByIndex(state, idx)!;\n      const customFonts = selectors.getCustomFonts(state);\n      const filename = state.toolbar.workspaceFilename;\n      if (filename === null) {\n        return dispatch(saveAsWorkspace());\n      }\n      saveWorkspace(\n        filename,\n        screens,\n        getFramebufByIndex,\n        customFonts,\n        () => dispatch(actionCreators.updateLastSavedSnapshot())\n      );\n    }\n  },\n\n  fileImport: (type: FileFormat): RootStateThunk => {\n    return (dispatch, getState) => {\n      const state = getState()\n      const framebufIndex = screensSelectors.getCurrentScreenFramebufIndex(state)\n      if (framebufIndex === null) {\n        return;\n      }\n      dialogImportFile(type, (framebufs: Framebuf[]) => {\n        dispatch(Framebuffer.actions.importFile(framebufs[0], framebufIndex))\n      })\n    }\n  },\n\n  importFramebufsAppend: (framebufs: Framebuf[]): RootStateThunk => {\n    return (dispatch, _getState) => {\n      dispatch(importFramebufs(framebufs, true));\n    };\n  },\n\n  fileImportAppend: (type: FileFormat): RootStateThunk => {\n    return (dispatch, _getState) => {\n      dialogImportFile(type, (framebufs: Framebuf[]) => {\n\n        if(type.ext==\"prg\")\n        {\n        dispatch(Toolbar.actions.setProgressTitle('Importing CBASE file...'))\n        dispatch(Toolbar.actions.setShowProgressModal(true))\n\n\n        setTimeout(function(){\n        dispatch(importFramebufs(framebufs, true));\n        setTimeout(function(){\n          dispatch(Toolbar.actions.setShowProgressModal(false))\n\n        },100)\n      },100)\n    }\n    else\n    {\n      dispatch(importFramebufs(framebufs, true));\n\n\n    }\n\n\n      })\n    }\n  },\n\n  fileExportAs: (fmt: FileFormat): RootStateThunk => {\n    return (_dispatch, getState) => {\n      const state = getState()\n      const screens = screensSelectors.getScreens(state)\n      let remappedFbIndex = 0\n      const selectedFramebufIndex = screensSelectors.getCurrentScreenFramebufIndex(state)\n      const framebufs = screens.map((fbIdx, i) => {\n        const framebuf = selectors.getFramebufByIndex(state, fbIdx)\n        if (!framebuf) {\n          throw new Error('invalid framebuf');\n        }\n        if (selectedFramebufIndex === fbIdx) {\n          remappedFbIndex = i\n        }\n        const { font } = selectors.getFramebufFont(state, framebuf);\n        return {\n          ...framebuf,\n          font\n        }\n      })\n      const palette = getSettingsCurrentColorPalette(state)\n      const amendedFormatOptions: FileFormat = {\n        ...fmt,\n        commonExportParams: {\n          selectedFramebufIndex: remappedFbIndex\n        }\n      }\n      dialogExportFile(amendedFormatOptions, framebufs, state.customFonts, palette);\n    }\n  },\n\n  resetState: (): RootStateThunk => {\n    return (dispatch, _getState) => {\n      dispatch(actionCreators.resetStateAction());\n      loadSettings((j: SettingsJson) => dispatch(settings.actions.load(j)))\n    }\n  },\n\n  undo: ():  RootStateThunk => {\n    return (dispatch, getState) => {\n      const framebufIndex = screensSelectors.getCurrentScreenFramebufIndex(getState())\n      dispatch({\n        ...ActionCreators.undo(),\n        framebufIndex\n      })\n    }\n  },\n  redo: (): RootStateThunk => {\n    return (dispatch, getState) => {\n      const framebufIndex = screensSelectors.getCurrentScreenFramebufIndex(getState())\n      dispatch({\n        ...ActionCreators.redo(),\n        framebufIndex\n      })\n    }\n  }\n}\n","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\redux\\types.ts",["329"],"\nimport { StateWithHistory } from 'redux-undo'\nimport { Action } from 'redux'\nimport { ThunkAction } from 'redux-thunk'\nimport { FileFormat } from './typesExport';\nimport { Matrix3x3 } from '../utils/matrix';\n\nexport const DEFAULT_FB_WIDTH = 40;\nexport const DEFAULT_FB_HEIGHT = 25;\n\nexport interface Coord2 {\n  row: number;\n  col: number;\n};\n\nexport interface Pixel {\n  code: number;\n  color: number;\n};\n\nexport interface Font {\n  bits: number[];\n  charOrder: number[];\n};\n\nexport interface Framebuf {\n  readonly framebuf: Pixel[][];\n  readonly width: number;\n  readonly height: number;\n  readonly backgroundColor: number;\n  readonly borderColor: number;\n  readonly borderOn: boolean;\n  readonly charset: string;\n  readonly name?: string;\n  readonly zoom: {zoomLevel:number,alignment:string};\n  readonly zoomReady: boolean;\n};\n\n// This is the basically the same as the redux Framebuf except\n// that it's been amended with some extra fields with selectors\n// when an export is initiated.\nexport interface FramebufWithFont extends Framebuf {\n  font: Font;\n}\n\nexport interface Rgb {\n  r: number;\n  g: number;\n  b: number;\n}\n\nexport type Zoom = {zoomLevel:number,alignment:string};\n\nexport type RgbPalette = Rgb[];\n\nexport type Angle360 = 0 | 90 | 180 | 270;\n\nexport interface Transform {\n  mirror: number; // TODO ts\n  rotate: Angle360;\n}\n\nexport interface BrushRegion {\n  min: Coord2;\n  max: Coord2;\n}\n\nexport type Brush = any;\n\nexport type PaletteName = 'petmate' | 'colodore' | 'pepto' | 'vice';\n\nexport type EditBranch = 'saved' | 'editing';\n\nexport type ResizeBranch = 'width' | 'height' | 'dir';\n\n\nexport type EditSaved<T> = {\n  [k in EditBranch]: T;\n};\n\nexport type ResizeSaved<T> = {\n  [k in ResizeBranch]: T;\n};\nexport enum  BrushType {\n  CharsColors = 0,\n  CharsOnly = 1,\n  ColorsOnly = 2,\n  ColorStamp = 3,\n  Raw = 4\n\n}\n\nexport interface Settings {\n  palettes: number[][];\n  selectedColorPalette: PaletteName;\n  integerScale: boolean;\n};\n\n\nexport interface Screens {\n  current: number;\n  list: number[];\n};\n\n\nexport enum Tool {\n  Draw = 0,\n  Colorize = 1,\n  CharDraw = 2,\n  Brush = 3,\n  Text = 4,\n  PanZoom = 5,\n  FloodFill = 6\n};\n\n// Per screen UI state\nexport interface FramebufUIState {\n  canvasTransform: Matrix3x3;\n  canvasFit: 'fitWidth' | 'fitWidthHeight' | 'fitHeight' | 'nofit';\n};\n\nexport interface Toolbar {\n  brush: Brush | null;\n  brushRegion: BrushRegion | null;\n  brushTransform: Transform;\n  selectedChar: Coord2;\n  charTransform: Transform;\n  undoId: number;\n  textColor: number;\n  textCursorPos: Coord2|null;\n  selectedTool: Tool;\n  workspaceFilename: string|null;\n  altKey: boolean;\n  ctrlKey: boolean;\n  tabKey: boolean;\n  metaKey: boolean;\n  shiftKey: boolean;\n  capslockKey: boolean;\n  spacebarKey: boolean;\n  showSettings: boolean;\n  showResizeSettings: boolean;\n  resizeWidth: number;\n  resizeHeight: number;\n  resizeCrop: boolean;\n  showProgressModal: boolean;\n  progressTitle:string;\n  progressValue:number;\n  showCustomFonts: boolean;\n  showExport: { show: boolean, fmt?: FileFormat}; // fmt undefined only when show=false\n  showImport: { show: boolean, fmt?: FileFormat}; // fmt undefined only when show=false\n  selectedPaletteRemap: number;\n  canvasGrid: boolean;\n  shortcutsActive: boolean;\n\n\n  newScreenSize: { width: number, height: number };\n\n  framebufUIState: {[framebufIndex: number]: FramebufUIState};\n}\n\nexport type UndoableFramebuf = StateWithHistory<Framebuf>;\n\nexport type LastSavedState = {\n  screenList: Screens['list'];\n  framebufs: Framebuf[];\n};\n\n\n\nexport interface RootState {\n  settings: {\n    saved: Settings;\n    editing: Settings;\n  };\n\n  toolbar: Toolbar;\n  screens: Screens;\n  customFonts: { [name: string]: {font: Font, name: string} };\n  framebufList: UndoableFramebuf[];\n  lastSavedSnapshot: LastSavedState;\n};\n\nexport type RootStateThunk = ThunkAction<void, RootState, undefined, Action>;\n\nexport type SettingsJson = any;\n\n// Interface describing the custom fonts chunks in\n// .petmate workspace version == 2\nexport type WsCustomFontsV2 = {\n  [id: string]: {\n    name: string,\n    font: {\n      bits: number[],\n      charOrder: number[]\n    }\n  }\n};\n\nexport * from './typesExport'\n","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\redux\\screens.ts",["330"],"\nimport { Action } from 'redux'\nimport { ThunkAction } from 'redux-thunk';\n\nimport * as selectors from './selectors'\nimport {\n  getScreens,\n  getCurrentScreenIndex,\n  getCurrentScreenFramebufIndex\n} from './screensSelectors'\n\nimport {\n  Framebuffer,\n  DEFAULT_BACKGROUND_COLOR,\n  DEFAULT_BORDER_COLOR,\n  CHARSET_DIRART,\n  CHARSET_C128_UPPER,\n  CHARSET_C16_UPPER,\n  CHARSET_C64SE_UPPER,\n  CHARSET_PET_UPPER,\n  CHARSET_VIC20_UPPER,\n  CHARSET_UPPER,\n\n} from './editor'\n\nimport { Toolbar } from './toolbar';\n\nimport {\n  FramebufWithFont,\n  RootState,\n  Screens\n} from './types'\nimport { ActionsUnion, createAction, DispatchPropsFromActions } from './typeUtils'\n\nimport { makeScreenName, makeDirArtName } from './utils'\nimport { arrayMove } from '../external/react-sortable-hoc'\nimport * as fp from '../utils/fp'\nimport { promptProceedWithUnsavedChangesInFramebuf } from '../utils';\n\nexport const ADD_SCREEN_AND_FRAMEBUF = 'ADD_SCREEN_AND_FRAMEBUF'\n\nconst ADD_SCREEN = 'ADD_SCREEN'\nconst REMOVE_SCREEN = 'REMOVE_SCREEN'\nconst SET_CURRENT_SCREEN_INDEX = 'SET_CURRENT_SCREEN_INDEX'\nconst SET_SCREEN_ORDER = 'SET_SCREEN_ORDER'\nconst NEXT_SCREEN = 'NEXT_SCREEN'\nconst ADD_DIRART = 'ADD_DIRART'\nconst MOVE_SCREEN = 'MOVE_SCREEN'\n\ninterface AddScreenArgs {\n  framebufId: number;\n  insertAfterIndex: number;\n};\n\nconst actionCreators = {\n  addScreen: (framebufId: number, insertAfterIndex: number) => createAction(ADD_SCREEN, { framebufId, insertAfterIndex } as AddScreenArgs),\n  addScreenAndFramebuf: (insertAfterIndex?: number) => createAction(ADD_SCREEN_AND_FRAMEBUF, insertAfterIndex),\n  removeScreenAction: (index: number) => createAction(REMOVE_SCREEN, index),\n  moveScreen: (dir: number) => createAction(MOVE_SCREEN, dir),\n  setCurrentScreenIndex: (index: number) => createAction(SET_CURRENT_SCREEN_INDEX, index),\n  setScreenOrder: (screens: number[]) => createAction(SET_SCREEN_ORDER, screens),\n  nextScreen: (dir: number) => createAction(NEXT_SCREEN, dir),\n  addDirArt: (framebufId: number, insertAfterIndex: number) => createAction(ADD_DIRART, { framebufId, insertAfterIndex } as AddScreenArgs)\n};\n\nfunction removeScreen(index: number): ThunkAction<void, RootState, undefined, Action>  {\n  return (dispatch, getState) => {\n    const state = getState()\n    const numScreens = getScreens(state).length\n    if (numScreens <= 1) {\n      // Don't allow deletion of the last framebuffer\n      return;\n    }\n    if (promptProceedWithUnsavedChangesInFramebuf(state, state.screens.list[index], {\n      title: 'Remove',\n      detail: 'Removing the screen cannot be undone.'\n    })) {\n      if(index==-1)\n        index = getCurrentScreenIndex(state)\n      dispatch(actions.setCurrentScreenIndex(index === numScreens - 1 ? numScreens - 2 : index))\n      dispatch(actions.removeScreenAction(index));\n    }\n  }\n}\n\n\nfunction moveScreen(dir: number): ThunkAction<void, RootState, undefined, Action>  {\n  return (dispatch, getState) => {\n\n\n    const state = getState()\n    const lastIdx = getScreens(state).length-1\n\n    const idx = getCurrentScreenIndex(state)\n    var screens = getScreens(state);\n    const destIdx =  idx + dir\n\n    if(destIdx>=0 && destIdx<=lastIdx)\n     dispatch(actions.setScreenOrder( arrayMove(screens, idx, destIdx)))\n\n\n\n\n  }\n}\n\nfunction addScreenPlusFramebuf(index: number, fb:any): ThunkAction<void, RootState, undefined, Action>  {\n  console.log('addScreenPlusFramebuf:',index,fb.name);\n  return (dispatch, getState) => {\n    const state = getState()\n    index = getCurrentScreenIndex(state)\n    dispatch(actionCreators.addScreenAndFramebuf\n      (index));\n    dispatch((dispatch, getState) => {\n      const state = getState()\n      const newScreenIdx = getCurrentScreenIndex(state)\n      const newFramebufIdx = getScreens(state)[newScreenIdx]\n\n      console.log('total screens', getScreens(state).length,getScreens(state))\n      console.log('addScreenPlusFramebuf_action:',newFramebufIdx,newFramebufIdx,fb.name);\n\n      dispatch(Framebuffer.actions.copyFramebuf({\n        ...fb,\n      }, newFramebufIdx));\n      dispatch(Toolbar.actions.setFramebufUIState(newFramebufIdx, selectors.getFramebufUIState(state, index)));\n    })\n  }\n}\n\n\nfunction cloneScreen(index: number): ThunkAction<void, RootState, undefined, Action>  {\n  return (dispatch, getState) => {\n    const state = getState()\n    if(index==-1)\n    {\n      index = getCurrentScreenIndex(state)\n    }\n    const fbidx = getScreens(state)[index]\n    const framebuf = selectors.getFramebufByIndex(state, fbidx);\n    if (framebuf === null) {\n      return;\n    }\n    dispatch(actionCreators.addScreenAndFramebuf(index));\n    dispatch((dispatch, getState) => {\n      const state = getState()\n      const newScreenIdx = getCurrentScreenIndex(state)\n      const newFramebufIdx = getScreens(state)[newScreenIdx]\n      dispatch(Framebuffer.actions.copyFramebuf({\n        ...framebuf,\n        name: makeScreenName(newFramebufIdx)\n      }, newFramebufIdx));\n      dispatch(Toolbar.actions.setFramebufUIState(newFramebufIdx, selectors.getFramebufUIState(state, fbidx)));\n    })\n  }\n}\n\nfunction newScreen(): ThunkAction<void, RootState, undefined, Action> {\n  return (dispatch, getState) => {\n    const state = getState()\n    let colors = {\n      backgroundColor: DEFAULT_BACKGROUND_COLOR,\n      borderColor: DEFAULT_BORDER_COLOR\n    }\n    const framebuf = selectors.getCurrentFramebuf(state);\n    if (framebuf !== null) {\n      colors = {\n        backgroundColor: framebuf.backgroundColor,\n        borderColor: framebuf.borderColor\n      }\n    }\n    const zoom = {zoomLevel:10,alignment:'left'}\n\n    dispatch(actions.addScreenAndFramebuf());\n    dispatch((dispatch, getState) => {\n      const state = getState()\n      const newFramebufIdx = getCurrentScreenFramebufIndex(state)\n      if (newFramebufIdx === null) {\n        return;\n      }\n      dispatch(Framebuffer.actions.setFields({\n        ...colors,\n        ...zoom,\n        name: makeScreenName(newFramebufIdx)\n      }, newFramebufIdx))\n    })\n  }\n}\n\nfunction newDirArt(): ThunkAction<void, RootState, undefined, Action> {\n  return (dispatch, getState) => {\n    const state = getState()\n    let colors = {\n      backgroundColor: DEFAULT_BACKGROUND_COLOR,\n      borderColor: DEFAULT_BORDER_COLOR\n    }\n    const framebuf = selectors.getCurrentFramebuf(state);\n    if (framebuf !== null) {\n      colors = {\n        backgroundColor: framebuf.backgroundColor,\n        borderColor: framebuf.borderColor\n      }\n    }\n    dispatch(actions.addScreenAndFramebuf());\n    dispatch((dispatch, getState) => {\n      const state = getState()\n      const newFramebufIdx = getCurrentScreenFramebufIndex(state)\n      if (newFramebufIdx === null) {\n        return;\n      }\n      dispatch(Framebuffer.actions.setFields({\n        ...colors,\n        zoom: {zoomLevel:8,alignment:'left'},\n        name: makeDirArtName(newFramebufIdx)\n      }, newFramebufIdx))\n\n      dispatch(Framebuffer.actions.setCharset(CHARSET_DIRART\n      , newFramebufIdx))\n\n      dispatch(Framebuffer.actions.setBorderOn(false,newFramebufIdx))\n\n\n\n      dispatch(Framebuffer.actions.setDims({\n        width:16,height:32,\n\n      }, newFramebufIdx))\n    })\n  }\n}\n\n\nfunction newScreenX(screenType:string,dimensions:string, border:boolean): ThunkAction<void, RootState, undefined, Action> {\n  return (dispatch, getState) => {\n    const state = getState()\n    let colors = {\n      backgroundColor: DEFAULT_BACKGROUND_COLOR,\n      borderColor: DEFAULT_BORDER_COLOR\n    }\n    let foreColor = 14;\n    let CHARSET = CHARSET_UPPER;\n    switch (screenType) {\n      case 'pet':\n        colors = {\n          backgroundColor: 0,\n          borderColor: 0\n        };\n        CHARSET = CHARSET_PET_UPPER;\n        break;\n      case 'c16':\n        colors = {\n          backgroundColor: 1,\n          borderColor: 15\n        };\n        CHARSET = CHARSET_C16_UPPER;\n        break;\n      case 'vic20':\n        colors = {\n          backgroundColor: 1,\n          borderColor: 3\n        };\n        CHARSET = CHARSET_VIC20_UPPER;\n        break;\n      case 'c128':\n        colors = {\n          backgroundColor: 11,\n          borderColor: 13\n        };\n        CHARSET = CHARSET_C128_UPPER;\n        break;\n        case 'c64se':\n          CHARSET = CHARSET_C64SE_UPPER;\n          break;\n          case 'dirart':\n            CHARSET = CHARSET_DIRART;\n            break;\n\n      }\n\n   //   console.log('newScreenX',screenType,dimensions,colors,border);\n\n    const width=Number(dimensions.split('x')[0]);\n    const height=Number(dimensions.split('x')[1]);\n\n    dispatch(actions.addScreenAndFramebuf());\n    dispatch((dispatch, getState) => {\n      const state = getState()\n      const newFramebufIdx = getCurrentScreenFramebufIndex(state)\n      if (newFramebufIdx === null) {\n        return;\n      }\n      dispatch(Framebuffer.actions.setFields({\n        ...colors,\n        zoom: {zoomLevel:8,alignment:'left'},\n        name: screenType+\"_\"+ makeScreenName(newFramebufIdx)\n      }, newFramebufIdx))\n\n      dispatch(Framebuffer.actions.setCharset(CHARSET\n      , newFramebufIdx))\n\n      dispatch(Framebuffer.actions.setBorderOn(border,newFramebufIdx))\n      dispatch(Toolbar.actions.setColor(foreColor));\n\n      dispatch(Framebuffer.actions.setDims({\n        width,height,\n\n      }, newFramebufIdx))\n    })\n  }\n}\n\n\nexport const actions = {\n  ...actionCreators,\n  removeScreen,\n  moveScreen,\n  cloneScreen,\n  newScreen,\n  newDirArt,\n  newScreenX,\n  addScreenPlusFramebuf,\n\n}\n\n\n\nexport type Actions = ActionsUnion<typeof actionCreators>;\nexport type PropsFromDispatch = DispatchPropsFromActions<typeof actions>;\n\nexport function reducer(state: Screens = {current: 0, list: []}, action: Actions): Screens {\n  switch (action.type) {\n    case ADD_SCREEN:\n      const insertAfter = action.data.insertAfterIndex\n      return {\n        ...state,\n        list: fp.arrayInsertAt(state.list, insertAfter + 1, action.data.framebufId)\n      }\n    case REMOVE_SCREEN:\n      return {\n        ...state,\n        list: fp.arrayRemoveAt(state.list, action.data)\n      }\n    case SET_CURRENT_SCREEN_INDEX:\n      return {\n        ...state,\n        current: action.data\n      }\n    case SET_SCREEN_ORDER: {\n      const newScreenIdx = action.data\n      const newCurrentScreen = newScreenIdx.indexOf(state.list[state.current])\n      return {\n        ...state,\n        list: newScreenIdx,\n        current: newCurrentScreen\n      }\n    }\n    case NEXT_SCREEN:\n      return {\n        ...state,\n        current: Math.min(state.list.length - 1, Math.max(0, state.current + action.data))\n      }\n\n    case ADD_DIRART:\n      const insertdAfter = action.data.insertAfterIndex\n      return {\n        ...state,\n        list: fp.arrayInsertAt(state.list, insertdAfter+1, action.data.framebufId)\n      }\n  default:\n    return state\n  }\n}\n","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\containers\\Root.tsx",[],"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\store\\configureStore.prod.js",[],"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\store\\configureStore.dev.js",[],"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\redux\\utils.js",[],"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\index.ts",["331"],"import { loadMarqCFramebuf, loadD64Framebuf, loadSeq, loadCbase } from './importers'\nimport {\n  savePNG,\n  saveMarqC,\n  saveExecutablePRG,\n  saveExecutablePlayer,\n  saveAsm,\n  saveBASIC,\n  saveGIF,\n  saveJSON,\n  saveSEQ,\n  savePET,\n  saveD64,\n  saveCbase,\n  savePlayer\n} from './exporters'\n\nimport {\n  drawLine\n} from './line'\n\nimport { colorPalettes } from './palette'\n\nimport { electron, fs, path, buffer} from './electronImports'\nimport {\n  FileFormat, Rgb, Font, Coord2, Framebuf, Settings,\n  FramebufWithFont,\n  RootState,\n  WsCustomFontsV2,\n  FileFormatCbase,\n  FileFormatPlayerV1\n} from '../redux/types';\n\nimport * as ReduxRoot from '../redux/root';\nimport * as selectors from '../redux/selectors';\nimport * as customFonts from '../redux/customFonts'\n\n\n\n\n\n//const { ipcRenderer } = electron\n\n// TODO import VICE VPL files\n\nconst defaultExportCommon = {\n  selectedFramebufIndex: 0\n}\n\n// TODO ts use FileFormat type\nexport const formats: { [index: string]: FileFormat } = {\n  pngFile: {\n    name: 'pngFile',\n    ext: 'png',\n    description: 'PNG Image (.png)',\n    commonExportParams: defaultExportCommon,\n    exportOptions: {\n      borders: false,\n      alphaPixel: false,\n      scale: 1\n    }\n  },\n  seqFile: {\n    name: 'seqFile',\n    ext: 'seq',\n    description:'SEQ PETSCII File (.seq)',\n    commonExportParams: defaultExportCommon,\n    exportOptions: {\n      insCR: false,\n      insClear: true,\n      stripBlanks: false,\n        insCharset: false,\n    }\n  },\n  cbaseFile: {\n    name: 'cbaseFile',\n    ext: 'prg',\n    description:'CBASE PRG File (.prg)',\n    commonExportParams: defaultExportCommon,\n\n  },\n  cFile: {\n    name: 'cFile',\n    ext: 'c',\n    description:'C Language File (.c)',\n    commonExportParams: defaultExportCommon,\n  },\n  d64File: {\n    name: 'd64File',\n    ext: 'd64',\n    description:'D64 Floppy Disk (.d64)',\n    commonExportParams: defaultExportCommon,\n    exportOptions: {\n      header: \"DISKNAME\",\n      id: \"2A\"\n    }\n  },\n  prgFile: {\n    name: 'prgFile',\n    ext: 'prg',\n    description:'Commodore PRG Binary (.prg)',\n    commonExportParams: defaultExportCommon,\n  },\n  asmFile: {\n    name: 'asmFile',\n    description: 'ASM Assembly source files (.asm)',\n    ext: 'asm',\n    commonExportParams: defaultExportCommon,\n    exportOptions: {\n      currentScreenOnly: true,\n      standalone: false,\n      hex: false,\n      assembler: 'kickass'\n    }\n  },\n  basFile: {\n    name:'basFile',\n    description:'Commodore Basic Text (.bas)',\n    ext: 'bas',\n    commonExportParams: defaultExportCommon,\n    exportOptions: {\n      currentScreenOnly: true,\n      standalone: true\n    }\n  },\n  gifFile: {\n    name: 'gifFile',\n    description: 'GIF Image (.gif)',\n    ext: 'gif',\n    commonExportParams: defaultExportCommon,\n    exportOptions: {\n      borders: false,\n      animMode: 'single',\n      loopMode: 'loop',\n      delayMS: '250'\n    }\n  },\n  jsonFile: {\n    name:'jsonFile',\n    description:'Petmate JSON File (.json)',\n    ext: 'json',\n    commonExportParams: defaultExportCommon,\n    exportOptions: {\n      currentScreenOnly: true\n    }\n  },\n  petFile: {\n    name:'petFile',\n    description:'PET PETSCII Image File (.pet)',\n    ext: 'pet',\n    commonExportParams: defaultExportCommon,\n  },\n\n  prgPlayer: {\n    name: 'prgPlayer',\n    description: 'Petmate Player v1 (.prg)',\n    ext: 'prg',\n    commonExportParams: defaultExportCommon,\n    exportOptions: {\n      currentScreenOnly: true,\n      music: true,\n      songFile: '',\n      songNumber: 1,\n      playerDebug: true,\n      playerType: 'Single Frame',\n      playerAnimationDirection: 'Forward',\n      playerAnimationLoop: true,\n      playerSpeed: 1,\n      playerScrollType: 'Linear',\n      computer: 'c64' ,\n    }\n\n  },\n\n\n}\n\nexport function rgbToCssRgb(o: Rgb) {\n  return `rgb(${o.r}, ${o.g}, ${o.b}`\n}\n\nexport function colorIndexToCssRgb(palette: Rgb[], idx: number) {\n  return rgbToCssRgb(palette[idx])\n}\n\nexport function luminance (color: Rgb): number {\n  const r = color.r / 255\n  const g = color.g / 255\n  const b = color.b / 255\n  return (r + r + b + g + g + g) / 6\n}\n\nexport const charOrderUpper = [ 32, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 46, 44, 59, 33, 63, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 34, 35, 36, 37, 38, 39, 112, 110, 108, 123, 85, 73, 79, 80, 113, 114, 40, 41, 60, 62, 78, 77, 109, 125, 124, 126, 74, 75, 76, 122, 107, 115, 27, 29, 31, 30, 95, 105, 100, 111, 121, 98, 120, 119, 99, 116, 101, 117, 97, 118, 103, 106, 91, 43, 82, 70, 64, 45, 67, 68, 69, 84, 71, 66, 93, 72, 89, 47, 86, 42, 61, 58, 28, 0, 127, 104, 92, 102, 81, 87, 65, 83, 88, 90, 94, 96, 160, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 174, 172, 187, 161, 191, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 162, 163, 164, 165, 166, 167, 240, 238, 236, 251, 213, 201, 207, 208, 241, 242, 168, 169, 188, 190, 206, 205, 237, 253, 252, 254, 202, 203, 204, 250, 235, 243, 155, 157, 159, 158, 223, 233, 228, 239, 249, 226, 248, 247, 227, 244, 229, 245, 225, 246, 231, 234, 219, 171, 210, 198, 192, 173, 195, 196, 197, 212, 199, 194, 221, 200, 217, 175, 214, 170, 189, 186, 156, 128, 255, 232, 220, 230, 209, 215, 193, 211, 216, 218, 222, 224, 256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271 ]\nexport const charOrderLower = [ 32, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 46, 44, 59, 33, 63, 96, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 34, 35, 36, 37, 38, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 45, 42, 61, 39, 0, 112, 110, 108, 123, 113, 114, 40, 41, 95, 105, 92, 127, 60, 62, 28, 47, 109, 125, 124, 126, 107, 115, 27, 29, 94, 102, 104, 58, 30, 31, 91, 122, 100, 111, 121, 98, 99, 119, 120, 101, 116, 117, 97, 103, 106, 118, 64, 93, 160, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 174, 172, 187, 161, 191, 224, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 162, 163, 164, 165, 166, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 171, 173, 170, 189, 167, 128, 240, 238, 236, 251, 241, 242, 168, 169, 223, 233, 220, 255, 188, 190, 156, 175, 237, 253, 252, 254, 235, 243, 155, 157, 222, 230, 232, 186, 158, 159, 219, 250, 228, 239, 249, 226, 227, 247, 248, 229, 244, 245, 225, 231, 234, 246, 192, 221, 256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271]\nexport const dirartOrder = [ 32, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 46, 44, 59, 33, 63, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 34, 35, 36, 37, 38, 39, 112, 110, 108, 123, 85, 73, 79, 80, 113, 114, 40, 41, 60, 62, 78, 77, 109, 125, 124, 126, 74, 75, 76, 122, 107, 115, 27, 29, 31, 30, 95, 105, 100, 111, 121, 98, 120, 119, 99, 116, 101, 117, 97, 118, 103, 106, 91, 43, 82, 70, 64, 45, 67, 68, 69, 84, 71, 66, 93, 72, 89, 47, 86, 42, 61, 58, 28, 0, 127, 104, 92, 102, 81, 87, 65, 83, 88, 90, 94, 96, 160, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 174, 172, 187, 161, 191, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 162, 163, 164, 165, 166, 167, 240, 238, 236, 251, 213, 201, 207, 208, 241, 242, 168, 169, 188, 190, 206, 205, 237, 253, 252, 254, 202, 203, 204, 250, 235, 243, 155, 157, 159, 158, 223, 233, 228, 239, 249, 226, 248, 247, 227, 244, 229, 245, 225, 246, 231, 234, 219, 171, 210, 198, 192, 173, 195, 196, 197, 212, 199, 194, 221, 200, 217, 175, 214, 170, 189, 186, 156, 128, 255, 232, 220, 230, 209, 215, 193, 211, 216, 218, 222, 224,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271 ]\n\n\nexport const charScreencodeFromRowCol = (font: Font, {row, col}: Coord2) => {\n  if (font === null) {\n    return 0xa0\n  }\n  if (row < 0 || row >= 17 ||\n      col < 0 || col >= 16) {\n    return null\n  }\n  const idx = row*16 + col\n  return font.charOrder[idx]\n}\n\nexport const rowColFromScreencode = (font: Font, code: number) => {\n  const charOrder = font.charOrder\n  for (let i = 0; i < charOrder.length; i++) {\n    if (charOrder[i] === code) {\n      return {\n        row: Math.floor(i >> 4),\n        col: Math.floor(i & 15)\n      }\n    }\n  }\n  throw new Error('rowColFromScreencode - the impossible happened');\n}\n\n//const FILE_VERSION = 1\nconst framebufFields = (framebuf: Framebuf) => {\n  return {\n    width: framebuf.width,\n    height: framebuf.height,\n    backgroundColor: framebuf.backgroundColor,\n    borderColor: framebuf.borderColor,\n    borderOn:framebuf.borderOn,\n    charset: framebuf.charset,\n    name: framebuf.name,\n    framebuf: framebuf.framebuf,\n    zoom: framebuf.zoom\n  }\n}\n\nconst saveFramebufs = (fmt: FileFormat, filename: string, framebufs: FramebufWithFont[], fonts: customFonts.CustomFonts, palette: Rgb[]) => {\n\n  const { selectedFramebufIndex } = fmt.commonExportParams;\n  const selectedFramebuf = framebufs[selectedFramebufIndex];\n  console.log(selectedFramebufIndex);\n  if (fmt.ext === 'png') {\n    return savePNG(filename, selectedFramebuf, palette, fmt);\n  } else if (fmt.ext === 'seq') {\n    return saveSEQ(filename, selectedFramebuf, fmt);\n  } else if (fmt.ext  === 'gif') {\n    return saveGIF(filename, framebufs, palette, fmt);\n  } else if (fmt.ext === 'c') {\n    return saveMarqC(filename, framebufs, fmt);\n  } else if (fmt.ext === 'asm') {\n    return saveAsm(filename, framebufs, fmt);\n  } else if (fmt.ext === 'prg' && fmt.name ==='prgFile') {\n    return saveExecutablePRG(filename, selectedFramebuf, fmt);\n  } else if (fmt.ext === 'bas') {\n    return saveBASIC(filename, framebufs, fmt);\n  } else if (fmt.ext === 'json') {\n    return saveJSON(filename, framebufs, fonts, fmt);\n  } else if (fmt.ext === 'pet') {\n    return savePET(filename, framebufs, fmt);\n  } else if (fmt.ext === 'd64') {\n    return saveD64(filename, selectedFramebuf,fonts, fmt);\n  } else if (fmt.ext === 'prg' && fmt.name ==='cbaseFile') {\n    return saveCbase(filename, framebufs, fmt as FileFormatCbase);\n  }else if (fmt.ext === 'prg' && fmt.name ==='prgPlayer') {\n    return savePlayer(filename, framebufs, fmt);\n  }\n  throw new Error(\"shouldn't happen\");\n}\n\ntype GetFramebufByIdFunc = (fbidx: number) => Framebuf;\n\n// Serialize CustomFonts to a known structure for JSON serialization.\n// Could pass in just the original object, but this extra indirection will\n// protect from accidentally changing the file format in case the internal\n// custom fonts structure changes.\nfunction customFontsToJson(cf: customFonts.CustomFonts): WsCustomFontsV2 {\n  const res: {[id: string]: any} = {};\n  Object.entries(cf).forEach(([id, { name, font }]) => {\n    let f: { bits: number[], charOrder: number[] } = font;\n    let n: string = name;\n    res[id] = {\n      name: n,\n      font: f\n    };\n  });\n  return res;\n}\n\nconst WORKSPACE_VERSION = 2;\n\nexport function saveWorkspace (\n  filename: string,\n  screens: number[],\n  getFramebufById: GetFramebufByIdFunc,\n  customFonts: customFonts.CustomFonts,\n  updateLastSavedSnapshot: () => void\n) {\n  const content = JSON.stringify({\n    version: WORKSPACE_VERSION,\n    // Renumber screen indices to 0,1,2,..,N and drop unused framebufs\n    screens: screens.map((_t,idx )=> idx),\n    framebufs: screens.map(fbid => {\n      return {\n        ...framebufFields(getFramebufById(fbid))\n      }\n    }),\n    customFonts: customFontsToJson(customFonts)\n  })\n  try {\n    fs.writeFileSync(filename, content, 'utf-8');\n    electron.remote.app.addRecentDocument(filename);\n\n    var app = electron.remote.app;\n\n    app.addRecentDocument(filename);\n\n    console.log(\"Open Recent: \", app.applicationMenu.items[0].submenu.items[5].submenu.items, app)\n        console.log(\" electron.remote.app.addRecentDocument(filename) -> \",filename);\n    updateLastSavedSnapshot();\n\n\n\n  }\n  catch(e) {\n    alert(`Failed to save file '${filename}'!`)\n  }\n}\n\nexport const loadFramebuf = (filename: string, importFile: (fbs: Framebuf[]) => void) => {\n  const ext = path.extname(filename)\n  if (ext === '.c') {\n    return loadMarqCFramebuf(filename, importFile)\n  } else if (ext === '.d64') {\n    const fb = loadD64Framebuf(filename);\n    if (fb !== undefined) {\n      return importFile([fb]);\n    }\n  } else if (ext === '.seq') {\n    const fb = loadSeq(filename);\n    if (fb !== undefined) {\n        return importFile([fb]);\n    }\n  } else if (ext === '.prg') {\n\n      console.log(\"loading cbase:\",filename)\n\n\n\n\n    const fb = loadCbase(filename);\n    if (fb !== undefined) {\n        return importFile(fb);\n    }\n  } else {\n    console.error('this should not happen');\n  }\n}\n\nexport const sortRegion = (region: { min: Coord2, max: Coord2}) => {\n  const { min, max } = region;\n  const minx = Math.min(min.col, max.col)\n  const miny = Math.min(min.row, max.row)\n  const maxx = Math.max(min.col, max.col)\n  const maxy = Math.max(min.row, max.row)\n  return {\n    min: {row: miny, col: minx},\n    max: {row: maxy, col: maxx},\n  }\n}\n\n/**\n * Returns an array with arrays of the given size.\n *\n * @param myArray {Array} array to split\n * @param chunk_size {Integer} Size of every group\n */\nexport function chunkArray<T>(myArray: T[], chunk_size: number){\n    var index = 0;\n    var arrayLength = myArray.length;\n    var tempArray = [];\n\n    for (index = 0; index < arrayLength; index += chunk_size) {\n        const myChunk = myArray.slice(index, index+chunk_size);\n        // Do something if you want with the group\n        tempArray.push(myChunk);\n    }\n\n    return tempArray;\n}\n\n\nexport const loadAppFile = (filename: string) => {\n  const appPath = electron.remote.app.getAppPath()\n  return fs.readFileSync(path.resolve(appPath, filename));\n}\nexport const loadFontFilePlus = (fontFileName: string, addonFileName: string) => {\n  const appPath = electron.remote.app.getAppPath()\n  return  Array.from(new Uint8Array(Buffer.concat([Buffer.from(fs.readFileSync(path.resolve(appPath, fontFileName))),Buffer.from(fs.readFileSync(path.resolve(appPath, addonFileName)))])));\n}\n\nexport const executablePrgTemplate = loadAppFile('assets/template.prg')\nexport const dirartData = loadFontFilePlus('assets/dirart.bin','assets/bar-dirart.bin')\n\nexport const c64DataUpper = loadFontFilePlus('assets/c64-charset-upper.bin','assets/bar-minimal.bin')\nexport const c64DataLower = loadFontFilePlus('assets/c64-charset-lower.bin','assets/bar-minimal.bin')\nexport const cbaseDataUpper = loadFontFilePlus('assets/cbase-charset-upper.bin','assets/bar-cbase.bin')\nexport const cbaseDataLower = loadFontFilePlus('assets/cbase-charset-lower.bin','assets/bar-cbase.bin')\nexport const c64SEDataUpper = loadFontFilePlus('assets/c64SE-charset-upper.bin','assets/bar-minimal.bin')\nexport const c64SEDataLower = loadFontFilePlus('assets/c64SE-charset-lower.bin','assets/bar-minimal.bin')\nexport const petDataGFX = loadFontFilePlus('assets/pet-charset-upper.bin','assets/bar-minimal.bin')\nexport const petDataBiz = loadFontFilePlus('assets/pet-charset-lower.bin','assets/bar-minimal.bin')\nexport const c128DataUpper = loadFontFilePlus('assets/c128-charset-upper.bin','assets/bar-minimal.bin')\nexport const c128DataLower = loadFontFilePlus('assets/c128-charset-lower.bin','assets/bar-minimal.bin')\nexport const c16DataUpper = loadFontFilePlus('assets/c16-charset-upper.bin','assets/bar-minimal.bin')\nexport const c16DataLower = loadFontFilePlus('assets/c16-charset-lower.bin','assets/bar-minimal.bin')\nexport const vic20DataUpper = loadFontFilePlus('assets/vic20-charset-upper.bin','assets/bar-minimal.bin')\nexport const vic20DataLower = loadFontFilePlus('assets/vic20-charset-lower.bin','assets/bar-minimal.bin')\n\n\nexport function setWorkspaceFilenameWithTitle(setWorkspaceFilename: (fname: string) => void, filename: string) {\n  setWorkspaceFilename(filename)\n  electron.ipcRenderer.send('set-title', `Petmate 9 (0.9.6) BETA6 - ${filename}`)\n}\n\ntype StoreDispatch = any;\nexport function loadWorkspaceNoDialog(\n  dispatch: StoreDispatch,\n  filename: string\n) {\n  dispatch(ReduxRoot.actions.openWorkspace(filename));\n}\n\nexport function loadFileNoDialog(\n  dispatch: StoreDispatch,\n  filename: string,\n  type: FileFormat,\n) {\n  dispatch(ReduxRoot.actions.openImportFile(type,filename));\n}\n\n\n\nexport function dialogLoadWorkspace(\n  dispatch: StoreDispatch\n) {\n  const { dialog } = electron.remote;\n  const window = electron.remote.getCurrentWindow();\n  const filters = [\n    {name: 'Petmate workspace', extensions: ['petmate']},\n  ]\n  const filename = dialog.showOpenDialogSync(window, {properties: ['openFile'], filters})\n  if (filename === undefined) {\n    return\n  }\n  if (filename.length === 1) {\n    loadWorkspaceNoDialog(dispatch, filename[0]);\n  } else {\n    console.error('wtf?!')\n  }\n}\n\nexport function dialogSaveAsWorkspace(\n  screens: number[],\n  getFramebufByIndex: (fbidx: number) => Framebuf,\n  customFonts: customFonts.CustomFonts,\n  setWorkspaceFilename: (fname: string) => void,\n  updateLastSavedSnapshot: () => void\n) {\n  const {dialog} = electron.remote;\n  const window = electron.remote.getCurrentWindow();\n  const filters = [\n    {name: 'Petmate workspace file', extensions: ['petmate']},\n  ];\n  const filename = dialog.showSaveDialogSync(window, {properties: ['openFile'], filters});\n  if (filename === undefined) {\n    return;\n  }\n  saveWorkspace(filename, screens, getFramebufByIndex, customFonts, updateLastSavedSnapshot);\n  setWorkspaceFilenameWithTitle(setWorkspaceFilename, filename);\n}\n\nexport function dialogExportFile(fmt: FileFormat, framebufs: FramebufWithFont[], customFonts: customFonts.CustomFonts, palette: Rgb[]) {\n  const {dialog} = electron.remote\n  const window = electron.remote.getCurrentWindow();\n  const filters = [\n    {name: fmt.name, extensions: [fmt.ext]}\n  ]\n  const filename = dialog.showSaveDialogSync(window, {properties: ['openFile'], filters})\n  if (filename === undefined) {\n    return\n  }\n  console.log(fmt)\n  saveFramebufs(fmt, filename, framebufs, customFonts, palette)\n}\n\n// Pop up a file select dialog for a certain file type and call the\n// loadFile callback with the file contents.\nexport function dialogReadFile(type: FileFormat, loadFile: (data: Buffer) => void) {\n  const {dialog} = electron.remote\n  const window = electron.remote.getCurrentWindow();\n  const filters = [\n    { name: type.name, extensions: [type.ext] }\n  ]\n  const filename = dialog.showOpenDialogSync(window, {properties: ['openFile'], filters})\n  if (filename === undefined) {\n    return\n  }\n  if (filename.length === 1) {\n\n    const buf = fs.readFileSync(filename[0]);\n    loadFile(buf);\n  } else {\n    console.error('wtf?!')\n  }\n}\n\nexport function dialogPickSidFile() : string {\n  const {dialog} = electron.remote\n  const window = electron.remote.getCurrentWindow();\n  const filters = [\n    { name: 'Music Files', extensions: ['sid','bin','mus'] }\n  ]\n  const filename = dialog.showOpenDialogSync(window, {properties: ['openFile'], filters})\n  if (filename === undefined) {\n    return '';\n  }\n  if (filename.length === 1) {\nreturn filename;\n\n  } else {\n    console.error('wtf?!')\n    return '';\n  }\n}\n\n\nexport function dragReadFile(filename: string, loadFile: (data: Buffer) => void)\n{\n  const buf = fs.readFileSync(filename[0]);\n  loadFile(buf);\n\n}\n\n// TODO could use dialogReadFile to implement this, just need to change the\n// importFile API to accept file contents.\nexport function dialogImportFile(type: FileFormat, importFile: (fbs: Framebuf[]) => void) {\n  const {dialog} = electron.remote\n  const window = electron.remote.getCurrentWindow();\n  const filters = [\n    { name: type.name, extensions: [type.ext] }\n  ]\n  const filename = dialog.showOpenDialogSync(window, {properties: ['openFile'], filters})\n  if (filename === undefined) {\n    return\n  }\n  if (filename.length === 1) {\n    loadFramebuf(filename[0], importFile)\n  } else {\n    console.error('wtf?!')\n  }\n}\n\nexport function xImportFile(filename: string, type: FileFormat, importFile: (fbs: Framebuf[]) => void) {\n\n    loadFramebuf(filename, importFile)\n}\n\nexport function loadSettings(dispatchSettingsLoad: (json: Settings) => void) {\n  let settingsFile = path.join(electron.remote.app.getPath('userData'), 'Settings')\n  if (fs.existsSync(settingsFile)) {\n    const c = fs.readFileSync(settingsFile, 'utf-8')\n    const j = JSON.parse(c)\n    dispatchSettingsLoad(j)\n  }\n}\n\n// Ask for confirmation to proceed if the workspace contains unsaved changes\n//\n// Returns: true if it's ok to continue, false otherwise.\nexport function promptProceedWithUnsavedChanges(state: RootState, msg: { title: string, detail: string }) {\n  if (selectors.anyUnsavedChanges(state)) {\n    const { dialog } = electron.remote;\n    return dialog.showMessageBoxSync({\n      type: 'question',\n      buttons: [msg.title, 'Cancel'],\n      cancelId: 1,\n      message: 'Workspace contains unsaved changes.',\n      detail: msg.detail\n    }) === 0;\n  }\n  return true;\n}\n\n// Ask for confirmation to proceed if the workspace contains unsaved changes\n//\n// Returns: true if it's ok to continue, false otherwise.\nexport function promptProceedWithUnsavedChangesInFramebuf(state: RootState, fbIndex: number, msg: { title: string, detail: string }) {\n  if (selectors.anyUnsavedChangesInFramebuf(state, fbIndex)) {\n    const { dialog } = electron.remote;\n    return dialog.showMessageBoxSync({\n      type: 'question',\n      buttons: [msg.title, 'Cancel'],\n      cancelId: 1,\n      message: 'Screen contains unsaved changes.',\n      detail: msg.detail\n    }) === 0;\n  }\n  return true;\n}\n\nexport { drawLine, colorPalettes }\n","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\redux\\typeUtils.ts",["332"],"\nimport { Action } from 'redux'\n\ninterface ActionWithData<T extends string, D> extends Action<T> {\n  data: D;\n}\n\ntype FunctionType = (...args: any[]) => any;\nexport type ActionCreatorsMap = { [actionCreator: string]: FunctionType };\nexport type ActionsUnion<A extends ActionCreatorsMap> = ReturnType<A[keyof A]>;\n\ntype MapReturnToVoid<T> =\n  T extends (...args: infer U) => any ? (...args: U) => void : T;\n\nexport type DispatchPropsFromActions<T> = {\n   [P in keyof T]: MapReturnToVoid<T[P]>;\n}\n\nexport function createAction<T extends string>(type: T): Action<T>\nexport function createAction<T extends string, D>(type: T, data: D): ActionWithData<T, D>\nexport function createAction<T extends string, D>(type: T, data?: D) {\n  return data === undefined ? { type } : { type, data };\n}\n\nexport function updateField<State, K extends keyof State>(\n  state:  State,\n  field:  K,\n  value:  State[K]\n): State {\n  return {\n    ...state,\n    [field]: value\n  }\n}\n","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\fp.ts",[],"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\redux\\editor.ts",["333"],"import { Action, Dispatch, bindActionCreators } from 'redux'\n\nimport {\n  Brush,\n  BrushType,\n  Coord2,\n  Framebuf,\n  Pixel,\n  DEFAULT_FB_HEIGHT,\n  DEFAULT_FB_WIDTH\n} from './types'\n\nimport * as fp from '../utils/fp'\nimport { makeScreenName } from './utils'\nimport { ActionsUnion, updateField } from './typeUtils'\nimport Toolbar from '../containers/Toolbar'\n\n\nexport const CHARSET_UPPER = 'upper'\nexport const CHARSET_LOWER = 'lower'\nexport const CHARSET_DIRART = 'dirart'\nexport const CHARSET_CBASE_UPPER = 'cbaseUpper'\nexport const CHARSET_CBASE_LOWER = 'cbaseLower'\n\nexport const CHARSET_C16_UPPER = 'c16Upper'\nexport const CHARSET_C16_LOWER = 'c16Lower'\nexport const CHARSET_C128_UPPER = 'c128Upper'\nexport const CHARSET_C128_LOWER = 'c128Lower'\nexport const CHARSET_VIC20_UPPER = 'vic20Upper'\nexport const CHARSET_VIC20_LOWER = 'vic20Lower'\nexport const CHARSET_C64SE_UPPER = 'c64SEUpper'\nexport const CHARSET_C64SE_LOWER = 'c64SELower'\nexport const CHARSET_PET_UPPER = 'petGfx'\nexport const CHARSET_PET_LOWER = 'petBiz'\n\n\nexport const DEFAULT_BACKGROUND_COLOR = 6\nexport const DEFAULT_BORDER_COLOR = 14\nexport const DEFAULT_BORDER_ON = true\nexport const DEFAULT_ZOOM = { zoomLevel: 1, alignment: 'left' }\nexport const DEFAULT_ZOOMREADY = false\n\n\nexport interface FbActionWithData<T extends string, D> extends Action<T> {\n  data: D;\n  undoId: number | null;\n  framebufIndex: number | null;\n}\n\n\n// Fb actions are handled specially as these actions are always tagged\n// with a framebufIndex and an undoId.\nexport function createFbAction<T extends string>(type: T, framebufIndex: number | null, undoId: number | null): FbActionWithData<T, undefined>\nexport function createFbAction<T extends string, D>(type: T, framebufIndex: number | null, undoId: number | null, data: D): FbActionWithData<T, D>\nexport function createFbAction<T extends string, D>(type: T, framebufIndex: number | null, undoId: number | null, data?: D) {\n  return data === undefined ?\n    { type, framebufIndex, undoId } :\n    { type, data, framebufIndex, undoId };\n}\n\n\n\n\ntype SetCharParams = Coord2 & { screencode?: number, color?: number };\ntype SetBrushParams = Coord2 & { brushType: number, brush: Brush, brushColor: number };\ntype ImportFileParams = any // TODO ts\n\nconst SET_PIXEL = 'Framebuffer/SET_PIXEL'\nconst SET_BRUSH = 'Framebuffer/SET_BRUSH'\nconst SET_FIELDS = 'Framebuffer/SET_FIELDS'\nconst IMPORT_FILE = 'Framebuffer/IMPORT_FILE'\nconst CLEAR_CANVAS = 'Framebuffer/CLEAR_CANVAS'\nconst RESIZE_CANVAS = 'Framebuffer/RESIZE_CANVAS'\nconst COPY_FRAMEBUF = 'Framebuffer/COPY_FRAMEBUF'\nconst SHIFT_HORIZONTAL = 'Framebuffer/SHIFT_HORIZONTAL'\nconst SHIFT_VERTICAL = 'Framebuffer/SHIFT_VERTICAL'\n\nconst SET_BACKGROUND_COLOR = 'Framebuffer/SET_BACKGROUND_COLOR'\nconst SET_BORDER_COLOR = 'Framebuffer/SET_BORDER_COLOR'\nconst SET_BORDER_ON = 'Framebuffer/SET_BORDER_ON'\nconst SET_CHARSET = 'Framebuffer/SET_CHARSET'\nconst SET_NAME = 'Framebuffer/SET_NAME'\nconst SET_DIMS = 'Framebuffer/SET_DIMS'\nconst SET_ZOOM = 'Framebuffer/SET_ZOOM'\nconst SET_ZOOMREADY = 'Framebuffer/SET_ZOOMREADY'\nconst SWAP_COLORS = 'Framebuffer/SWAP_COLORS'\nconst SWAP_CHARS = 'Framebuffer/SWAP_CHARS'\nconst TOGGLE_BORDER = 'Framebuffer/TOGGLE_BORDER'\n\n\nconst actionCreators = {\n  setPixel: (data: SetCharParams, undoId: number | null, framebufIndex: number | null) => createFbAction(SET_PIXEL, framebufIndex, undoId, data),\n  setBrush: (data: SetBrushParams, undoId: number | null, framebufIndex: number) => createFbAction(SET_BRUSH, framebufIndex, undoId, data),\n  importFile: (data: ImportFileParams, framebufIndex: number) => createFbAction(IMPORT_FILE, framebufIndex, null, data),\n  clearCanvas: (framebufIndex: number) => createFbAction(CLEAR_CANVAS, framebufIndex, null),\n  copyFramebuf: (data: Framebuf, framebufIndex: number) => createFbAction(COPY_FRAMEBUF, framebufIndex, null, data),\n  setFields: (data: any, framebufIndex: number) => createFbAction(SET_FIELDS, framebufIndex, null, data),\n  shiftHorizontal: (data: -1 | 1, framebufIndex: number) => createFbAction(SHIFT_HORIZONTAL, framebufIndex, null, data),\n  shiftVertical: (data: -1 | 1, framebufIndex: number) => createFbAction(SHIFT_VERTICAL, framebufIndex, null, data),\n\n  setBackgroundColor: (data: number, framebufIndex: number) => createFbAction(SET_BACKGROUND_COLOR, framebufIndex, null, data),\n  setBorderColor: (data: number, framebufIndex: number) => createFbAction(SET_BORDER_COLOR, framebufIndex, null, data),\n  setBorderOn: (data: boolean, framebufIndex: number) => createFbAction(SET_BORDER_ON, framebufIndex, null, data),\n\n\n  setCharset: (data: string, framebufIndex: number) => createFbAction(SET_CHARSET, framebufIndex, null, data),\n  setName: (data: string | undefined, framebufIndex: number) => createFbAction(SET_NAME, framebufIndex, null, data),\n\n  setDims: (data: { width: number, height: number }, framebufIndex: number) => createFbAction(SET_DIMS, framebufIndex, null, data),\n  setZoom: (data: { zoomLevel: number, alignment: string }, framebufIndex: number) => createFbAction(SET_ZOOM, framebufIndex, null, data),\n  setZoomReady: (data: boolean, framebufIndex: number) => createFbAction(SET_ZOOMREADY, framebufIndex, null, data),\n  resizeCanvas: (data: { rWidth: number, rHeight: number, rDir: Coord2, isCrop: boolean }, framebufIndex: number) => createFbAction(RESIZE_CANVAS, framebufIndex, null, data),\n  swapColors: (colors: { srcColor: number, destColor: number }, framebufIndex: number) => createFbAction(SWAP_COLORS, framebufIndex, null, colors),\n  swapChars: (chars: { srcChar: number, destChar: number }, framebufIndex: number) => createFbAction(SWAP_CHARS, framebufIndex, null, chars),\n\n};\n\nexport const actions = actionCreators;\n\n// Map action dispatch functions to something that can be used\n// in React components.  This drops the last framebufIndex from the\n// type as it's implicitly plugged in by the connect() merge props\n// option.\ntype MapReturnToVoidFB<T> =\n  T extends (framebufIndex: number) => any ? () => void :\n  T extends (a0: infer U, framebufIndex: number) => any ? (a0: U) => void :\n  T extends (a0: infer U, a1: infer V, framebufIndex: number) => any ? (a0: U, a1: V) => void :\n  T extends (a0: infer U, a1: infer V, a2: infer S, framebufIndex: number) => any ? (a0: U, a1: V, a2: S) => void : T;\n\ntype DispatchPropsFromActionsFB<T> = {\n  [P in keyof T]: MapReturnToVoidFB<T[P]>;\n}\n\nexport type PropsFromDispatch = DispatchPropsFromActionsFB<typeof actions>;\n\nexport type Actions = ActionsUnion<typeof actionCreators>;\n\nexport class Framebuffer {\n\n  static actions = actions;\n\n  static reducer = fbReducer\n\n  static bindDispatch(dispatch: Dispatch) {\n    return bindActionCreators(Framebuffer.actions, dispatch)\n  }\n}\n\nfunction setChar(fbState: Framebuf, { row, col, screencode, color }: SetCharParams): Pixel[][] {\n  const { framebuf, width, height } = fbState\n  if (row < 0 || row >= height ||\n    col < 0 || col >= width) {\n    return framebuf\n  }\n  return framebuf.map((pixelRow, idx) => {\n    if (row === idx) {\n      return pixelRow.map((pix, x) => {\n        if (col === x) {\n          if (screencode === undefined) {\n            return { ...pix, color: color! }\n          }\n          if (color === undefined) {\n            return { ...pix, code: screencode }\n          }\n          return { code: screencode, color }\n        }\n        return pix\n      })\n    }\n    return pixelRow\n  })\n}\n\nfunction setBrush(framebuf: Pixel[][], { row, col, brush, brushType, brushColor }: SetBrushParams): Pixel[][] {\n  const { min, max } = brush.brushRegion\n\n\n\n  return framebuf.map((pixelRow, y) => {\n    const yo = y - row\n    if (yo >= min.row && yo <= max.row) {\n      return pixelRow.map((pix, x) => {\n        const xo = x - col\n        if (xo >= min.col && xo <= max.col) {\n          const bpix = brush.framebuf[yo - min.row][xo - min.col]\n          const fpix = framebuf[y][x]\n\n          let code = bpix.code;\n          let color = bpix.color;\n\n          if (brushType == BrushType.Raw) {\n            //return all data and paste transparency info as well\n            return {\n              code: code,\n              color: color\n            }\n          }\n          else {\n            //default paste char and colors\n            if (brushType == BrushType.CharsOnly) {\n              //paste char info only\n              color = fpix.color;\n            }\n            else if (brushType == BrushType.ColorsOnly) {\n              //paste color data only\n              code = fpix.code;\n            }\n            else if (brushType == BrushType.ColorStamp) {\n              //paste color mono color stamp (currently selected color)\n              color = brushColor;\n            }\n            if (bpix.code !== 256) {\n              return {\n                code: code,\n                color: color\n              }\n            }\n\n\n          }\n\n        }\n        return pix\n      })\n    }\n    return pixelRow\n  })\n}\n\nfunction rotateArr<T>(arr: T[], dir: -1 | 1) {\n  if (dir === -1) {\n    return [...arr.slice(1, arr.length), arr[0]];\n  }\n  return [arr[arr.length - 1], ...arr.slice(0, arr.length - 1)];\n\n}\n\nfunction shiftHorizontal(framebuf: Pixel[][], dir: -1 | 1) {\n  return framebuf.map((row) => rotateArr(row, dir))\n}\n\nfunction shiftVertical(framebuf: Pixel[][], dir: -1 | 1) {\n  return rotateArr(framebuf, dir);\n}\n\nfunction emptyFramebuf(width: number, height: number): Pixel[][] {\n  return Array(height).fill(Array(width).fill({ code: 32, color: 14 }))\n}\n\nfunction mapPixels(fb: Framebuf, mapFn: (fb: Framebuf) => Pixel[][]) {\n  const mappedFn = mapFn(fb);\n  return {\n    ...fb,\n    framebuf: mappedFn,\n    width: mappedFn[0].length,\n    height: mappedFn.length,\n  }\n}\n\nfunction swapFrameBufColors(framebuf: Pixel[][], colors: { srcColor: number, destColor: number }) {\n  // return framebuf.map((row) => rotateArr(row, dir))\n  const { srcColor, destColor } = colors;\n  console.log('swapFrameBufColors', colors);\n  return framebuf.map((row) => row.map((cell) => cell.color == srcColor ? { code: cell.code, color: destColor } : cell))\n}\n\nfunction swapFrameBufChars(framebuf: Pixel[][], chars: { srcChar: number, destChar: number }) {\n  // return framebuf.map((row) => rotateArr(row, dir))\n  const { srcChar, destChar } = chars;\n  console.log('swapFrameBufChars', chars);\n  return framebuf.map((row) => row.map((cell) => cell.code == srcChar ? { code: destChar, color: cell.color } : cell))\n}\n\n\nfunction resizeFrameBuf(framebuf: Pixel[][], data: { rWidth: number, rHeight: number, rDir: Coord2, isCrop: boolean }) {\n  // return framebuf.map((row) => rotateArr(row, dir))\n  const { rWidth, rHeight, rDir, isCrop } = data;\n\n  const sWidth = framebuf[0].length;\n  const sHeight = framebuf.length;\n  const exChar = { code: 32, color: 14 };\n\n  // Array(height).fill(Array(width).fill({code: 32, color:14}))\n  if (rWidth > sWidth) {\n    //expand width\n    if (rHeight > sHeight) {\n      //expand width/height\n      return [...framebuf, ...Array(rHeight - sHeight).fill(Array(sWidth).fill(exChar))].map((row) => [...row, ...Array(rWidth - sWidth).fill(exChar)]);\n\n    }\n    else {\n      //expand width and crop height\n      return framebuf.slice(0, rHeight).map((row) => [...row, ...Array(rWidth - sWidth).fill(exChar)]);\n    }\n  }\n  else {\n    if (isCrop) {\n      //crop width\n      if (rHeight > sHeight) {\n        // crop width and expand height\n        return [...framebuf, ...Array(rHeight - sHeight).fill(Array(sWidth).fill(exChar))].map((row) => row.slice(0, rWidth));\n      }\n      else {\n        //crop width and crop height\n        return framebuf.slice(0, rHeight).map((row) => row.slice(0, rWidth));\n      }\n    }\n    else {\n      //Width Crop is now a wrap around\n\n      console.log('framebuf.flat():', framebuf.flat())\n      console.log('framebuf.slice(0, rHeight).map((row) => row.slice(0, rWidth))', framebuf.slice(0, rHeight).map((row) => row.slice(0, rWidth)))\n\n      return framebuf.slice(0, rHeight).map((row) => row.slice(0, rWidth));\n\n\n\n\n\n\n    }\n\n  }\n}\n\n\nexport function fbReducer(state: Framebuf = {\n  framebuf: emptyFramebuf(DEFAULT_FB_WIDTH, DEFAULT_FB_HEIGHT),\n  width: DEFAULT_FB_WIDTH,\n  height: DEFAULT_FB_HEIGHT,\n  zoom: DEFAULT_ZOOM,\n  backgroundColor: DEFAULT_BACKGROUND_COLOR,\n  borderColor: DEFAULT_BORDER_COLOR,\n  borderOn: DEFAULT_BORDER_ON,\n  charset: CHARSET_UPPER,\n  name: undefined,\n  zoomReady: DEFAULT_ZOOMREADY,\n\n\n}, action: Actions): Framebuf {\n  switch (action.type) {\n    case SET_PIXEL:\n      return mapPixels(state, fb => setChar(fb, action.data));\n    case SET_BRUSH:\n      return mapPixels(state, fb => setBrush(fb.framebuf, action.data));\n    case CLEAR_CANVAS:\n      return mapPixels(state, _fb => emptyFramebuf(state.width, state.height));\n    case RESIZE_CANVAS:\n      return mapPixels(state, fb => {\n        return resizeFrameBuf(fb.framebuf, action.data)\n      });\n    case SWAP_COLORS:\n      return mapPixels(state, fb => {\n        return swapFrameBufColors(fb.framebuf, action.data)\n      });\n      case SWAP_CHARS:\n        return mapPixels(state, fb => {\n          return swapFrameBufChars(fb.framebuf, action.data)\n        });\n\n\n    case SHIFT_HORIZONTAL:\n      return mapPixels(state, fb => shiftHorizontal(fb.framebuf, action.data));\n    case SHIFT_VERTICAL:\n      return mapPixels(state, fb => shiftVertical(fb.framebuf, action.data));\n    case SET_FIELDS:\n      return {\n        ...state,\n        ...action.data\n      }\n    case COPY_FRAMEBUF:\n      return {\n        ...state,\n        ...action.data\n      }\n    case IMPORT_FILE:\n      const c = action.data\n      const name = fp.maybeDefault(c.name, makeScreenName(action.framebufIndex))\n      return {\n        framebuf: c.framebuf,\n        width: c.width,\n        height: c.height,\n        backgroundColor: c.backgroundColor,\n        borderColor: c.borderColor,\n        borderOn: c.borderOn,\n        charset: c.charset,\n        zoom: c.zoom,\n        zoomReady: false,\n        name\n      }\n    case SET_BACKGROUND_COLOR:\n      return updateField(state, 'backgroundColor', action.data);\n    case SET_BORDER_COLOR:\n      return updateField(state, 'borderColor', action.data);\n    case SET_BORDER_ON:\n      return updateField(state, 'borderOn', action.data);\n    case SET_CHARSET:\n      return updateField(state, 'charset', action.data);\n    case SET_NAME:\n      return updateField(state, 'name', action.data);\n    case SET_DIMS: {\n      const { width, height } = action.data;\n      return {\n        ...state,\n        width: action.data.width,\n        height: action.data.height,\n        framebuf: emptyFramebuf(width, height)\n      }\n    }\n    case SET_ZOOM:\n\n      const { zoomLevel, alignment } = action.data;\n\n      const updatedzoom = { zoomLevel, alignment }\n      return updateField(state, 'zoom', updatedzoom);\n\n    case SET_ZOOMREADY:\n      return updateField(state, 'zoomReady', action.data);\n\n    default:\n      return state;\n  }\n}\n","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\redux\\screensSelectors.ts",[],"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\redux\\settingsSelectors.ts",[],"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\redux\\selectors.ts",["334"],"// @ts-ignore\nimport memoize  from 'fast-memoize'\nimport {\n  charScreencodeFromRowCol,\n  rowColFromScreencode,\n  c64DataUpper,\n  c64DataLower,\n  dirartData,\n  charOrderUpper,\n  charOrderLower,\n  cbaseDataUpper,\n  cbaseDataLower,\nc16DataUpper,\nc16DataLower,\nc64SEDataLower,\nc64SEDataUpper,\nc128DataLower,\nc128DataUpper,\npetDataBiz,\npetDataGFX,\nvic20DataLower,\nvic20DataUpper,\n} from '../utils'\n\nimport { RootState, Font, Framebuf, Coord2, Transform, Brush, FramebufUIState } from './types'\nimport { mirrorBrush, findTransformedChar } from './brush'\nimport { CHARSET_UPPER, CHARSET_LOWER, CHARSET_DIRART, CHARSET_CBASE_LOWER, CHARSET_CBASE_UPPER, CHARSET_C128_LOWER,CHARSET_C128_UPPER,CHARSET_C16_LOWER,CHARSET_C16_UPPER,CHARSET_C64SE_LOWER,CHARSET_C64SE_UPPER,CHARSET_PET_LOWER,CHARSET_PET_UPPER,CHARSET_VIC20_LOWER,CHARSET_VIC20_UPPER } from './editor'\n\nimport { getCurrentScreenFramebufIndex } from './screensSelectors'\nimport { CustomFonts } from './customFonts'\n\nexport const getFramebufByIndex = (state: RootState, idx: number | null) => {\n  if (idx !== null && idx < state.framebufList.length) {\n    return state.framebufList[idx].present\n  }\n  return null;\n}\n\n\n\n\nexport const getCurrentFramebuf = (state: RootState) => {\n  return getFramebufByIndex(state, getCurrentScreenFramebufIndex(state))\n}\n\nexport const getROMFontBits = (charset: string): Font => {\n  if (charset !== CHARSET_UPPER && charset !== CHARSET_LOWER\n    && charset !== CHARSET_DIRART\n    && charset !== CHARSET_CBASE_LOWER && charset !== CHARSET_CBASE_UPPER\n    && charset !== CHARSET_C16_LOWER && charset !== CHARSET_C16_UPPER\n    && charset !== CHARSET_C128_LOWER && charset !== CHARSET_C128_UPPER\n    && charset !== CHARSET_C64SE_LOWER && charset !== CHARSET_C64SE_UPPER\n    && charset !== CHARSET_VIC20_LOWER && charset !== CHARSET_VIC20_UPPER\n    && charset !== CHARSET_PET_LOWER && charset !== CHARSET_PET_UPPER\n\n    ) {\n    throw new Error(`unknown charset ${charset}`);\n  }\n\n  if (charset === CHARSET_LOWER) {\n    return {\n      bits: c64DataLower,\n      charOrder: charOrderLower,\n    };\n  }\n  if (charset === CHARSET_UPPER) {\n    return {\n      bits: c64DataUpper,\n      charOrder: charOrderUpper,\n    };\n  }\n  if (charset === CHARSET_CBASE_LOWER) {\n    return {\n      bits: cbaseDataLower,\n      charOrder: charOrderLower,\n    };\n  }\n  if (charset === CHARSET_CBASE_UPPER) {\n    return {\n      bits: cbaseDataUpper,\n      charOrder: charOrderUpper,\n    };\n  }\n\n  if (charset === CHARSET_DIRART)\n  {\n    return {\n      bits: dirartData,\n      charOrder: charOrderUpper,\n    };\n  }\n  if (charset === CHARSET_C16_LOWER) {\n    return {\n      bits: c16DataLower,\n      charOrder: charOrderLower,\n    };\n  }\n  if (charset === CHARSET_C16_UPPER) {\n    return {\n      bits: c16DataUpper,\n      charOrder: charOrderUpper,\n    };\n  }\n\n  if (charset === CHARSET_C128_LOWER) {\n    return {\n      bits: c128DataLower,\n      charOrder: charOrderLower,\n    };\n  }\n  if (charset === CHARSET_C128_UPPER) {\n    return {\n      bits: c128DataUpper,\n      charOrder: charOrderUpper,\n    };\n  }\n  if (charset === CHARSET_C64SE_UPPER) {\n    return {\n      bits: c64SEDataUpper,\n      charOrder: charOrderUpper,\n    };\n  }\n  if (charset === CHARSET_C64SE_LOWER) {\n    return {\n      bits: c64SEDataLower,\n      charOrder: charOrderLower,\n    };\n  }\n    if (charset === CHARSET_VIC20_LOWER) {\n      return {\n        bits: vic20DataLower,\n        charOrder: charOrderLower,\n      };\n    }\n    if (charset === CHARSET_VIC20_UPPER) {\n      return {\n        bits: vic20DataUpper,\n        charOrder: charOrderUpper,\n      };\n    }\n    if (charset === CHARSET_PET_LOWER) {\n      return {\n        bits: petDataBiz,\n        charOrder: charOrderLower,\n      };\n    }\n    if (charset === CHARSET_PET_UPPER) {\n      return {\n        bits: petDataGFX,\n        charOrder: charOrderUpper,\n      };\n    }\n\n    else{\n      return {\n        bits: c64DataUpper,\n        charOrder: charOrderUpper,\n      };\n\n    }\n\n\n\n\n\n\n\n\n}\n\n// getFontBits returns a new object every time it's called.  This causes\n// serious cache invalidates in rendering the canvas (since it thinks the font\n// changed).  So memoize the returned object from getFontBits in case it's\n// called with the same value.\nconst getROMFontBitsMemoized = memoize(getROMFontBits)\n\nexport const getFramebufFont = (state: RootState, framebuf: Framebuf): { charset: string, font: Font } => {\n  if (framebuf.charset === CHARSET_UPPER\n  || framebuf.charset === CHARSET_LOWER\n  || framebuf.charset === CHARSET_DIRART\n  || framebuf.charset === CHARSET_CBASE_LOWER\n  || framebuf.charset === CHARSET_CBASE_UPPER\n  || framebuf.charset === CHARSET_C16_UPPER\n  || framebuf.charset === CHARSET_C16_LOWER\n  || framebuf.charset === CHARSET_C128_UPPER\n  || framebuf.charset === CHARSET_C128_LOWER\n  || framebuf.charset === CHARSET_C64SE_UPPER\n  || framebuf.charset === CHARSET_C64SE_LOWER\n  || framebuf.charset === CHARSET_VIC20_UPPER\n  || framebuf.charset === CHARSET_VIC20_LOWER\n  || framebuf.charset === CHARSET_PET_UPPER\n  || framebuf.charset === CHARSET_PET_LOWER\n\n)\n  {\n    return {\n      charset: framebuf.charset,\n      font: getROMFontBitsMemoized(framebuf.charset)\n    };\n  }\n  return {\n    charset: framebuf.charset,\n    font: state.customFonts[framebuf.charset].font\n  };\n}\n\nexport const getCurrentFramebufFont = (state: RootState) => {\n  const fb = getCurrentFramebuf(state)\n  if (!fb) {\n    return {\n      charset: CHARSET_UPPER,\n      font: getROMFontBits(CHARSET_UPPER)\n    };\n  }\n  return getFramebufFont(state, fb);\n}\n\nexport function getCustomFonts (state: RootState): CustomFonts {\n  return state.customFonts;\n}\n\nconst rowColFromScreencodeMemoized_ = (f: Font, sc: number) => rowColFromScreencode(f, sc)\nconst rowColFromScreencodeMemoized = memoize(rowColFromScreencodeMemoized_)\n\nconst computeScreencodeWithTransform = (rowcol: Coord2, font: Font, transform: Transform) => {\n  const sc = charScreencodeFromRowCol(font, rowcol)\n  return findTransformedChar(font, sc!, transform)\n}\nconst computeScreencodeWithTransformMemoized = memoize(computeScreencodeWithTransform)\nexport const getScreencodeWithTransform = (rowcol: Coord2, font: Font, transform: Transform) => {\n  return computeScreencodeWithTransformMemoized(rowcol, font, transform)\n}\n\nexport const getCharRowColWithTransform = (rowcol: Coord2, font: Font, transform: Transform) => {\n  const char = getScreencodeWithTransform(rowcol, font, transform)\n  return rowColFromScreencodeMemoized(font, char)\n}\n\nconst transformBrushMemoized = memoize(mirrorBrush)\nexport const transformBrush = (brush: Brush, transform: Transform, font: Font) => {\n  return transformBrushMemoized(brush, transform, font)\n}\n\nexport const getFramebufUIState = (state: RootState, framebufIndex: number|null): FramebufUIState|undefined => {\n  if (framebufIndex === null) {\n    return undefined;\n  }\n  return state.toolbar.framebufUIState[framebufIndex];\n}\n\n// Are there any unsaved changes in the workspace?\nexport function anyUnsavedChanges (state: RootState): boolean {\n  if (state.lastSavedSnapshot.screenList !== state.screens.list) {\n    return true;\n  }\n  const lastSavedFbs = state.lastSavedSnapshot.framebufs;\n  for (let i = 0; i < lastSavedFbs.length; i++) {\n    if (lastSavedFbs[i] !== state.framebufList[i].present) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// Are there any unsaved changes in a particular framebuf?\nexport function anyUnsavedChangesInFramebuf (state: RootState, fbIndex: number): boolean {\n  const lastSavedFbs = state.lastSavedSnapshot.framebufs;\n  if (fbIndex < lastSavedFbs.length) {\n    return lastSavedFbs[fbIndex] !== state.framebufList[fbIndex].present\n  }\n  // FB didn't exist on last save, so interpret it as changed.\n  // This sort of gives false positives for newly added screens\n  // that haven't been touched yet but didn't exist on last save.\n  return true;\n}\n","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\redux\\brush.ts",[],"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\matrix.ts",["335"],"export type Vec3 = [number, number, number];\n\nfunction copyVec3(v: Vec3): Vec3 {\n  return [...v] as Vec3;\n}\n\nexport interface Matrix3x3 {\n  v: [Vec3, Vec3, Vec3];\n}\n\nexport function c(a: Matrix3x3, col: number): Vec3 {\n  return [a.v[0][col], a.v[1][col], a.v[2][col]];\n}\n\nexport function r(a: Matrix3x3, row: number): Vec3 {\n  return [a.v[row][0], a.v[row][1], a.v[row][2]];\n}\n\nexport function dot(a: Vec3, b: Vec3): number {\n  return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];\n}\n\nexport function multVect3(a: Matrix3x3, v: Vec3) {\n  return [dot(r(a, 0), v), dot(r(a, 1), v), dot(r(a, 2), v)];\n}\n\nexport function copy(m: Matrix3x3): Matrix3x3 {\n  return {\n    v: [copyVec3(m.v[0]), copyVec3(m.v[1]), copyVec3(m.v[2])]\n  }\n}\n\nexport function ident(): Matrix3x3 {\n  return {\n    v: [\n      [1, 0, 0],\n      [0, 1, 0],\n      [0, 0, 1]\n    ]\n  }\n}\n\n\nexport function invert(a: Matrix3x3) {\n  const res = ident();\n  function m(r: number, c: number): number {\n    return a.v[r][c];\n  }\n  function setminv(r: number, c: number, v: number): void {\n    res.v[r][c] = v;\n  }\n\n  const det = m(0, 0) * (m(1, 1) * m(2, 2) - m(2, 1) * m(1, 2)) -\n              m(0, 1) * (m(1, 0) * m(2, 2) - m(1, 2) * m(2, 0)) +\n              m(0, 2) * (m(1, 0) * m(2, 1) - m(1, 1) * m(2, 0));\n\n  const invdet = 1 / det;\n\n  setminv(0, 0, (m(1, 1) * m(2, 2) - m(2, 1) * m(1, 2)) * invdet);\n  setminv(0, 1, (m(0, 2) * m(2, 1) - m(0, 1) * m(2, 2)) * invdet);\n  setminv(0, 2, (m(0, 1) * m(1, 2) - m(0, 2) * m(1, 1)) * invdet);\n  setminv(1, 0, (m(1, 2) * m(2, 0) - m(1, 0) * m(2, 2)) * invdet);\n  setminv(1, 1, (m(0, 0) * m(2, 2) - m(0, 2) * m(2, 0)) * invdet);\n  setminv(1, 2, (m(1, 0) * m(0, 2) - m(0, 0) * m(1, 2)) * invdet);\n  setminv(2, 0, (m(1, 0) * m(2, 1) - m(2, 0) * m(1, 1)) * invdet);\n  setminv(2, 1, (m(2, 0) * m(0, 1) - m(0, 0) * m(2, 1)) * invdet);\n  setminv(2, 2, (m(0, 0) * m(1, 1) - m(1, 0) * m(0, 1)) * invdet);\n  return res;\n}\n\nexport function mult(a: Matrix3x3, b: Matrix3x3): Matrix3x3 {\n  return {\n    v: [\n      [dot(r(a,0), c(b,0)),  dot(r(a,0), c(b,1)), dot(r(a,0), c(b,2))],\n      [dot(r(a,1), c(b,0)),  dot(r(a,1), c(b,1)), dot(r(a,1), c(b,2))],\n      [dot(r(a,2), c(b,0)),  dot(r(a,2), c(b,1)), dot(r(a,2), c(b,2))]\n    ]\n  }\n}\n\nexport function toCss(a: Matrix3x3) {\n  const v = a.v;\n  return `matrix(${v[0][0]}, ${v[1][0]}, ${v[0][1]}, ${v[1][1]}, ${v[0][2]}, ${v[1][2]})`;\n}\n\nexport function scale(s: number): Matrix3x3 {\n  const m = ident();\n  m.v[0][0] = s;\n  m.v[1][1] = s;\n  return m;\n}\n\nexport function translate(x: number, y: number): Matrix3x3 {\n  const m = ident();\n  m.v[0][2] = x;\n  m.v[1][2] = y;\n  return m;\n}\n","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\redux\\workspace.ts",[],"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\redux\\typesExport.ts",[],"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\containers\\App.tsx",["336"],"\nimport React, { Component, Fragment, ReactNode } from 'react';\nimport { connect } from 'react-redux'\nimport { Dispatch } from 'redux'\n\nimport Toolbar from './Toolbar'\nimport FramebufferTabs from './FramebufferTabs'\nimport Settings from './Settings'\nimport ResizeSettings from './ResizeSettings'\nimport ProgressModal from './ProgressModal';\nimport CustomFontsModal from './CustomFontsModal';\nimport ExportModal from './ExportModal'\nimport ImportModal from './ImportModal'\nimport Editor from './Editor';\nimport FileDrop from './FileDrop'\n\n\n\nimport * as reduxToolbar from '../redux/toolbar'\nimport { loadWorkspaceNoDialog,loadFileNoDialog, formats } from '../utils'\n\nimport s from './App.module.css'\n\nimport configureStore from './../store/configureStore';\nconst store = configureStore();\n\n\ninterface Dims {\n  width: number;\n  height: number;\n}\n\ninterface DivSizeProps {\n  className: string;\n  render: (props: Dims) => ReactNode;\n}\n\ninterface DivSizeState {\n  containerSize: Dims | null;\n}\n\nclass DivSize extends Component<DivSizeProps, DivSizeState> {\n\n  private ref = React.createRef<HTMLDivElement>();\n  private ro: ResizeObserver | null = null;\n  state = {\n    containerSize: null\n  };\n\n  constructor (props: DivSizeProps) {\n    super(props)\n\n    this.ro = new ResizeObserver((entries: ResizeObserverEntry[]) => {\n      const e = entries[0]\n      this.setState({\n        containerSize: {\n          width: e.contentRect.width,\n          height: e.contentRect.height\n        }\n      })\n    })\n  }\n\n  componentDidMount () {\n    if (this.ro && this.ref.current) {\n      this.ro.observe(this.ref.current)\n    }\n  }\n\n  componentWillUnmount () {\n    if (this.ro && this.ref.current) {\n      this.ro.unobserve(this.ref.current);\n    }\n  }\n\n\n  render () {\n    return (\n      <div\n        className={this.props.className}\n        ref={this.ref}\n      >\n        {this.props.render(this.state.containerSize!)}\n      </div>\n    )\n  }\n}\n\ninterface AppViewProps {\n  Toolbar: reduxToolbar.PropsFromDispatch;\n  dispatch: Dispatch\n}\n\nclass AppView extends Component<AppViewProps> {\n\n  componentDidMount() {\n    document.addEventListener('keydown', this.handleKeyDown);\n    document.addEventListener('keyup', this.handleKeyUp);\n  }\n\n  componentWillUnmount() {\n    document.removeEventListener('keydown', this.handleKeyDown);\n    document.removeEventListener('keyup', this.handleKeyUp);\n  }\n\n  handleKeyDown = (event: KeyboardEvent) => {\n    this.props.Toolbar.keyDown(event.key)\n  }\n\n  handleKeyUp = (event: KeyboardEvent) => {\n    this.props.Toolbar.keyUp(event.key)\n  }\n\n  handleLoadPetmate = (filename: string) => {\n    const { dispatch } = this.props;\n\n    const extension = filename.split('.')[filename.split('.').length-1].toUpperCase();\n\n    switch(extension)\n    {\n        case \"PETMATE\":\n            loadWorkspaceNoDialog(dispatch, filename);\n          break;\n        case \"SEQ\":\n\n           loadFileNoDialog(dispatch, filename, formats.SEQ);\n          break;\n        case \"D64\":\n          loadFileNoDialog(dispatch, filename, formats.d64);\n          break;\n        case \"C\":\n          loadFileNoDialog(dispatch, filename, formats.C);\n\n        break;\n        case \"PRG\":\n        loadFileNoDialog(dispatch, filename, formats.cbase);\n       break;\n\n    }\n\n\n\n\n  }\n\n  render() {\n    return (\n      <Fragment>\n        <FileDrop\n          className={s.appGrid}\n          loadDroppedFile={this.handleLoadPetmate}\n        >\n\n          <div className={s.leftmenubar}>\n            <Toolbar />\n          </div>\n          <DivSize\n            className={s.editor}\n            render={(containerSize: Dims) =>\n            <> <FramebufferTabs />\n            <Editor containerSize={containerSize} />\n            </> }\n          />\n        </FileDrop>\n        <Settings />\n        <ResizeSettings  />\n        <CustomFontsModal />\n        <ExportModal />\n        <ImportModal />\n        <ProgressModal />\n      </Fragment>\n    )\n  }\n}\n\nexport default connect(\n  null,\n  dispatch => {\n    return {\n      Toolbar: reduxToolbar.Toolbar.bindDispatch(dispatch),\n      dispatch\n    }\n  })(AppView)\n","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\palette.ts",["337"],"\nimport { Rgb, PaletteName } from '../redux/types'\n\nconst palette: Rgb[] = [\n  {r:0x00, g:0x00, b:0x00},\n  {r:0xff, g:0xff, b:0xff},\n  {r:146, g:74, b:64},\n  {r:132, g:197, b:204},\n  {r:147, g:81, b:182},\n  {r:114, g:177, b:75},\n  {r:72, g:58, b:164},\n  {r:213, g:223, b:124},\n  {r:153, g:105, b:45},\n  {r:103, g:82, b:1},\n  {r:192, g:129, b:120},\n  {r:96, g:96, b:96},\n  {r:138, g:138, b:138},\n  {r:178, g:236, b:145},\n  {r:134, g:122, b:222},\n  {r:174, g:174, b:174},\n];\n\nfunction hexToRgb(hex: string): Rgb {\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n  if (!result) {\n    throw new Error('hexToRgb: impossible -- must mean a syntax error in color defs in palette.ts');\n  }\n  return {\n      r: parseInt(result[1], 16),\n      g: parseInt(result[2], 16),\n      b: parseInt(result[3], 16)\n  };\n}\n\nconst colodore = [\n  \"#000000\",\"#ffffff\",\"#813338\",\"#75cec8\",\n  \"#8e3c97\",\"#56ac4d\",\"#2e2c9b\",\"#edf171\",\n  \"#8e5029\",\"#553800\",\"#c46c71\",\"#4a4a4a\",\n  \"#7b7b7b\",\"#a9ff9f\",\"#706deb\",\"#b2b2b2\"\n];\n\nconst pepto = [\n  \"#000000\",\"#ffffff\",\"#67372d\",\"#73a3b1\",\n  \"#6e3e83\",\"#5b8d48\",\"#362976\",\"#b7c576\",\n  \"#6c4f2a\",\"#423908\",\"#98675b\",\"#444444\",\n  \"#6c6c6c\",\"#9dd28a\",\"#6d5fb0\",\"#959595\"\n];\n\nconst vice = [\n  \"#000000\",\"#ffffff\",\"#b96a54\",\"#acf3fe\",\n  \"#be73f8\",\"#9ae35b\",\"#695af1\",\"#fffd84\",\n  \"#c5913c\",\"#8c7817\",\"#f3ab98\",\"#818181\",\n  \"#b6b6b6\",\"#dcfea3\",\"#b1a0fc\",\"#e0e0e0\"\n];\n\nexport const colorPalettes: {[k in PaletteName]: Rgb[]} = {\n  'petmate': palette,\n  'colodore': colodore.map(hexToRgb),\n  'pepto': pepto.map(hexToRgb),\n  'vice': vice.map(hexToRgb)\n};\n","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\line.ts",[],"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\external\\react-sortable-hoc\\index.js",[],"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\redux\\customFonts.ts",["338"],"\nimport { Font } from './types';\nimport { ActionsUnion, createAction, DispatchPropsFromActions } from './typeUtils'\n\nconst ADD_CUSTOM_FONT = 'ADD_CUSTOM_FONT'\n\ninterface AddCustomFontArgs {\n  id: string;\n  name: string;\n  font: Font;\n};\n\nconst actionCreators = {\n  addCustomFont: (id: string, name: string, font: Font) => createAction(ADD_CUSTOM_FONT, { id, name, font  } as AddCustomFontArgs)\n};\n\nexport const actions = {\n  ...actionCreators,\n}\n\nexport type Actions = ActionsUnion<typeof actionCreators>;\nexport type PropsFromDispatch = DispatchPropsFromActions<typeof actions>;\nexport type CustomFonts = { [id: string]: { font: Font, name: string } };\n\nexport function reducer(state: CustomFonts = {}, action: Actions): CustomFonts {\n  switch (action.type) {\n  case ADD_CUSTOM_FONT:\n    // TODO handle existing name\n    return {\n      ...state,\n      [action.data.id]: {\n        name: action.data.name,\n        font: action.data.font\n      }\n    }\n  default:\n    return state\n  }\n}\n","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\containers\\Toolbar.tsx",["339"],"import React, {\n  Component,\n  Fragment,\n  PureComponent,\n  FunctionComponent as SFC,\n} from \"react\";\nimport { connect } from \"react-redux\";\nimport { bindActionCreators, Dispatch } from \"redux\";\nimport classnames from \"classnames\";\nimport { ActionCreators } from \"redux-undo\";\n\nimport ColorPicker from \"../components/ColorPicker\";\nimport * as utils from \"../utils\";\nimport * as fp from \"../utils/fp\";\nimport { Toolbar } from \"../redux/toolbar\";\nimport { Framebuffer } from \"../redux/editor\";\nimport * as framebuf from \"../redux/editor\";\nimport * as toolbar from \"../redux/toolbar\";\nimport * as selectors from \"../redux/selectors\";\nimport * as screensSelectors from \"../redux/screensSelectors\";\nimport {\n  getSettingsPaletteRemap,\n  getSettingsCurrentColorPalette,\n} from \"../redux/settingsSelectors\";\nimport * as Root from \"../redux/root\";\nimport { framebufIndexMergeProps } from \"../redux/utils\";\nimport { Tool, Rgb, RootState, FramebufUIState } from \"../redux/types\";\n\nimport { withHoverFade } from \"./hoc\";\n//faSave, faExpand,faExpandAlt,  faMagic\nimport {\n  faClone,\n  faPencilAlt,\n  faUndo,\n  faRedo,\n  faCog,\n  faArrowsAlt,\n  faKeyboard,\n  faFillDrip,\n  faSearch,\n  faDumpsterFire,\n  faCropAlt,\n} from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\n\nimport styles from \"./Toolbar.module.css\";\nimport { IconProp } from \"@fortawesome/fontawesome-svg-core\";\n\n\ninterface IconProps {\n  selected?: boolean;\n  tooltip: string | null;\n  iconName: IconProp | null;\n  bottom: boolean;\n  subIcon?: SFC<{}>;\n  onIconClick: () => void;\n}\n\nclass Icon extends PureComponent<IconProps> {\n  static defaultProps = {\n    bottom: false,\n    subIcon: undefined,\n  };\n  render() {\n    const selectedClass =\n      this.props.selected !== undefined && this.props.selected\n        ? styles.selectedTool\n        : null;\n    const tooltip =\n      this.props.tooltip !== null ? (\n        <span className={styles.tooltiptext}>{this.props.tooltip}</span>\n      ) : null;\n    return (\n      <div\n        className={classnames(\n          styles.tooltip,\n          selectedClass,\n          this.props.bottom ? styles.end : null\n        )}\n        onClick={() => this.props.onIconClick()}\n      >\n        {this.props.iconName !== null ? <FontAwesomeIcon className={styles.icon} icon={this.props.iconName} /> : null}\n        {this.props.subIcon !== undefined ? <this.props.subIcon /> : null}\n        {tooltip}\n      </div>\n    );\n  }\n}\n\ninterface SelectableToolProps {\n  tool: Tool;\n  selectedTool: Tool;\n  setSelectedTool: (tool: Tool) => void;\n}\n\ntype Omit<T, K> = Pick<T, Exclude<keyof T, K>>;\n\nclass SelectableTool extends PureComponent<\n  SelectableToolProps & Omit<IconProps, \"onIconClick\" | \"bottom\">\n> {\n  handleClick = () => {\n    this.props.setSelectedTool(this.props.tool);\n  };\n  render() {\n    const { tool, ...props } = this.props;\n    return (\n      <Icon\n        onIconClick={this.handleClick}\n        selected={tool === this.props.selectedTool}\n        {...props}\n      />\n    );\n  }\n}\n\ninterface FbColorPickerProps {\n  active: boolean;\n  fadeOut: boolean;\n  colorPalette: Rgb[];\n  paletteRemap: number[];\n  color: number;\n  tooltip: string;\n\n  onSelectColor: (idx: number) => void;\n  onToggleActive: () => void;\n}\n\nclass FbColorPicker_ extends PureComponent<FbColorPickerProps> {\n  handleSelectColor = (idx: number) => {\n    this.props.onSelectColor(idx);\n  };\n\n  render() {\n    const { colorPalette } = this.props;\n    const bg = utils.colorIndexToCssRgb(colorPalette, this.props.color);\n\n    let s;\n    if (this.props.tooltip === \"Background\") {\n      s = {\n        height: \"25px\",\n        marginTop: \"-35px\",\n        backgroundColor: bg,\n        flex: \"none\",\n        width: \"27px\",\n      };\n    } else {\n      s = {\n        height: \"40px\",\n        marginTop: \"10px\",\n        backgroundColor: bg,\n        flex: 1,\n      };\n    }\n\n    let picker = null;\n    let tooltip = null;\n    if (this.props.active) {\n      picker = (\n        <div\n          className={classnames(\n            styles.colorpicker,\n            this.props.fadeOut ? styles.fadeOut : null\n          )}\n          style={{\n            top: \"9px\",\n            filter: \"drop-shadow(2.5px 2.5px 1.5px rgba(0,0,0,0.5))\",\n          }}\n        >\n          <ColorPicker\n            onSelectColor={this.handleSelectColor}\n            paletteRemap={this.props.paletteRemap}\n            colorPalette={colorPalette}\n            selected={this.props.color}\n            scale={{ scaleX: 1.5, scaleY: 1.5 }}\n            twoRows={true}\n            ctrlKey={false}\n          />\n        </div>\n      );\n      tooltip = null;\n    } else {\n      tooltip = (\n        <span className={styles.tooltiptext}>{this.props.tooltip}</span>\n      );\n    }\n    return (\n      <Fragment>\n        <div style={s} onClick={this.props.onToggleActive} />\n        {picker}\n        {tooltip}\n      </Fragment>\n    );\n  }\n}\nconst FbColorPicker = withHoverFade(FbColorPicker_);\n\nconst renderColorizeSubIcon: SFC<{}> = () => {\n  return (\n    <div\n      style={{\n        backgroundColor: \"#d77\",\n        position: \"absolute\",\n        width: \"9px\",\n        height: \"9px\",\n        top: \"24px\",\n        left: \"30px\",\n        borderRadius: \"50%\",\n      }}\n    ></div>\n  );\n};\n\nconst renderCharSubIcon: SFC<{}> = () => {\n  return (\n    <div\n      style={{\n        position: \"absolute\",\n        width: \"9px\",\n        height: \"9px\",\n        top: \"18px\",\n        left: \"30px\",\n      }}\n    >\n      A\n    </div>\n  );\n};\n\nconst renderfaSearch: SFC<{}> = () => {\n  return (\n    <div style={{\n        position: \"absolute\",\n        width: \"9px\",\n        height: \"9px\",\n        top: \"22px\",\n        left: \"8px\",\n        fontSize:\"10px\"\n      }}\n    >\n     <FontAwesomeIcon icon={faSearch}></FontAwesomeIcon>\n    </div>\n  );\n};\n\n\nconst renderSelectDashed: SFC<{}> = () => {\n  return (\n    <div\n      style={{\n        margin: \"8px\",\n        width: \"24px\",\n        height: \"24px\",\n        border: \"2px dashed #787878\",\n      }}\n    ></div>\n  );\n};\n\ninterface CanvasFitSubMenuProps {\n  fit: FramebufUIState[\"canvasFit\"];\n  setFit: (fit: FramebufUIState[\"canvasFit\"]) => void;\n}\n\ninterface SelectButtonProps extends CanvasFitSubMenuProps {\n  name: FramebufUIState[\"canvasFit\"];\n  children: {};\n}\n\nconst SelectButton: SFC<SelectButtonProps> = (props: SelectButtonProps) => {\n  const { name, fit, setFit, children } = props;\n  return (\n    <div\n      className={styles.canvasFitSelectButton}\n      style={{\n        borderStyle: \"solid\",\n        borderWidth: \"0px\",\n        borderColor:\n          name === fit ? \"rgba(255,255,255,0.4)\" : \"rgba(255,255,255,0.0)\",\n      }}\n      onClick={() => setFit(name)}\n    >\n      {children}\n    </div>\n  );\n};\n\nclass CanvasFitSubMenu extends PureComponent<CanvasFitSubMenuProps> {\n  render() {\n\n    return (\n      <div\n        style={{\n\n          alignItems: \"center\",\n          fontSize: \"0.6em\",\n          color: \"rgb(120,120,120)\",\n          display: \"None\",\n        }}\n      >\n\n\n        <SelectButton\n          name=\"fitWidth\"\n          fit={this.props.fit}\n          setFit={this.props.setFit}\n        >\n          W\n        </SelectButton>\n        <SelectButton\n          name=\"fitWidthHeight\"\n          fit={this.props.fit}\n          setFit={this.props.setFit}\n        >\n          WxH\n        </SelectButton>\n        <SelectButton\n          name=\"fitHeight\"\n          fit={this.props.fit}\n          setFit={this.props.setFit}\n        >\n          H\n        </SelectButton>\n      </div>\n    );\n  }\n}\n\ninterface ToolbarSelectorProps {\n  framebufIndex: number | null;\n  selectedTool: Tool;\n  backgroundColor: number | null;\n  borderColor: number | null;\n  borderOn: boolean | null;\n  width:  number | null;\n  height:  number | null;\n  paletteRemap: number[];\n  colorPalette: Rgb[];\n  canvasFit: FramebufUIState[\"canvasFit\"];\n  ctrlKey: boolean;\n  shiftKey: boolean;\n  altKey: boolean;\n}\n\ninterface ToolbarViewProps extends ToolbarSelectorProps {\n  readonly Framebuffer: framebuf.PropsFromDispatch;\n  readonly Toolbar: toolbar.PropsFromDispatch;\n  setFramebufCanvasFit: (fit: FramebufUIState[\"canvasFit\"]) => void;\n  // Undoable dispatchers\n  undo: () => void;\n  redo: () => void;\n}\n\ninterface ToolbarViewState {\n  readonly pickerActive: {\n    border: boolean;\n    background: boolean;\n  };\n}\n\nclass ToolbarView extends Component<\n  ToolbarViewProps & ToolbarSelectorProps,\n  ToolbarViewState\n> {\n  state = {\n    pickerActive: {\n      border: false,\n      background: false,\n    },\n  };\n\n  setPickerActive = (\n    pickerId: \"border\" | \"background\" | \"canvasFit\",\n    val: boolean\n  ) => {\n    this.setState((prevState) => {\n      return {\n        pickerActive: {\n          ...prevState.pickerActive,\n          [pickerId]: val,\n        },\n      };\n    });\n  };\n\n  handleSelectBgColor = (color: number) => {\n    this.setPickerActive(\"background\", false);\n    this.props.Framebuffer.setBackgroundColor(color);\n  };\n\n  handleSelectBorderColor = (color: number) => {\n    this.setPickerActive(\"border\", false);\n    this.props.Framebuffer.setBorderColor(color);\n  };\n\n  render() {\n    if (this.props.backgroundColor === null) {\n      return null;\n    }\n    type MkToolArgs = {\n      tool: Tool;\n      iconName: IconProp | null;\n      tooltip: string;\n      subIcon?: SFC<{}>;\n    };\n    const mkTool = ({ tool, iconName, tooltip, subIcon }: MkToolArgs) => {\n      return (\n        <SelectableTool\n          key={tool}\n          tool={tool}\n          setSelectedTool={this.props.Toolbar.setSelectedTool}\n          selectedTool={this.props.selectedTool}\n          iconName={iconName}\n          tooltip={tooltip}\n          subIcon={subIcon}\n        />\n      );\n    };\n    const tools = [\n      mkTool({\n        tool: Tool.PanZoom,\n        iconName: faArrowsAlt,\n        tooltip: \"Pan/zoom\",\n        subIcon: renderfaSearch,\n\n      }),\n      mkTool({\n        tool: Tool.Brush,\n        iconName: null,\n        tooltip: \"Select\",\n        subIcon: renderSelectDashed,\n      }),\n      mkTool({\n        tool: Tool.Draw,\n        iconName: faPencilAlt,\n        tooltip: \"Char & Color\",\n      }),\n      mkTool({\n        tool: Tool.Colorize,\n        iconName: faPencilAlt,\n        tooltip: \"Color only\",\n        subIcon: renderColorizeSubIcon,\n      }),\n      mkTool({\n        tool: Tool.CharDraw,\n        iconName: faPencilAlt,\n        tooltip: \"Char only\",\n        subIcon: renderCharSubIcon,\n      }),\n\n      mkTool({\n        tool: Tool.Text,\n        iconName: faKeyboard,\n        tooltip: \"Keyboard Entry Mode\",\n      }),\n      mkTool({\n        tool: Tool.FloodFill,\n        iconName: faFillDrip,\n        tooltip: \"Flood Fill\",\n      }),\n\n\n    ];\n    return (\n      <div className={styles.toolbar}>\n        <Icon onIconClick={this.props.undo} iconName={faUndo} tooltip=\"Undo\" />\n        <Icon onIconClick={this.props.redo} iconName={faRedo} tooltip=\"Redo\" />\n        {tools}\n        <Icon\n          onIconClick={()=>{\n\n          this.props.Toolbar.resizeDims();\n           this.props.Toolbar.setShowResizeSettings(true);\n\n        }}\n          iconName={faCropAlt}\n          tooltip=\"Crop/Resize\"\n        />\n        <Icon\n          onIconClick={()=>{\n          this.props.Toolbar.clearCanvas();\n        }}\n          iconName={faDumpsterFire}\n          tooltip=\"Clear canvas\"\n        />\n        <Icon\n          onIconClick={() => {\n\nif(this.props.ctrlKey||this.props.shiftKey||this.props.altKey)\n{\n            if(this.props.ctrlKey){\n              if(this.props.shiftKey)\n              {\n                console.log(\"All Borders Off\")\n                this.props.Toolbar.setAllBorder(false);\n              }else\n              {\n              console.log(\"All Borders On\")\n              this.props.Toolbar.setAllBorder(true);\n              }\n            }\n            if(this.props.altKey)\n            {\n              console.log(\"All Borders Flip\")\n              this.props.Toolbar.setAllBorderFlip();\n            }\n          }else\n          {\n            this.props.Framebuffer.setBorderOn(!this.props.borderOn!);\n          }\n\n          }}\n          iconName={faClone}\n          tooltip=\"Border On/Off\"\n        />\n\n        <FbColorPicker\n          pickerId=\"border\"\n          containerClassName={styles.tooltip}\n          active={this.state.pickerActive.border}\n          color={this.props.borderColor!}\n          onSetActive={this.setPickerActive}\n          onSelectColor={this.handleSelectBorderColor}\n          paletteRemap={this.props.paletteRemap}\n          colorPalette={this.props.colorPalette}\n          tooltip=\"Border\"\n        />\n        <FbColorPicker\n          pickerId=\"background\"\n          containerClassName={styles.tooltip}\n          active={this.state.pickerActive.background}\n          color={this.props.backgroundColor}\n          onSetActive={this.setPickerActive}\n          onSelectColor={this.handleSelectBgColor}\n          paletteRemap={this.props.paletteRemap}\n          colorPalette={this.props.colorPalette}\n          tooltip=\"Background\"\n        />\n        <CanvasFitSubMenu\n          fit={this.props.canvasFit}\n          setFit={this.props.setFramebufCanvasFit}\n        />\n\n        <Icon\n          bottom={true}\n          onIconClick={() => this.props.Toolbar.setShowSettings(true)}\n          iconName={faCog}\n          tooltip=\"Preferences\"\n        />\n      </div>\n    );\n  }\n}\n\nconst undoActions = {\n  undo: (framebufIndex: number) => {\n    return {\n      ...ActionCreators.undo(),\n      framebufIndex,\n    };\n  },\n  redo: (framebufIndex: number) => {\n    return {\n      ...ActionCreators.redo(),\n      framebufIndex,\n    };\n  },\n};\nconst mapDispatchToProps = (dispatch: any) => {\n  function setCanvasFit(canvasFit: FramebufUIState[\"canvasFit\"]) {\n    return (dispatch: Dispatch, getState: any) => {\n      const state = getState();\n      const fbIndex = screensSelectors.getCurrentScreenFramebufIndex(state)!;\n      const prevState = selectors.getFramebufUIState(getState(), fbIndex);\n      dispatch(\n        Toolbar.actions.setFramebufUIState(fbIndex, {\n          ...prevState!,\n          canvasFit,\n        })\n      );\n    };\n  }\n  return {\n    ...bindActionCreators(undoActions, dispatch),\n    ...bindActionCreators(Root.actions, dispatch),\n    Toolbar: Toolbar.bindDispatch(dispatch),\n    Framebuffer: Framebuffer.bindDispatch(dispatch),\n    setFramebufCanvasFit: (f: FramebufUIState[\"canvasFit\"]) =>\n      dispatch(setCanvasFit(f)),\n  };\n};\n\nconst mapStateToProps = (state: RootState): ToolbarSelectorProps => {\n  const framebuf = selectors.getCurrentFramebuf(state);\n  const framebufIndex = screensSelectors.getCurrentScreenFramebufIndex(state);\n  let canvasFit: FramebufUIState[\"canvasFit\"] = \"fitWidth\";\n\nif(framebuf!==null)\n{\n\n\n/*\n\n  console.log(framebuf);\n\n  const rWidth = 666\n  const rHeight = framebuf.height\n //Toolbar.actions.setResizeWidth(rWidth)\n  state.toolbar.resizeWidth = rWidth\n//  Toolbar.actions.setResizeHeight(rHeight)\n  state.toolbar.resizeHeight = rHeight\n // console.log('!!!!!mapStateToProps',framebuf?.width,framebuf?.height,state.toolbar.resizeWidth,state.toolbar.resizeHeight,)\n*/\n}\n\n  if (framebufIndex !== null) {\n\n\n    const uis = selectors.getFramebufUIState(state, framebufIndex);\n    canvasFit = uis!.canvasFit;\n  }\n  return {\n    framebufIndex,\n    backgroundColor: fp.maybe(framebuf, null, (fb) => fb.backgroundColor),\n    borderColor: fp.maybe(framebuf, null, (fb) => fb.borderColor),\n    borderOn: fp.maybe(framebuf, null, (fb) => fb.borderOn),\n    width:fp.maybe(framebuf, null, (fb) => fb.width),\n    height:fp.maybe(framebuf, null, (fb) => fb.height),\n    selectedTool: state.toolbar.selectedTool,\n    paletteRemap: getSettingsPaletteRemap(state),\n    colorPalette: getSettingsCurrentColorPalette(state),\n    canvasFit,\n    ctrlKey: state.toolbar.ctrlKey,\n    shiftKey: state.toolbar.shiftKey,\n    altKey: state.toolbar.altKey,\n  };\n};\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps,\n  framebufIndexMergeProps\n)(ToolbarView);\n","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\containers\\FramebufferTabs.tsx",["340"],"import React, {\n  Component,\n  PureComponent,\n  useState,\n  useCallback,\n  CSSProperties,\n} from \"react\";\nimport { connect } from \"react-redux\";\nimport { bindActionCreators } from \"redux\";\nimport {\n  SortableContainer,\n  SortableElement,\n  arrayMove,\n} from \"../external/react-sortable-hoc\";\n\nimport classnames from \"classnames\";\n\nimport ContextMenuArea from \"./ContextMenuArea\";\n\nimport CharGrid from \"../components/CharGrid\";\nimport * as framebuf from \"../redux/editor\";\nimport * as toolbar from \"../redux/toolbar\";\nimport * as screens from \"../redux/screens\";\nimport * as selectors from \"../redux/selectors\";\nimport * as screensSelectors from \"../redux/screensSelectors\";\nimport { getSettingsCurrentColorPalette } from \"../redux/settingsSelectors\";\n\nimport * as utils from \"../utils\";\nimport * as fp from \"../utils/fp\";\n\nimport {\n  faPlus,\n  faAlignLeft,\n  faAlignCenter,\n} from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\n\nimport styles from \"./FramebufferTabs.module.css\";\nimport {\n  Framebuf,\n  FramebufWithFont,\n  Rgb,\n  Font,\n  RootState,\n  RgbPalette,\n} from \"../redux/types\";\nimport { electron } from \"../utils/electronImports\";\nimport { getJSON, getPNG } from \"../utils/exporters\";\nimport { CustomFonts } from \"../redux/customFonts\";\nimport {\n  ActionsUnion,\n  createAction,\n  DispatchPropsFromActions,\n} from \"../redux/typeUtils\";\nimport { framebufFromJson } from \"../redux/workspace\";\n\ninterface NameInputDispatchProps {\n  Toolbar: toolbar.PropsFromDispatch;\n}\n\ninterface NameInputProps {\n  name: string;\n\n  onSubmit: (name: string) => void;\n  onCancel: () => void;\n  onBlur: () => void;\n}\n\ninterface NameInputState {\n  name: string;\n}\n\n// This class is a bit funky with how it disables/enables keyboard shortcuts\n// globally for the app while the input element has focus.  Maybe there'd be a\n// better way to do this, but this seems to work.\nclass NameInput_ extends Component<\n  NameInputProps & NameInputDispatchProps,\n  NameInputState\n> {\n  state = {\n    name: this.props.name,\n  };\n\n  componentWillUnmount() {\n    this.props.Toolbar.setShortcutsActive(true);\n  }\n\n  handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {\n    e.preventDefault();\n    this.props.onSubmit(this.state.name);\n    this.props.Toolbar.setShortcutsActive(true);\n  };\n\n  handleChange = (e: React.FormEvent<EventTarget>) => {\n    let target = e.target as HTMLInputElement;\n    this.setState({ name: target.value });\n  };\n\n  handleKeyDown = (e: React.KeyboardEvent) => {\n    if (e.key === \"Escape\") {\n      e.preventDefault();\n      this.props.onCancel();\n      this.props.Toolbar.setShortcutsActive(true);\n    }\n  };\n\n  handleBlur = (_e: React.FormEvent<HTMLInputElement>) => {\n    this.props.onBlur();\n    this.props.Toolbar.setShortcutsActive(true);\n  };\n\n  handleFocus = (e: React.FormEvent<HTMLInputElement>) => {\n    let target = e.target as HTMLInputElement;\n    this.props.Toolbar.setShortcutsActive(false);\n    target.select();\n  };\n\n  render() {\n    return (\n      <div className={styles.tabNameEditor}>\n        <form onSubmit={this.handleSubmit}>\n          <input\n            autoFocus\n            onKeyDown={this.handleKeyDown}\n            value={this.state.name}\n            onChange={this.handleChange}\n            onBlur={this.handleBlur}\n            onFocus={this.handleFocus}\n            type=\"text\"\n            size={14}\n          />\n        </form>\n      </div>\n    );\n  }\n}\n\nconst NameInput = connect(null, (dispatch) => {\n  return {\n    Toolbar: bindActionCreators(toolbar.Toolbar.actions, dispatch),\n  };\n})(NameInput_);\n\ninterface NameEditorProps {\n  name: string;\n\n  onNameSave: (name: string) => void;\n}\n\ninterface NameEditorState {\n  editing: boolean;\n}\n\nclass NameEditor extends Component<NameEditorProps, NameEditorState> {\n  state = {\n    editing: false,\n  };\n\n  handleEditingClick = () => {\n    this.setState({ editing: true });\n  };\n\n  handleBlur = () => {\n    this.setState({ editing: false });\n  };\n\n  handleSubmit = (name: string) => {\n    this.setState({ editing: false });\n    this.props.onNameSave(name);\n  };\n\n  handleCancel = () => {\n    this.setState({ editing: false });\n  };\n\n  render() {\n    const nameElts = this.state.editing ? (\n      <NameInput\n        name={this.props.name}\n        onSubmit={this.handleSubmit}\n        onBlur={this.handleBlur}\n        onCancel={this.handleCancel}\n      />\n    ) : (\n      <div className={styles.tabName} onClick={this.handleEditingClick}>\n        {this.props.name}\n      </div>\n    );\n    return <div className={styles.tabNameContainer}>{nameElts}</div>;\n  }\n}\n\nfunction computeContainerSize(fb: Framebuf) {\n  const pixWidth = fb.width * 8;\n  const pixHeight = fb.height * 8;\n  // TODO if height is bigger than maxHeight, need to scale differently\n  // to fit the box.\n\n  let s;\n  if (pixHeight > 200) {\n    s = 120 / pixWidth;\n  } else {\n    s = 75 / pixHeight;\n  }\n\n  if (pixWidth > 320) {\n    s = 75 / pixHeight;\n  }\n\n  if (pixHeight == pixWidth) {\n    s = 120 / pixWidth;\n  }\n  return {\n    divWidth: \"120px\",\n    divHeight: \"75px\",\n    scaleX: s,\n    scaleY: s,\n  };\n}\n\ninterface FramebufTabProps {\n  id: number;\n  active: boolean;\n  framebufId: number;\n  framebuf: Framebuf;\n  colorPalette: Rgb[];\n  font: Font;\n\n  setName: (name: string, framebufId: number) => void;\n  onSetActiveTab: (id: number) => void;\n  onDuplicateTab: (id: number) => void;\n  onRemoveTab: (id: number) => void;\n  onCopyTab: (id: number) => void;\n  onCopyPNGTab: (id: number) => void;\n  onPasteTab: (id: number) => void;\n}\n\nclass FramebufTab extends PureComponent<FramebufTabProps> {\n  tabRef = React.createRef<HTMLDivElement>();\n\n  handleSelect = () => {\n    this.props.onSetActiveTab(this.props.id);\n  };\n\n  handleMenuDuplicate = () => {\n    this.props.onDuplicateTab(this.props.id);\n  };\n\n  handleMenuCopy = () => {\n    this.props.onCopyTab(this.props.id);\n  };\n\n\n  handleMenuCopyPNG = () => {\n    this.props.onCopyPNGTab(this.props.id);\n  };\n\n  handleMenuPaste = () => {\n    this.props.onPasteTab(this.props.id);\n  };\n\n  handleMenuRemove = () => {\n    this.props.onRemoveTab(this.props.id);\n  };\n\n  handleNameSave = (name: string) => {\n    if (name !== \"\") {\n      this.props.setName(name, this.props.framebufId);\n    }\n  };\n\n  componentDidUpdate() {\n    if (this.props.active && this.tabRef.current) {\n      this.tabRef.current.scrollIntoView();\n    }\n  }\n\n  render() {\n    const { width, height, framebuf, backgroundColor, borderColor } =\n      this.props.framebuf;\n    const font = this.props.font;\n    const colorPalette = this.props.colorPalette;\n    const backg = utils.colorIndexToCssRgb(colorPalette, backgroundColor);\n    const bord = utils.colorIndexToCssRgb(colorPalette, borderColor);\n    //const maxHeight = 25*2*1.5;\n    const { scaleX, scaleY } = computeContainerSize(this.props.framebuf);\n    const s = {\n      width: \"120px\",\n      height: \"75px\",\n      backgroundColor: \"#000\",\n      borderStyle: \"solid\",\n      borderWidth: \"5px\",\n      borderColor: bord,\n      overflow: \"hidden\",\n    };\n    const scaleStyle: CSSProperties = {\n      transform: `scale(${scaleX}, ${scaleY})`,\n      transformOrigin: \"0% 0%\",\n      imageRendering: \"pixelated\",\n    };\n\n    const menuItems = [\n     /* {\n        label: \"Duplicate\",\n        click: this.handleMenuDuplicate,\n      },\n*/      {\n        label: \"Copy\",\n        click: this.handleMenuCopy,\n      },\n      {\n        label: \"Copy to PNG\",\n        click: this.handleMenuCopyPNG,\n      },\n\n      {\n        label: \"Paste\",\n        click: this.handleMenuPaste,\n      },\n      {\n        label: \"Remove\",\n        click: this.handleMenuRemove,\n      },\n    ];\n\n    return (\n      <div\n        style={{\n          display: \"flex\",\n          flexDirection: \"column\",\n          alignItems: \"flex-start\",\n          marginRight: \"8px\",\n        }}\n        ref={this.tabRef}\n      >\n        <ContextMenuArea menuItems={menuItems}>\n          <div\n            onClick={this.handleSelect}\n            className={classnames(\n              styles.tab,\n              this.props.active ? styles.active : null\n            )}\n            style={s}\n          >\n            <div style={scaleStyle}>\n              <CharGrid\n                width={width}\n                height={height}\n                backgroundColor={backg}\n                grid={false}\n                framebuf={framebuf}\n                font={font}\n                colorPalette={colorPalette}\n              />\n            </div>\n            <div\n              style={{\n                backgroundColor: \"#444\",\n                color: \"#fff\",\n                padding: \"2px\",\n                position: \"relative\",\n                marginLeft: \"auto\",\n                marginTop: \"54px\",\n                width: \"fit-content\",\n                fontSize: \".8em\",\n                textAlign: \"right\",\n                border: \"0px solid #000\",\n              }}\n            >\n              {width}x{height}\n            </div>\n          </div>\n        </ContextMenuArea>\n        <NameEditor\n          name={fp.maybeDefault(this.props.framebuf.name, \"Untitled\" as string)}\n          onNameSave={this.handleNameSave}\n        />\n      </div>\n    );\n  }\n}\n\nconst SortableFramebufTab = SortableElement((props: FramebufTabProps) => (\n  <FramebufTab {...props} />\n));\n\nconst SortableTabList = SortableContainer((props: { children: any }) => {\n  return <div className={styles.tabs}>{props.children}</div>;\n});\n\ntype ScreenDimsProps = {\n  dims: {\n    width: number;\n    height: number;\n  };\n  Toolbar: toolbar.PropsFromDispatch;\n};\n\ntype ScreenDimsEditProps = {\n  stopEditing: () => void;\n};\n\nfunction ScreenDimsEdit(props: ScreenDimsProps & ScreenDimsEditProps) {\n  const { width, height } = props.dims;\n  const [dimsText, setDimsText] = useState(`${width}x${height}`);\n\n  const handleBlur = useCallback(() => {\n    props.stopEditing();\n  }, []);\n\n  const handleSubmit = useCallback(\n    (e: React.FormEvent) => {\n      e.preventDefault();\n      props.stopEditing();\n      const numsRe = /^([0-9]+)x([0-9]+)/;\n      const matches = numsRe.exec(dimsText);\n      if (matches) {\n        const width = Math.max(1, Math.min(1024, parseInt(matches[1])));\n        const height = Math.max(1, Math.min(1024, parseInt(matches[2])));\n        props.Toolbar.setNewScreenSize({ width, height });\n      }\n    },\n    [dimsText]\n  );\n\n  const handleChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {\n    setDimsText(e.target.value);\n  }, []);\n\n  const handleKeyDown = useCallback(\n    (e: React.KeyboardEvent<HTMLInputElement>) => {\n      if (e.key === \"Escape\") {\n        props.stopEditing();\n      }\n    },\n    []\n  );\n\n  const handleFocus = useCallback((e: React.FormEvent<HTMLInputElement>) => {\n    let target = e.target as HTMLInputElement;\n    props.Toolbar.setShortcutsActive(false);\n    target.select();\n  }, []);\n\n  return (\n    <div className={styles.tabNameEditor}>\n      <form onSubmit={handleSubmit}>\n        <input\n          autoFocus\n          type=\"text\"\n          pattern=\"[0-9]+x[0-9]+\"\n          title=\"Specify screen width x height (e.g., 40x25)\"\n          value={dimsText}\n          onKeyDown={handleKeyDown}\n          onBlur={handleBlur}\n          onFocus={handleFocus}\n          onChange={handleChange}\n        />\n      </form>\n    </div>\n  );\n}\n\nfunction ScreenDims(props: ScreenDimsProps) {\n  const [editing, setEditing] = useState(false);\n  const stopEditing = useCallback(() => {\n    setEditing(false);\n    props.Toolbar.setShortcutsActive(true);\n  }, []);\n  return (\n    <div className={styles.screenDimContainer} onClick={() => setEditing(true)}>\n      {editing ? (\n        <ScreenDimsEdit {...props} stopEditing={stopEditing} />\n      ) : (\n        <div className={styles.screenDimText}>\n          {props.dims.width}x{props.dims.height}\n        </div>\n      )}\n    </div>\n  );\n}\n\nfunction NewTabButton(props: {\n  dims: { width: number; height: number };\n  onClick: () => void;\n  onClickLeft: () => void;\n  onClickCenter: () => void;\n\n  Toolbar: toolbar.PropsFromDispatch;\n}) {\n  // onClick is not in FontAwesomeIcon props and don't know how to pass\n  // it otherwise.\n  const typingWorkaround = { onClick: props.onClick };\n  const onClickL = { onClick: props.onClickLeft };\n  const onClickC = { onClick: props.onClickCenter };\n\n  return (\n    <div\n      style={{\n        border: \"1px solid #333\",\n        margin: \"0px\",\n        marginRight: \"8px\",\n        textAlign: \"center\",\n        padding: \"16px\",\n        cursor: \"pointer\",\n        color: \"#bdbdbd\",\n        width: \"50px\",\n      }}\n    >\n      <FontAwesomeIcon {...typingWorkaround} icon={faPlus} size=\"2x\" />\n      <ScreenDims dims={props.dims} Toolbar={props.Toolbar} />\n      <div style={{ marginTop: \"4px\", padding: \"2px\", display: \"flex\" }}>\n        <FontAwesomeIcon\n          {...onClickL}\n          style={{\n            marginRight: \"8px\",\n            marginTop: \"4px\",\n            padding: \"2px\",\n            border: \"1px solid #666\",\n            borderRadius: \"2px\",\n          }}\n          icon={faAlignLeft}\n          size=\"1x\"\n        />\n        <FontAwesomeIcon\n          {...onClickC}\n          style={{\n            marginLeft: \"0px\",\n            marginTop: \"4px\",\n            padding: \"2px\",\n            border: \"1px solid #666\",\n            borderRadius: \"2px\",\n          }}\n          icon={faAlignCenter}\n          size=\"1x\"\n        />\n      </div>\n    </div>\n  );\n}\n\ninterface FramebufferTabsDispatch {\n  Screens: screens.PropsFromDispatch;\n  Toolbar: toolbar.PropsFromDispatch;\n}\n\ninterface FramebufferTabsProps {\n  screens: number[];\n  activeScreen: number;\n  colorPalette: Rgb[];\n  newScreenSize: { width: number; height: number };\n\n  getFramebufByIndex: (framebufId: number) => Framebuf | null;\n  getFont: (framebuf: Framebuf) => { charset: string; font: Font };\n  setFramebufName: (name: string, framebufIndex: number) => void;\n}\n\nclass FramebufferTabs_ extends Component<\n  FramebufferTabsProps & FramebufferTabsDispatch\n> {\n  handleActiveClick = (idx: number) => {\n    this.props.Screens.setCurrentScreenIndex(idx);\n  };\n\n  handleNewTab = () => {\n    this.props.Screens.newScreen();\n    // Context menu eats the ctrl key up event, so force it to false\n    this.props.Toolbar.setCtrlKey(false);\n  };\n  handleAllFramesLeft = () => {\n    const currentScreen = this.props.activeScreen;\n\n    const lis = this.props.screens.map((framebufId, i) => {\n      //const framebuf = this.props.getFramebufByIndex(framebufId)!\n      this.props.Screens.setCurrentScreenIndex(framebufId);\n      this.props.Toolbar.setZoom(101, \"left\");\n    });\n    this.props.Screens.setCurrentScreenIndex(currentScreen);\n  };\n  handleAllFramesCenter = () => {\n    const currentScreen = this.props.activeScreen;\n\n    const lis = this.props.screens.map((framebufId, i) => {\n      const framebuf = this.props.getFramebufByIndex(framebufId)!;\n      this.props.Screens.setCurrentScreenIndex(framebufId);\n      this.props.Toolbar.setZoom(101, \"center\");\n    });\n    this.props.Screens.setCurrentScreenIndex(currentScreen);\n  };\n\n  handleRemoveTab = (idx: number) => {\n    this.props.Screens.removeScreen(idx);\n    // Context menu eats the ctrl key up event, so force it to false\n    this.props.Toolbar.setCtrlKey(false);\n  };\n\n  handleDuplicateTab = (idx: number) => {\n    this.props.Screens.cloneScreen(idx);\n    // Context menu eats the ctrl key up event, so force it to false\n    this.props.Toolbar.setCtrlKey(false);\n  };\n\n  handleCopyTab = (idx: number) => {\n    const frameId = this.props.screens[idx];\n    const copyFrame = this.props.getFramebufByIndex(frameId);\n\n    if (copyFrame != null) {\n      const { font } = this.props.getFont(copyFrame);\n      const copyFrameWithFont: FramebufWithFont = {\n        ...copyFrame,\n        font,\n      };\n\n      const JSONData = getJSON(copyFrameWithFont, {});\n\n      electron.clipboard.writeBuffer(\n        \"petmate/framebuffer\",\n        Buffer.from(JSONData, \"utf-8\")\n      );\n    }\n    // Context menu eats the ctrl key up event, so force it to false\n    this.props.Toolbar.setCtrlKey(false);\n  };\n\n  handleCopyPNGTab = (idx: number) => {\n    const frameId = this.props.screens[idx];\n    const copyFrame = this.props.getFramebufByIndex(frameId);\n\n    if (copyFrame != null) {\n      const { font } = this.props.getFont(copyFrame);\n      const copyFrameWithFont: FramebufWithFont = {\n        ...copyFrame,\n        font,\n      };\n\n      console.log('b4 electron.clipboard.availableFormats():',electron.clipboard.availableFormats());\n\n      electron.clipboard.writeBuffer(\n        \"image/png\",\n        Buffer.from(getPNG(copyFrameWithFont, this.props.colorPalette))\n      );\n\n      console.log('After electron.clipboard.availableFormats():',electron.clipboard.availableFormats());\n\n    }\n    // Context menu eats the ctrl key up event, so force it to false\n    this.props.Toolbar.setCtrlKey(false);\n  };\n\n  handlePasteTab = (idx: number) => {\n    const frameId = this.props.screens[idx];\n\n    if (electron.clipboard.has(\"petmate/framebuffer\")) {\n      const pastedFrameBuffer = JSON.parse(\n        Buffer.from(\n          electron.clipboard.readBuffer(\"petmate/framebuffer\")\n        ).toString()\n      ).framebufs;\n      console.log(\"handlePasteTab\", idx, frameId, pastedFrameBuffer.name);\n      this.props.Screens.addScreenPlusFramebuf(frameId, pastedFrameBuffer);\n    }\n\n    // Context menu eats the ctrl key up event, so force it to false\n    this.props.Toolbar.setCtrlKey(false);\n  };\n\n  onSortEnd = (args: { oldIndex: number; newIndex: number }) => {\n    this.props.Screens.setScreenOrder(\n      arrayMove(this.props.screens, args.oldIndex, args.newIndex)\n    );\n  };\n\n  render() {\n    const lis = this.props.screens.map((framebufId, i) => {\n      const framebuf = this.props.getFramebufByIndex(framebufId)!;\n      const { font } = this.props.getFont(framebuf);\n      return (\n        <SortableFramebufTab\n          key={framebufId}\n          index={i}\n          id={i}\n          framebufId={framebufId}\n          onSetActiveTab={this.handleActiveClick}\n          onRemoveTab={this.handleRemoveTab}\n          onDuplicateTab={this.handleDuplicateTab}\n          onCopyTab={this.handleCopyTab}\n          onCopyPNGTab={this.handleCopyPNGTab}\n          onPasteTab={this.handlePasteTab}\n          framebuf={framebuf}\n          active={i === this.props.activeScreen}\n          font={font}\n          colorPalette={this.props.colorPalette}\n          setName={this.props.setFramebufName}\n        />\n      );\n    });\n    return (\n      <div style={{ width: \"100%\", display: \"flex\" }}>\n        <NewTabButton\n          dims={this.props.newScreenSize}\n          Toolbar={this.props.Toolbar}\n          onClick={this.handleNewTab}\n          onClickLeft={this.handleAllFramesLeft}\n          onClickCenter={this.handleAllFramesCenter}\n        />\n\n        <div className={styles.tabHeadings}>\n          <SortableTabList\n            distance={5}\n            axis=\"x\"\n            lockAxis=\"x\"\n            onSortEnd={this.onSortEnd}\n          >\n            {lis}\n            <div className=\"tab\">&nbsp;</div>\n          </SortableTabList>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default connect(\n  (state: RootState) => {\n    return {\n      newScreenSize: state.toolbar.newScreenSize,\n      activeScreen: screensSelectors.getCurrentScreenIndex(state),\n      screens: screensSelectors.getScreens(state),\n      getFramebufByIndex: (idx: number) =>\n        selectors.getFramebufByIndex(state, idx),\n      getFont: (fb: Framebuf) => selectors.getFramebufFont(state, fb),\n      colorPalette: getSettingsCurrentColorPalette(state),\n    };\n  },\n  (dispatch) => {\n    return {\n      Toolbar: toolbar.Toolbar.bindDispatch(dispatch),\n      Screens: bindActionCreators(screens.actions, dispatch),\n      setFramebufName: bindActionCreators(framebuf.actions.setName, dispatch),\n    };\n  }\n)(FramebufferTabs_);\n","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\containers\\Settings.tsx",[],"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\containers\\ProgressModal.tsx",[],"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\containers\\ImportModal.tsx",["341"],"import React, { Component, StatelessComponent as SFC, CSSProperties } from 'react'\nimport { connect } from 'react-redux'\nimport { bindActionCreators } from 'redux';\nimport memoize  from 'fast-memoize'\nimport { PNG } from 'pngjs'\nimport classnames from 'classnames'\nimport Modal from '../components/Modal'\n\nimport * as toolbar from '../redux/toolbar'\nimport * as ReduxRoot from '../redux/root'\n\nimport { FileFormat, RootState, Pixel, Rgb, Framebuf } from '../redux/types';\nimport CharGrid from '../components/CharGrid';\nimport FontSelector from '../components/FontSelector';\nimport { getROMFontBits } from '../redux/selectors';\nimport { dialogReadFile, colorIndexToCssRgb, colorPalettes } from '../utils';\n\nimport * as png2pet from '../utils/importers/png2petscii'\nimport { DEFAULT_BACKGROUND_COLOR, DEFAULT_BORDER_COLOR, DEFAULT_ZOOM, DEFAULT_ZOOMREADY } from '../redux/editor';\nimport { getSettingsCurrentColorPalette } from '../redux/settingsSelectors';\nimport ColorPicker from '../components/ColorPicker';\n\nimport styles from './ImportModal.module.css'\n\nconst ModalTitle: SFC<{}> = ({children}) => <h2>{children}</h2>\nconst Title: SFC<{}> = ({children}) => <h4>{children}</h4>\nconst ErrorMsg: SFC<{ msg: string }> = ({ msg }) => <div className={classnames(styles.error, styles.title)}>Error: <span className={classnames(styles.error, styles.msg)}>{msg}</span></div>\nconst Text: SFC<{}> = ({children}) => <div className={styles.text}>{children}</div>\n\nconst getROMFontBitsMemoized = memoize(getROMFontBits);\nconst petsciifyMemoized = memoize(petsciify);\n\ninterface PngPreviewProps {\n  currentColorPalette: Rgb[];\n  framebuf: Pixel[][];\n  backgroundColor: number;\n  borderColor: number;\n  width: number;  // PETSCII width in chars\n  height: number; // PETSCII height in chars\n  charset: string;\n}\n\nfunction convertScreencodes(\n  width: number,\n  height: number,\n  screencodes: Uint8Array,\n  colors: (number|undefined)[]\n): Pixel[][] {\n  const dst = Array(height);\n  for (let y = 0; y < height; y++) {\n    const row = Array(width);\n    for (let x = 0; x < width; x++) {\n      const code = screencodes[y*width + x];\n      const color = colors[y*width + x];\n      row[x] = { code, color: color == undefined ? DEFAULT_BACKGROUND_COLOR : color };\n    }\n    dst[y] = row;\n  }\n  return dst;\n}\n\nclass PngPreview extends Component<PngPreviewProps> {\n  render () {\n    const { width, height, backgroundColor } = this.props;\n    const scaleX = 1.0;\n    const scaleY = 1.0;\n    const scale: CSSProperties = {\n      width: width*8,\n      height: height*8,\n      transform: `scale(${scaleX},${scaleY})`,\n      transformOrigin: '0% 0%',\n      imageRendering: 'pixelated',\n      borderColor: colorIndexToCssRgb(this.props.currentColorPalette, this.props.borderColor),\n      borderWidth: '10px',\n      borderStyle: 'solid',\n    }\n    const font = getROMFontBitsMemoized(this.props.charset);\n    return (\n      <div style={{height:'100%'}}>\n        <Title>Preview</Title>\n        <div style={scale}>\n          <CharGrid\n            width={width}\n            height={height}\n            srcX={0}\n            srcY={0}\n            grid={false}\n            font={font}\n            backgroundColor={colorIndexToCssRgb(this.props.currentColorPalette, backgroundColor)}\n            colorPalette={this.props.currentColorPalette}\n            framebuf={this.props.framebuf}\n          />\n        </div>\n      </div>\n    )\n  }\n}\n\ninterface ImportModalProps {\n  showImport: {\n    show: boolean;\n    fmt?: FileFormat; // undefined if show=false\n  };\n  currentColorPalette: Rgb[];\n  colorPalettes: Rgb[][];\n};\n\ninterface ImportModalDispatch {\n  Toolbar: toolbar.PropsFromDispatch;\n  importFramebufsAppend: (framebufs: Framebuf[]) => void;\n}\n\n\ninterface ImportModalState {\n  charset: string;\n  png?: PNG;\n  selectedBackgroundColor?: number;\n}\n\nfunction findMatchByBackgroundColor(\n  matches: png2pet.Match[],\n  backgroundColor: number | undefined\n) {\n  if (backgroundColor == undefined) {\n    return matches[0];\n  }\n  for (let idx in matches) {\n    if (matches[idx].backgroundColor == backgroundColor) {\n      return matches[idx];\n    }\n  }\n  throw new Error('impossible');\n}\n\nfunction toFramebuf(\n  petscii: png2pet.Result,\n  selectedBackgroundColor: number | undefined,\n  charset: string\n): Framebuf {\n  const { width, height, matches, borderColor } = petscii;\n  const match = findMatchByBackgroundColor(matches, selectedBackgroundColor);\n  const f = petscii!;\n  return {\n    framebuf: convertScreencodes(width, height, match.screencodes, match.colors),\n    width: f.width,\n    height: f.height,\n    backgroundColor: match.backgroundColor,\n    borderColor: borderColor != undefined ? borderColor : DEFAULT_BORDER_COLOR,\n    charset,\n    borderOn:false,\n    zoom: DEFAULT_ZOOM,\n    zoomReady: DEFAULT_ZOOMREADY,\n  };\n}\n\nfunction petsciify(png: PNG|undefined, colorPalettes: Rgb[][], charset: string) {\n  if (!png) {\n    return undefined;\n  }\n  const petscii = png2pet.png2petscii({\n    width: png.width,\n    height: png.height,\n    data: png.data,\n    rgbPalettes: colorPalettes,\n    fontBits: Buffer.from(getROMFontBitsMemoized(charset).bits)\n  });\n  return petscii;\n}\n\nclass ImportModal_ extends Component<ImportModalProps & ImportModalDispatch, ImportModalState> {\n\n  state: ImportModalState = {\n    charset: 'upper',\n    selectedBackgroundColor: undefined\n  };\n\n  setPNG = (png?: PNG) => {\n    this.setState({\n      png,\n      charset: 'upper',\n      selectedBackgroundColor: undefined\n    });\n  }\n\n  handleOK = () => {\n    this.props.Toolbar.setShowImport({show:false});\n    const petscii = petsciifyMemoized(this.state.png, this.props.colorPalettes, this.state.charset);\n    if (petscii != undefined && !png2pet.isError(petscii)) {\n      this.props.importFramebufsAppend([toFramebuf(petscii, this.state.selectedBackgroundColor, this.state.charset)]);\n    }\n    this.setPNG();\n  }\n\n  handleCancel = () => {\n    this.props.Toolbar.setShowImport({show:false})\n    this.setPNG();\n  }\n\n  handleSetCharset = (c: string) => {\n    this.setState({ charset: c });\n  }\n\n  handleSelectPng = () => {\n    dialogReadFile(this.props.showImport.fmt!, (data) => {\n      this.setPNG(PNG.sync.read(Buffer.from(data)));\n    });\n  }\n\n  handleSelectBackgroundColor = (color: number) => {\n    this.setState({selectedBackgroundColor: color});\n  }\n\n  render () {\n    const { showImport } = this.props;\n    const petscii = petsciifyMemoized(this.state.png, this.props.colorPalettes, this.state.charset);\n    const matchedBackgroundColors = petscii && !png2pet.isError(petscii) ?\n      petscii.matches.map((m) => m.backgroundColor) : [];\n    const selectedBackground = petscii && !png2pet.isError(petscii) ?\n      (this.state.selectedBackgroundColor == undefined ?\n        matchedBackgroundColors[0] : this.state.selectedBackgroundColor) :\n      0;\n    return (\n      <div>\n        <Modal showModal={showImport.show}>\n          <div style={{\n            display: 'flex',\n            height: '100%',\n            flexDirection: 'column',\n            justifyContent: 'space-between'\n          }}>\n            <div>\n              <ModalTitle>PNG Import Options</ModalTitle>\n\n              {petscii && !png2pet.isError(petscii) &&\n                <div>\n                  <PngPreview\n                    currentColorPalette={this.props.currentColorPalette}\n\n                    {...toFramebuf(petscii, this.state.selectedBackgroundColor, this.state.charset)}\n                  />\n                  {matchedBackgroundColors.length > 1 &&\n                    <div>\n                      <Text>This image can be converted to any of the following background colors.  Pick one:</Text>\n                      <ColorPicker\n                        scale={{scaleX:1, scaleY:1}}\n                        paletteRemap={matchedBackgroundColors}\n                        colorPalette={this.props.currentColorPalette}\n                        selected={selectedBackground}\n                        twoRows={false}\n                        onSelectColor={this.handleSelectBackgroundColor}\n                        ctrlKey={false}\n                      />\n                    </div>\n                  }\n                </div>}\n              {petscii && png2pet.isError(petscii) && <ErrorMsg msg={petscii.error} />}\n              {this.state.png &&\n                <div style={{marginTop: '5px', marginBottom: '5px' }}>\n                  <FontSelector\n                    currentCharset={this.state.charset}\n                    customFonts={[]}\n                    setCharset={this.handleSetCharset} />\n                </div>}\n              <button className='secondary' onClick={this.handleSelectPng}>Select File...</button>\n            </div>\n\n            <div style={{alignSelf: 'flex-end'}}>\n              <button className='cancel' onClick={this.handleCancel}>Cancel</button>\n              <button className='primary' onClick={this.handleOK}>Import</button>\n            </div>\n          </div>\n\n        </Modal>\n      </div>\n    )\n  }\n}\n\nconst getAllRgbPalettes = memoize(function (): Rgb[][] {\n  return Object.values(colorPalettes);\n});\n\nexport default connect(\n  (state: RootState) => {\n    return {\n      showImport: state.toolbar.showImport,\n      currentColorPalette: getSettingsCurrentColorPalette(state),\n      colorPalettes: getAllRgbPalettes()\n    }\n  },\n  (dispatch) => {\n    return {\n      Toolbar: bindActionCreators(toolbar.Toolbar.actions, dispatch),\n      importFramebufsAppend: bindActionCreators(ReduxRoot.actions.importFramebufsAppend, dispatch)\n    }\n  }\n)(ImportModal_)\n","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\containers\\ResizeSettings.tsx",[],"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\containers\\ExportModal.tsx",["342"],"import React, { Component, Fragment, StatelessComponent as SFC } from 'react'\nimport { connect } from 'react-redux'\n\nimport Modal from '../components/Modal'\nimport {\n  connectFormState,\n  Form,\n  Checkbox,\n  RadioButton,\n  NumberInput,\n  TextInput\n\n} from '../components/formHelpers'\n\nimport * as toolbar from '../redux/toolbar'\nimport * as ReduxRoot from '../redux/root'\n\nimport * as utils from '../utils'\nimport { FileFormatGif, FileFormatPng, FileFormatSeq, FileFormatAsm, FileFormatBas, FileFormatJson, FileFormat,FileFormatD64, RootState, FileFormatPlayerV1 } from '../redux/types';\nimport { bindActionCreators } from 'redux';\n\nimport {dialogPickSidFile} from '../utils'\n\nimport styles from './ExportModal.module.css'\n\nconst ModalTitle: SFC<{}> = ({children}) => <h2>{children}</h2>\nconst Title: SFC<{}> = ({children}) => <h4>{children}</h4>\n\ninterface ExportPropsBase {\n  // Set via connectFormStateTyped\n  setField: (name: string, value: any) => void;\n}\n\ninterface GIFExportFormatProps extends ExportPropsBase {\n  state: FileFormatGif['exportOptions'];\n}\n\nclass GIFExportForm extends Component<GIFExportFormatProps> {\n  render () {\n    let fps: string|null = null\n    const delayMS = this.props.state.delayMS\n    if (delayMS !== '') {\n      const delayInt = parseInt(this.props.state.delayMS, 10)\n      if (delayInt !== 0 && !isNaN(delayInt)) {\n        const f = 1000.0 / delayInt\n        fps = `${f.toFixed(1)} fps`\n      }\n    }\n    const animControls = () => {\n      return (\n        <Fragment>\n          <label>Gif anim mode:</label>\n          <br/>\n          <br/>\n          <RadioButton\n            name='loopMode'\n            value='once'\n            label='Play once, no looping'\n          />\n          <RadioButton\n            name='loopMode'\n            value='loop'\n            label='Loop'\n          />\n          <RadioButton\n            name='loopMode'\n            value='pingpong'\n            label='Loop (ping pong)'\n          />\n          <div style={{display: 'flex', flexDirection: 'row'}}>\n            <NumberInput\n              name='delayMS'\n              value={delayMS}\n              label='Frame delay (ms)'\n            />\n            <label style={{marginLeft: '10px'}}>\n             {fps}\n            </label>\n          </div>\n        </Fragment>\n      )\n    }\n    return (\n      <Form state={this.props.state} setField={this.props.setField}>\n        <Title>GIF export options</Title>\n        <br/>\n        <Checkbox name='borders' label='Include borders' />\n        <br/>\n        <label>Gif anim mode:</label>\n        <br/>\n        <br/>\n        <RadioButton\n          name='animMode'\n          value='single'\n          label='Current screen only'\n        />\n        <RadioButton\n          name='animMode'\n          value='anim'\n          label='Export .gif anim'\n        />\n        <br/>\n        {this.props.state.animMode === 'single' ? null : animControls()}\n      </Form>\n    )\n  }\n}\n\ninterface PNGExportFormatProps extends ExportPropsBase {\n  state: FileFormatPng['exportOptions'];\n}\n\nclass PNGExportForm extends Component<PNGExportFormatProps> {\n  render () {\n    return (\n      <Form state={this.props.state} setField={this.props.setField}>\n        <Title>PNG export options</Title>\n        <br/>\n        <br/>\n        <Checkbox name='alphaPixel' label='Alpha pixel work-around for Twitter' />\n        <Checkbox name='borders' label='Include borders' />\n        <NumberInput name='scale' label='Pixel scale' />\n      </Form>\n    )\n  }\n}\n\ninterface SEQExportFormatProps extends ExportPropsBase {\n  state: FileFormatSeq['exportOptions'];\n}\n\nclass SEQExportForm extends Component<SEQExportFormatProps> {\n  render () {\n    return (\n      <Form state={this.props.state} setField={this.props.setField}>\n        <Title>SEQ export options</Title>\n        <br/>\n        <br/>\n        <Checkbox name='insCR' label='Append Carriage Returns at end of rows'/><span></span>\n        <Checkbox name='insClear' label='Insert CLS (0x93) at start of file' />\n        <Checkbox name='insCharset' label='Insert font: (0x0E) lower charset or (0x8E) upper charset' />\n\n        <br/>\n        <Checkbox name='stripBlanks' label='Optimize sequence' />\n      </Form>\n    )\n  }\n}\n\n\ninterface ASMExportFormatProps extends ExportPropsBase {\n  state: FileFormatAsm['exportOptions'];\n}\n\nclass ASMExportForm extends Component<ASMExportFormatProps> {\n  render () {\n    return (\n      <Form state={this.props.state} setField={this.props.setField}>\n        <Title>Assembler export options</Title>\n        <br/>\n        <br/>\n        <RadioButton\n          name='assembler'\n          value='kickass'\n          label='KickAssembler'\n        />\n        <RadioButton\n          name='assembler'\n          value='acme'\n          label='ACME'\n        />\n        <RadioButton\n          name='assembler'\n          value='c64tass'\n          label='64tass'\n        />\n        <RadioButton\n          name='assembler'\n          value='ca65'\n          label='ca65'\n        />\n        <RadioButton\n          name='assembler'\n          value='c64jasm'\n          label='c64jasm'\n        />\n        <br/>\n        <Checkbox\n          name='currentScreenOnly'\n          label='Current screen only'\n        />\n        <Checkbox\n          name='standalone'\n          label='Make output compilable to a .prg'\n        />\n        <Checkbox\n          name='hex'\n          label='Hexadecimal output'\n        />\n      </Form>\n    )\n  }\n}\n\ninterface BASICExportFormatProps extends ExportPropsBase {\n  state: FileFormatBas['exportOptions'];\n}\n\nclass BASICExportForm extends Component<BASICExportFormatProps> {\n  render () {\n    return (\n      <Form state={this.props.state} setField={this.props.setField}>\n        <Title>BASIC export options</Title>\n        <br/>\n        <br/>\n        <Checkbox\n          name='currentScreenOnly'\n          label='Current screen only'\n        />\n        <Checkbox\n          name='standalone'\n          label='Add BASIC code to display the image'\n        />\n      </Form>\n    )\n  }\n}\n\ninterface JsonExportFormatProps extends ExportPropsBase {\n  state: FileFormatJson['exportOptions'];\n}\n\nclass JsonExportForm extends Component<JsonExportFormatProps> {\n  render () {\n    return (\n      <Form state={this.props.state} setField={this.props.setField}>\n        <Title>JSON export options</Title>\n        <br/>\n        <br/>\n        <Checkbox\n          name='currentScreenOnly'\n          label='Current screen only'\n        />\n      </Form>\n    )\n  }\n}\n\ninterface D64ExportFormatProps extends ExportPropsBase {\n  state: FileFormatD64['exportOptions'];\n}\n\nclass D64ExportForm extends Component<D64ExportFormatProps> {\n  render () {\n\n    return (\n      <Form state={this.props.state} setField={this.props.setField}>\n        <br/>\n        <Title>D64 export options</Title>\n        <br/>\n\n        C64 Disks have a 16 character header and 5 character (max) ID. The ID is often '2A' which is\n        a marker for standard commodore disk format. For maximum compatibility use '2A'.\n        <br/>\n        <br/>\n      <div style={{display: \"flex\",flexDirection: \"row\"}}>\n        <TextInput name=\"header\" label='Header' style={{minWidth: '12em'}} inputprops={{width:16,size:16,maxLength:16, placeholder:\"1234567890ABCDEF\"}} />\n        <TextInput name=\"id\" label='ID' style={{minWidth: '4em'}} inputprops={{size:5,maxLength:5, placeholder:\"2A\"}} />\n        </div>\n        <br/>\n        Use UPPERCASE letters for regular text in the header and ID.\n        <br/>\n\n\n      </Form>\n    )\n  }\n}\n//--------------------\n\n\ninterface PrgPlayerExportFormatProps extends ExportPropsBase {\n  state: FileFormatPlayerV1['exportOptions'];\n}\n\nclass PrgPlayerExportForm extends Component<PrgPlayerExportFormatProps> {\n\n\n  handleImportMusic = () => {\n\nconst filename = dialogPickSidFile();\nthis.props.setField('songFile',filename)\n\n}\n\n\n  handleNewType = () => {\n\n\n\n\n\n\n    if(!this.props.state.currentScreenOnly)\n    {\n    this.props.setField('playerType','Single Frame')\n    }\n    else\n    {\n    this.props.setField('playerType','Animation')\n\n    }\n    this.props.setField('currentScreenOnly',!this.props.state.currentScreenOnly)\n    console.log(this.props.state)\n  }\n\n\n  render () {\n\n   // this.handleNewType();\n    const musicControls = () => {\n      return (\n        <Fragment>\n            <div className={styles.settingsPanel}>\n\n<div className={styles.settingsSubPanel} style={{width:'75%'}}>\n<NumberInput name='songNumber' label=\"Song:\" style={{display:\"inlineBlock\",flex:\"1 1 1\",padding:\"2\",margin:\"0px 0px 0px 10px\",border:\"1px solid white\",width:\"10px\"}} min=\"1\" max=\"1\" width=\"1\" />\n<span className={styles.spanMusicFileName}>\n  {this.props.state.songFile!='' ? this.props.state.songFile:'No file selected...'}\n\n  </span>\n\n</div>\n<div className={styles.settingsSubPanel} style={{width:'25%'}}>\n<button className={styles.buttonMusicAdd} onClick={this.handleImportMusic}>Pick Music</button>\n</div>\n</div>\n\n        </Fragment>\n    )}\n\n    const FramePlayerTypes = (isSingle:boolean) => {\n      if(isSingle)\n      {\n\n      return (\n        <Fragment>\n        <RadioButton name='playerType' value='Single Frame' label='Single Frame' />\n\n        </Fragment>\n    )}\n    else\n    {\n\n\n\n      return (\n        <Fragment>\n     <RadioButton name='playerType' value='Animation' label='Animation' />\n        </Fragment>\n    )\n    }\n  }\n\n\n    return (\n      <Form state={this.props.state} setField={this.props.setField}>\n        <Title>Petmate PRG Player v1.00</Title>\n\n        <Checkbox name='currentScreenOnly' label='Current screen only' onChange={this.handleNewType} />\n\n        <Checkbox name='music' label='Add a SID/Music' />\n\n        {this.props.state.music ? musicControls():''}\n\n        <div className={styles.settingsPanel}>\n\n\n\n\n        <div className={styles.settingsSubPanel}>\n        <label className={styles.settingsSubLabel}>Computer</label>\n        <RadioButton name='computer' value='c64' label='C64' />\n        <RadioButton name='computer' value='pet4032' label='Pet 4032' />\n        <RadioButton name='computer' value='c128' label='C128' />\n        <RadioButton name='computer' value='c16' label='C16' />\n        <RadioButton name='computer' value='vic20' label='Vic 20' />\n        </div>\n\n\n        <div className={styles.settingsSubPanel}>\n        <label className={styles.settingsSubLabel}>Player Type</label>\n\n\n        {FramePlayerTypes(this.props.state.currentScreenOnly)}\n\n\n        </div>\n\n        <div className={styles.settingsSubPanel}>\n        <label className={styles.settingsSubLabel}>Other&nbsp;Settings</label>\n\n        </div>\n\n\n</div>\n<div className={styles.settingsPanel}>\n<div className={styles.settingsSubPanel}></div><div className={styles.settingsSubPanel}></div>\n</div>\n      </Form>\n    )\n  }\n}\n\n\n\n\n\ninterface ExportModalState {\n  [key: string]: FileFormat['exportOptions'];\n  seqFile: FileFormatSeq['exportOptions'];\n  pngFile: FileFormatPng['exportOptions'];\n  asmFile: FileFormatAsm['exportOptions'];\n  basFile: FileFormatBas['exportOptions'];\n  gifFile: FileFormatGif['exportOptions'];\n  jsonFile: FileFormatJson['exportOptions'];\n  d64File: FileFormatD64['exportOptions'];\n\n}\n\n// Type to select one format branch from ExportModalState\ntype State<T extends keyof ExportModalState> = {\n  state: ExportModalState[T];\n  setState: any; // TODO ts\n}\n\nexport function connectFormStateTyped<T extends FileFormat['name']>({state, setState}: State<T>, subtree: T) {\n  return connectFormState({state, setState}, subtree);\n}\n\ninterface ExportFormProps {\n  ext: string | null;\n  name: string;\n  description: string | null;\n  state: ExportModalState;\n  setState: any;\n}\n\nclass ExportForm extends Component<ExportFormProps> {\n  render () {\n  //  if (this.props.name === null) {\n  //    return null\n  //  }\n    if (!utils.formats[this.props.name].exportOptions) {\n      return null\n    }\n    switch (this.props.name) {\n\n      case 'cFile':\n        return null\n        case 'd64File':\n          return (\n            <D64ExportForm {...connectFormState(this.props, 'd64File')} />)\n      case 'prgFile':\n        return null\n      case 'pngFile':\n        return (\n          <PNGExportForm {...connectFormState(this.props, 'pngFile')} />\n        )\n      case 'seqFile':\n        return (\n          <SEQExportForm {...connectFormState(this.props, 'seqFile')} />\n        )\n      case 'asmFile':\n        return (\n          <ASMExportForm {...connectFormState(this.props, 'asmFile')} />\n        )\n      case 'basFile':\n        return (\n          <BASICExportForm {...connectFormState(this.props, 'basFile')} />\n        )\n      case 'gifFile':\n        return (\n          <GIFExportForm {...connectFormState(this.props, 'gifFile')} />\n        )\n      case 'jsonFile':\n        return (\n          <JsonExportForm {...connectFormState(this.props, 'jsonFile')} />\n        )\n        case 'prgPlayer':\n          return (\n            <PrgPlayerExportForm {...connectFormState(this.props, 'prgPlayer')} />\n          )\n      default:\n        throw new Error(`unknown export format ${this.props.name}`);\n    }\n  }\n}\n\ninterface ExportModalProps {\n  showExport: {\n    show: boolean;\n    fmt?: FileFormat; // undefined if show=false\n  };\n};\n\ninterface ExportModalDispatch {\n  Toolbar: toolbar.PropsFromDispatch;\n  fileExportAs: (fmt: FileFormat) => void;\n}\n\nclass ExportModal_ extends Component<ExportModalProps & ExportModalDispatch, ExportModalState> {\n  state: ExportModalState = {\n    seqFile: {\n      insCR: false,\n      insClear: true,\n      stripBlanks: false,\n      insCharset:false,\n    },\n    pngFile: {\n      borders: true,\n      alphaPixel: false,\n      scale: 1,\n    },\n    asmFile: {\n      assembler: 'kickass',\n      currentScreenOnly: true,\n      hex: false,\n      standalone: false\n    },\n    basFile: {\n      currentScreenOnly: true,\n      standalone: false\n    },\n    gifFile: {\n      borders: true,\n      animMode: 'single',\n      loopMode: 'loop',\n      delayMS: '250'\n    },\n    jsonFile: {\n      currentScreenOnly: true\n    },\n    d64File: {\n      header: \"ENTER D64 NAME\",\n      id: \"2A\"\n    },\n    prgPlayer: {\n        currentScreenOnly: true,\n        music: false,\n        songFile: '',\n        songNumber: 1,\n        playerDebug: true,\n        playerType: 'Single Frame',\n        playerAnimationDirection: 'Forward',\n        playerAnimationLoop: true,\n        playerSpeed: 1,\n        playerScrollType: 'Linear',\n        computer: 'c64' ,\n\n\n    },\n  }\n\n  handleOK = () => {\n    const { showExport } = this.props;\n    this.props.Toolbar.setShowExport({show:false});\n    const fmt = showExport.fmt!;\n    const name = fmt.name;\n    if (fmt.exportOptions == undefined) {\n      // We shouldn't be here if there are no export UI options\n      return;\n    }\n    const amendedFmt = {\n      ...showExport.fmt,\n      exportOptions: {\n        ...this.state[name]\n      }\n    };\n    this.props.fileExportAs(amendedFmt as FileFormat);\n  }\n\n  handleCancel = () => {\n    this.props.Toolbar.setShowExport({show:false})\n  }\n\n  handleSetState = (cb: (s: ExportModalState) => void) => {\n    this.setState(prevState => {\n      return cb(prevState)\n    })\n  }\n\n  render () {\n    const { showExport } = this.props\n    const exportType = showExport.show ? showExport.fmt : undefined\n    const exportExt = exportType !== undefined ? exportType.ext : null\n    const fmt = showExport.fmt!;\n    const exportName = exportType !== undefined ? fmt.name:''\n    const exportDescription = exportType !== undefined ? fmt.description:null;\n    return (\n      <div>\n        <Modal showModal={this.props.showExport.show}>\n          <div style={{\n            display: 'flex',\n            height: '100%',\n            flexDirection: 'column',\n            justifyContent: 'space-between'\n          }}>\n            <div>\n              <ModalTitle>Export Options</ModalTitle>\n              <ExportForm\n                ext={exportExt}\n                name={exportName}\n                description={exportDescription}\n                state={this.state}\n                setState={this.handleSetState}\n\n              />\n            </div>\n\n            <div style={{alignSelf: 'flex-end'}}>\n              <button className='cancel' onClick={this.handleCancel}>Cancel</button>\n              <button className='primary' onClick={this.handleOK}>Export</button>\n            </div>\n          </div>\n\n        </Modal>\n      </div>\n    )\n  }\n}\n\nexport default connect(\n  (state: RootState) => {\n    return {\n      showExport: state.toolbar.showExport\n    }\n  },\n  (dispatch) => {\n    return {\n      Toolbar: bindActionCreators(toolbar.Toolbar.actions, dispatch),\n      fileExportAs: bindActionCreators(ReduxRoot.actions.fileExportAs, dispatch)\n    }\n  }\n)(ExportModal_)\n","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\containers\\FileDrop.tsx",["343"],"\nimport React, {\n  Component,\n  Fragment,\n  DragEvent\n} from 'react';\n\ninterface FileDropProps {\n  className: string;\n  loadDroppedFile: (filename: string) => void;\n};\n\ninterface FileDropState {\n  isDragging: boolean;\n};\n\nclass FlashScreen extends Component {\n  render () {\n    return (\n      <div\n        draggable={false}\n        style={{\n          pointerEvents: 'none',\n          position: 'absolute',\n          left: 0,\n          top: 0,\n          width: '100%',\n          height: '100%',\n          zIndex: 30,\n          backgroundColor: 'rgb(0, 0, 0)',\n          opacity: 0.8\n        }}>\n      </div>\n    )\n  }\n}\n\nexport default class FileDrop extends Component<FileDropProps, FileDropState> {\n  state = {\n    isDragging: false\n  };\n\n  dragCounter = 0;\n\n  static hasFiles = (e: DragEvent) => {\n    const types = e.dataTransfer.types;\n    return types && types.indexOf('Files') != -1;\n  }\n\n  resetDragging = () => {\n    this.setState({ isDragging: false });\n    this.dragCounter = 0;\n  }\n\n  handleTreeDrag = (event: DragEvent) => {\n    if (!FileDrop.hasFiles(event)) {\n      return;\n    }\n\n    // Drag counter trick from https://github.com/sarink/react-file-drop/blob/master/src/FileDrop/FileDrop.tsx\n    // Keep track of enter/leaves bubbling.\n    this.dragCounter += (event.type === 'dragenter' ? 1 : -1);\n\n    if (this.dragCounter == 1) {\n      this.setState({ isDragging: true });\n      return;\n    }\n\n    if (this.dragCounter == 0) {\n      this.setState({ isDragging: false });\n      return;\n    }\n  }\n\n  handleDragOver = (event: DragEvent) => {\n    event.preventDefault();\n  }\n\n  handleFileDrop = (event: DragEvent) => {\n    if (FileDrop.hasFiles(event)) {\n      this.resetDragging();\n\n      const files = event.dataTransfer.files;\n      if (files.length == 1) {\n        const file0 = files[0] as any;\n        this.props.loadDroppedFile(file0.path);\n      }\n    }\n  }\n\n  render () {\n    return (\n      <Fragment>\n        <div\n          draggable={false}\n          onDragEnter={this.handleTreeDrag}\n          onDragLeave={this.handleTreeDrag}\n          onDragOver={this.handleDragOver}\n          onDrop={this.handleFileDrop}\n          className={this.props.className}\n        >\n          {this.props.children}\n        </div>\n        {this.state.isDragging && <FlashScreen />}\n      </Fragment>\n    )\n  }\n}","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\containers\\CustomFontsModal.tsx",[],"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\containers\\Editor.tsx",["344"],"// @ts-ignore\nimport React, {\n  Component,\n  Fragment,\n  CSSProperties,\n  PointerEvent,\n  WheelEvent,\n} from \"react\";\nimport { connect } from \"react-redux\";\nimport classNames from \"classnames\";\n\nimport ColorPicker from \"../components/ColorPicker\";\nimport CharGrid from \"../components/CharGrid\";\nimport CharPosOverlay, {\n  TextCursorOverlay,\n} from \"../components/CharPosOverlay\";\nimport GridOverlay from \"../components/GridOverlay\";\nimport { CanvasStatusbar } from \"../components/Statusbar\";\n\n//import Resize from \"../components/Resize\"\n\nimport CharSelect from \"./CharSelect\";\n\nimport * as framebuf from \"../redux/editor\";\nimport { Framebuffer } from \"../redux/editor\";\nimport * as selectors from \"../redux/selectors\";\nimport * as screensSelectors from \"../redux/screensSelectors\";\nimport {\n  getSettingsPaletteRemap,\n  getSettingsCurrentColorPalette,\n  getSettingsIntegerScale,\n} from \"../redux/settingsSelectors\";\n\nimport { framebufIndexMergeProps } from \"../redux/utils\";\n\nimport * as toolbar from \"../redux/toolbar\";\nimport { Toolbar } from \"../redux/toolbar\";\nimport * as utils from \"../utils\";\nimport * as matrix from \"../utils/matrix\";\n\nimport styles from \"./Editor.module.css\";\nimport {\n  RootState,\n  BrushRegion,\n  BrushType,\n  Coord2,\n  Rgb,\n  Brush,\n  Font,\n  Tool,\n  Pixel,\n  Framebuf,\n  FramebufUIState,\n  Zoom,\n} from \"../redux/types\";\nimport ShaderSelector from \"../components/ShaderSelector\";\nimport GuideLayerAdjustment from \"../components/GuideLayerAdjustment\";\nimport DirArtClips from \"../components/DirartClips\";\nimport TexturePanel from \"../components/TexturePanel\";\nimport { framebufToPixels } from \"../utils/exporters/util\";\n\n//import Root from \"./Root\";\n\nlet brushOutlineSelectingColor = \"rgba(128, 255, 128, 0.5)\";\n\n\n\nconst gridColor = \"rgba(128, 128, 128, 1)\";\n\nvar x = setInterval(function() {\n  let selectedBrushID = document.getElementById(\"selectedBrushID\")\n  if(selectedBrushID!==null)\n  {\n    if(selectedBrushID.style.outlineColor==\"rgba(128, 255, 128, 0.5)\")\n    {\n    selectedBrushID.style.outlineColor=\"rgba(128, 255, 128, 0.51)\";\n    selectedBrushID.style.outlineStyle = \"dashed\";\n    selectedBrushID.style.outlineWidth = \"2\";\n    }\n    else\n    {\n    selectedBrushID.style.outlineColor=\"rgba(128, 255, 128, 0.5)\";\n    selectedBrushID.style.outlineStyle = \"dotted\";\n    selectedBrushID.style.outlineWidth = \"2\";\n\n    }\n  }\n\n},128)\n\nconst brushOverlayStyleBase: CSSProperties = {\n  outlineColor: \"rgba(255, 255, 255, 0.5)\",\n  outlineStyle: \"dashed\",\n  outlineOffset: \"0\",\n  outlineWidth: 2,\n  backgroundColor: \"rgba(255,255,255,0)\",\n  zIndex: 1,\n  pointerEvents: \"none\",\n  opacity:\".75\"\n};\n\ninterface BrushSelectOverlayProps {\n  framebufWidth: number;\n  framebufHeight: number;\n  brushRegion: BrushRegion | null;\n  charPos: Coord2;\n  borderOn: boolean;\n}\n\nclass BrushSelectOverlay extends Component<BrushSelectOverlayProps> {\n  render() {\n    if (this.props.brushRegion === null) {\n      return (\n        <CharPosOverlay\n          charPos={this.props.charPos}\n          framebufWidth={this.props.framebufWidth}\n          framebufHeight={this.props.framebufHeight}\n          color={brushOutlineSelectingColor}\n          borderOn={this.props.borderOn}\n        />\n      );\n    }\n    const { min, max } = utils.sortRegion(this.props.brushRegion);\n    const s: CSSProperties = {\n      ...brushOverlayStyleBase,\n      outlineColor: brushOutlineSelectingColor,\n      position: \"absolute\",\n      left: (min.col + Number(this.props.borderOn) * 4) * 8,\n      top: (min.row + Number(this.props.borderOn) * 4) * 8,\n      width: `${(max.col - min.col + 1) * 8}px`,\n      height: `${(max.row - min.row + 1) * 8}px`,\n    };\n    return <div id=\"brush\" style={s}></div>;\n  }\n}\n\nfunction computeBrushDstPos(\n  charPos: Coord2,\n  dims: { width: number; height: number }\n) {\n  return {\n    col: charPos.col - Math.floor(dims.width / 2),\n    row: charPos.row - Math.floor(dims.height / 2),\n  };\n}\n\ninterface BrushOverlayProps {\n  charPos: Coord2;\n  framebufWidth: number;\n  framebufHeight: number;\n  backgroundColor: string;\n  colorPalette: Rgb[];\n  brush: Brush | null;\n  font: Font;\n  borderOn: boolean;\n}\n\nclass BrushOverlay extends Component<BrushOverlayProps> {\n  render() {\n    if (this.props.brush === null) {\n      return null;\n    }\n    const { charPos, backgroundColor, framebufWidth, framebufHeight } =\n      this.props;\n    const { min, max } = utils.sortRegion(this.props.brush.brushRegion);\n    const brushw = max.col - min.col + 1;\n    const brushh = max.row - min.row + 1;\n    let bw = brushw;\n    let bh = brushh;\n    const destPos = computeBrushDstPos(charPos, { width: bw, height: bh });\n    let dstx = destPos.col;\n    let dsty = destPos.row;\n    if (bw + dstx > framebufWidth) {\n      bw = framebufWidth - dstx;\n    }\n    if (bh + dsty > framebufHeight) {\n      bh = framebufHeight - dsty;\n    }\n    let srcX = 0;\n    let srcY = 0;\n    if (dstx < 0) {\n      srcX = -dstx;\n      bw -= srcX;\n      dstx = 0;\n    }\n    if (dsty < 0) {\n      srcY = -dsty;\n      bh -= srcY;\n      dsty = 0;\n    }\n    if (bw <= 0 || bh <= 0) {\n      return null;\n    }\n    const s: CSSProperties = {\n      ...brushOverlayStyleBase,\n\n      position: \"absolute\",\n      left: (dstx + Number(this.props.borderOn) * 4) * 8,\n      top: (dsty + Number(this.props.borderOn) * 4) * 8,\n      width: `${bw * 8}px`,\n      height: `${bh * 8}px`,\n    };\n\n    return (\n      <div id=\"selectedBrushID\" style={s}>\n        <CharGrid\n          width={bw}\n          height={bh}\n          srcX={srcX}\n          srcY={srcY}\n          grid={false}\n          backgroundColor={backgroundColor}\n          colorPalette={this.props.colorPalette}\n          font={this.props.font}\n          framebuf={this.props.brush.framebuf}\n          borderOn={this.props.borderOn}\n          isTransparent={true}\n\n\n          />\n      </div>\n    );\n  }\n}\n\ninterface FramebufferViewProps {\n  undoId: number | null;\n\n  altKey: boolean;\n  ctrlKey: boolean;\n  shiftKey: boolean;\n  spacebarKey: boolean;\n\n  textCursorPos: Coord2;\n\n  framebuf: Pixel[][];\n  framebufWidth: number;\n  framebufHeight: number;\n  selectedTool: Tool;\n  brush: Brush | null;\n  brushRegion: BrushRegion | null;\n  // Scale and translation for pan/zoom\n  framebufUIState: FramebufUIState;\n  backgroundColor: number;\n  borderColor: number;\n  borderOn: boolean;\n  textColor: number;\n  curScreencode: number;\n  colorPalette: Rgb[];\n  zoom: Zoom;\n  font: Font;\n  zoomReady: boolean;\n  canvasGrid: boolean;\n  isDirart:boolean;\n\n  onCharPosChanged: (args: { isActive: boolean; charPos: Coord2 }) => void;\n\n  framebufLayout: {\n    width: number;\n    height: number;\n    pixelScale: number;\n  };\n}\n\ninterface FramebufferViewDispatch {\n  Framebuffer: framebuf.PropsFromDispatch;\n  Toolbar: toolbar.PropsFromDispatch;\n}\n\ninterface FramebufferViewState {\n  // Floor'd to int\n  charPos: Coord2;\n  isActive: boolean;\n}\n\nclass FramebufferView extends Component<\n  FramebufferViewProps & FramebufferViewDispatch,\n  FramebufferViewState\n> {\n  state: FramebufferViewState = {\n    charPos: { row: -1, col: 0 },\n    isActive: false,\n  };\n\n  prevDragPos: Coord2 | null = null;\n\n  setBlankChar = (clickLoc: Coord2) => {\n    const { undoId } = this.props;\n    const params = {\n      ...clickLoc,\n    };\n    if (this.props.selectedTool === Tool.Draw) {\n      this.props.Framebuffer.setPixel(\n        {\n          ...params,\n          color: this.props.textColor,\n          screencode: 32,\n        },\n        undoId\n      );\n    } else if (this.props.selectedTool === Tool.Colorize) {\n      this.props.Framebuffer.setPixel(\n        {\n          ...params,\n          color: this.props.textColor,\n        },\n        undoId\n      );\n    } else if (this.props.selectedTool === Tool.CharDraw) {\n      this.props.Framebuffer.setPixel(\n        {\n          ...params,\n          screencode: 32,\n        },\n        undoId\n      );\n    } else {\n      console.error(\"shouldn't get here\");\n    }\n  };\n  setTransparentChar = (clickLoc: Coord2) => {\n    const { undoId } = this.props;\n    const params = {\n      ...clickLoc,\n    };\n    if (this.props.selectedTool === Tool.Draw) {\n      this.props.Framebuffer.setPixel(\n        {\n          ...params,\n          color: this.props.textColor,\n          screencode: 256,\n        },\n        undoId\n      );\n    } else if (this.props.selectedTool === Tool.Colorize) {\n      this.props.Framebuffer.setPixel(\n        {\n          ...params,\n          color: this.props.textColor,\n        },\n        undoId\n      );\n    } else if (this.props.selectedTool === Tool.CharDraw) {\n      this.props.Framebuffer.setPixel(\n        {\n          ...params,\n          screencode: 256,\n        },\n        undoId\n      );\n    } else {\n      console.error(\"shouldn't get here\");\n    }\n  };\n\n  setChar = (clickLoc: Coord2) => {\n    const { undoId } = this.props;\n    const params = {\n      ...clickLoc,\n    };\n    if (this.props.selectedTool === Tool.Draw) {\n      this.props.Framebuffer.setPixel(\n        {\n          ...params,\n          color: this.props.textColor,\n          screencode: this.props.curScreencode,\n        },\n        undoId\n      );\n    } else if (this.props.selectedTool === Tool.Colorize) {\n      this.props.Framebuffer.setPixel(\n        {\n          ...params,\n          color: this.props.textColor,\n        },\n        undoId\n      );\n    } else if (this.props.selectedTool === Tool.CharDraw) {\n      this.props.Framebuffer.setPixel(\n        {\n          ...params,\n          screencode: this.props.curScreencode,\n        },\n        undoId\n      );\n    } else {\n      console.error(\"shouldn't get here\");\n    }\n  };\n\n  brushDraw = (coord: Coord2) => {\n    const { min, max } = this.props.brush.brushRegion;\n    const area = {\n      width: max.col - min.col + 1,\n      height: max.row - min.row + 1,\n    };\n    const destPos = computeBrushDstPos(coord, area);\n\n    let btype = BrushType.CharsColors;\n    //BrushType\n\n\n    if (this.props.ctrlKey) {\n      btype = BrushType.CharsOnly;\n    } else if (this.props.altKey) {\n      btype = BrushType.ColorsOnly;\n    }\n\n\n    if (this.props.altKey && this.props.ctrlKey) {\n      btype = BrushType.Raw;\n    }\n\n    if (this.rightButton) {\n      btype = BrushType.ColorStamp;\n    }\n\n    this.props.Framebuffer.setBrush(\n      {\n        ...destPos,\n        brushType: btype,\n        brush: this.props.brush,\n        brushColor: this.props.textColor,\n      },\n      this.props.undoId\n    );\n  };\n\n  dragStart = (coord: Coord2) => {\n    const { selectedTool } = this.props;\n    if (\n      selectedTool === Tool.Draw ||\n      selectedTool === Tool.Colorize ||\n      selectedTool === Tool.CharDraw\n    ) {\n      if (!this.rightButton) {\n        this.setChar(coord);\n      } else {\n        if (this.props.ctrlKey) {\n          this.setTransparentChar(coord);\n        } else {\n          this.setBlankChar(coord);\n        }\n      }\n    } else if (selectedTool === Tool.FloodFill) {\n      this.SetFloodFill(coord, this.rightButton);\n    } else if (selectedTool === Tool.Brush) {\n\n      if (this.props.brush === null) {\n        this.props.Toolbar.setBrushRegion({\n          min: coord,\n          max: coord,\n        });\n      } else {\n        this.brushDraw(coord);\n      }\n\n    } else if (selectedTool === Tool.Text) {\n      this.props.Toolbar.setTextCursorPos(coord);\n    }\n    this.prevDragPos = coord;\n  };\n\n  dragMove = (coord: Coord2) => {\n    const prevDragPos = this.prevDragPos!; // set in dragStart\n    const { selectedTool, brush, brushRegion } = this.props;\n    if (\n      selectedTool === Tool.Draw ||\n      selectedTool === Tool.Colorize ||\n      selectedTool === Tool.CharDraw\n    ) {\n      utils.drawLine(\n        (x, y) => {\n          //this.setChar({ row: y, col: x });\n\n          if (!this.rightButton) {\n            this.setChar({ row: y, col: x });\n          } else {\n            if (this.props.ctrlKey) {\n              this.setTransparentChar({ row: y, col: x });\n            } else {\n              this.setBlankChar({ row: y, col: x });\n            }\n          }\n        },\n        prevDragPos.col,\n        prevDragPos.row,\n        coord.col,\n        coord.row\n      );\n    } else if (selectedTool === Tool.Brush) {\n\n      if (brush !== null) {\n        this.brushDraw(coord);\n      } else if (brushRegion !== null) {\n        const clamped = {\n          row: Math.max(0, Math.min(coord.row, this.props.framebufHeight - 1)),\n          col: Math.max(0, Math.min(coord.col, this.props.framebufWidth - 1)),\n        };\n        this.props.Toolbar.setBrushRegion({\n          ...brushRegion,\n          max: clamped,\n        });\n      }\n\n    } else if (selectedTool === Tool.FloodFill) {\n      //FloodFill here\n      this.SetFloodFill(coord, this.rightButton);\n    } else {\n      console.error(\"not implemented\");\n    }\n\n    this.prevDragPos = coord;\n  };\n\n  dragEnd = () => {\n    const { selectedTool, brush, brushRegion } = this.props;\n    if (selectedTool === Tool.Brush) {\n      if (brush === null && brushRegion !== null) {\n        this.props.Toolbar.captureBrush(this.props.framebuf, brushRegion);\n      }\n    }\n    this.props.Toolbar.incUndoId();\n  };\n\n  altClick = (charPos: Coord2) => {\n    const x = charPos.col;\n    const y = charPos.row;\n    if (\n      y >= 0 &&\n      y < this.props.framebufHeight &&\n      x >= 0 &&\n      x < this.props.framebufWidth\n    ) {\n      const pix = this.props.framebuf[y][x];\n      this.props.Toolbar.setCurrentScreencodeAndColor(pix);\n    }\n  };\n\n  ctrlClick = (charPos: Coord2) => {\n\n    const x = charPos.col;\n    const y = charPos.row;\n    if (\n      y >= 0 &&\n      y < this.props.framebufHeight &&\n      x >= 0 &&\n      x < this.props.framebufWidth\n    ) {\n      const pix = this.props.framebuf[y][x];\n      //this.props.Toolbar.setCurrentScreencodeAndColor(pix);\n      this.props.Toolbar.setColor(pix.color);\n    }\n  };\n\n  rightClick = (charPos: Coord2) => {\n    const x = charPos.col;\n    const y = charPos.row;\n    if (\n      y >= 0 &&\n      y < this.props.framebufHeight &&\n      x >= 0 &&\n      x < this.props.framebufWidth\n    ) {\n      if (this.props.ctrlKey) {\n        this.setTransparentChar(charPos);\n      } else {\n        this.setBlankChar(charPos);\n      }\n    }\n  };\n\n\n  middleClick = (coord: Coord2) => {\n    const prevDragPos = this.prevDragPos!; // set in dragStart\n    const { selectedTool, brush, brushRegion } = this.props;\n    if (\n      selectedTool === Tool.Draw ||\n      selectedTool === Tool.Colorize ||\n      selectedTool === Tool.CharDraw\n    ) {\n      utils.drawLine(\n        (x, y) => {\n          //this.setChar({ row: y, col: x });\n\n          if (!this.rightButton) {\n            this.setChar({ row: y, col: x });\n          } else {\n            if (this.props.ctrlKey) {\n              this.setTransparentChar({ row: y, col: x });\n            } else {\n              this.setBlankChar({ row: y, col: x });\n            }\n          }\n        },\n        prevDragPos.col,\n        prevDragPos.row,\n        coord.col,\n        coord.row\n      );\n    } else if (selectedTool === Tool.Brush) {\n\n      if (brush !== null) {\n        this.brushDraw(coord);\n      } else if (brushRegion !== null) {\n        const clamped = {\n          row: Math.max(0, Math.min(coord.row, this.props.framebufHeight - 1)),\n          col: Math.max(0, Math.min(coord.col, this.props.framebufWidth - 1)),\n        };\n        this.props.Toolbar.setBrushRegion({\n          ...brushRegion,\n          max: clamped,\n        });\n      }\n\n    } else if (selectedTool === Tool.FloodFill) {\n      //FloodFill here\n      this.SetFloodFill(coord, this.rightButton);\n    } else {\n      console.error(\"not implemented\");\n    }\n\n    this.prevDragPos = coord;\n  };\n\n\n  // Returns true if specified row and col coordinates are in the matrix\n  validCoordinates = (coords: Coord2) => {\n    const x = coords.col;\n    const y = coords.row;\n    return (\n      y >= 0 &&\n      y < this.props.framebufHeight &&\n      x >= 0 &&\n      x < this.props.framebufWidth\n    );\n  };\n\n  validFloodCoordinates = (\n    coords: Coord2,\n    sourceCode: number,\n    sourceColor: number\n  ) => {\n    return (\n      this.validCoordinates(coords) &&\n      this.props.framebuf[coords.row][coords.col].code === sourceCode &&\n      this.props.framebuf[coords.row][coords.col].color === sourceColor\n    );\n  };\n\n  SetColorReplace=(oldColor:number,newColor:number)=>{\n    for(let y=0;y<this.props.framebufHeight;y++)\n    {\n      for(let x=0;x<this.props.framebufWidth;x++)\n      {\n        if(this.props.framebuf[y][x].color==oldColor)\n        this.props.framebuf[y][x].color=newColor\n      }\n    }\n  }\n\n  SetFloodFill = (startLoc: Coord2,isRightClick:boolean) => {\n    const { undoId } = this.props;\n    let Filled = [] as Coord2[];\n\n    if (this.validCoordinates(startLoc)) {\n      let floodQueue = [] as Coord2[];\n      floodQueue.push(startLoc);\n\n      //Get the colour and char at the initial click location\n\n\n      let sourceCode = this.props.framebuf[startLoc.row][startLoc.col].code;\n      const sourceColor = this.props.framebuf[startLoc.row][startLoc.col].color;\n\n      const destColor = this.props.textColor;\n      let destCode = this.props.curScreencode;\n\n\n      if (!isRightClick) {\n\n      } else {\n        if (this.props.ctrlKey) {\n          destCode = 256;\n\n        } else {\n          destCode = 32;\n\n        }\n      }\n\n\n\n      while (floodQueue.length > 0) {\n        const lastQItem = floodQueue.pop() as Coord2;\n\n        this.props.Framebuffer.setPixel(\n          {\n            ...{ row: lastQItem.row, col: lastQItem.col },\n            color: destColor,\n            screencode: destCode,\n          },\n          undoId\n        );\n\n        const row = lastQItem.row;\n        const col = lastQItem.col;\n        Filled.push(lastQItem);\n\n        const expand = [\n          { col: col, row: row + 1 },\n          { col: col, row: row - 1 },\n          { col: col + 1, row: row },\n          { col: col - 1, row: row },\n        ] as Coord2[];\n\n        expand.forEach((xcoords) => {\n          if (this.validFloodCoordinates(xcoords, sourceCode, sourceColor)) {\n            const existsInQueue = Filled.find(\n              (qcoord) =>\n                qcoord.row === xcoords.row && qcoord.col === xcoords.col\n            );\n            if (existsInQueue == undefined) floodQueue.push(xcoords);\n          }\n        });\n\n\n      }\n    }\n  };\n\n  //---------------------------------------------------------------------\n  // Mechanics of tracking pointer drags with mouse coordinate -> canvas char pos\n  // transformation.\n\n  private ref = React.createRef<HTMLDivElement>();\n  private prevCharPos: Coord2 | null = null;\n  private prevCoord: Coord2 | null = null;\n  private lockStartCoord: Coord2 | null = null;\n  private shiftLockAxis: \"shift\" | \"row\" | \"col\" | null = null;\n  private dragging = false;\n  private rightButton = false;\n  private middleButton = false;\n\n  currentCharPos(e: any): { charPos: Coord2 } {\n    if (!this.ref.current) {\n      throw new Error(\"impossible?\");\n    }\n\n    const bbox = this.ref.current.getBoundingClientRect();\n    const xx = e.clientX - bbox.left;\n    const yy = e.clientY - bbox.top;\n\n    const invXform = matrix.invert(this.props.framebufUIState.canvasTransform);\n    let [x, y] = matrix.multVect3(invXform, [xx, yy, 1]);\n    x /= 8;\n    y /= 8;\n\n    if (!this.props.borderOn) {\n      return { charPos: { row: Math.floor(y), col: Math.floor(x) } };\n    } else {\n      return { charPos: { row: Math.floor(y) - 4, col: Math.floor(x) - 4 } };\n    }\n  }\n\n  setCharPos(isActive: boolean, charPos: Coord2) {\n    this.setState({ isActive, charPos });\n    this.props.onCharPosChanged({ isActive, charPos });\n  }\n\n  handleMouseEnter = (e: any) => {\n    const { charPos } = this.currentCharPos(e);\n    this.setCharPos(true, charPos);\n  };\n\n  handleMouseLeave = (e: any) => {\n    const { charPos } = this.currentCharPos(e);\n    this.setCharPos(false, charPos);\n  };\n\n  handlePointerDown = (e: any) => {\n    if (\n      this.props.selectedTool == Tool.PanZoom ||\n      (this.props.selectedTool !== Tool.Text && this.props.spacebarKey)\n    ) {\n      this.handlePanZoomPointerDown(e);\n      return;\n    }\n\n    const { charPos } = this.currentCharPos(e);\n    this.setCharPos(true, charPos);\n\n    this.rightButton = false;\n    this.middleButton = false;\n\n\n    // alt-left click doesn't start dragging\n    if (this.props.altKey && this.props.selectedTool !== Tool.Brush) {\n      this.dragging = false;\n      this.altClick(charPos);\n      return;\n    }\n\n    if (this.props.ctrlKey && this.props.selectedTool !== Tool.Brush && e.button !== 2) {\n      this.dragging = false;\n      this.ctrlClick(charPos);\n      return;\n    }\n\n\n    if (e.button == 1) {\n\n      //middle button\n      this.middleButton = true;\n      //this.handlePanZoomPointerDown(e);\n      //this.handlePanZoomPointerDown(e);\n      this.middleClick(charPos)\n      return;\n\n    }\n\n\n\n    if (e.button == 2) {\n      //right button\n      this.rightClick(charPos);\n      this.rightButton = true;\n\n      //return;\n    }\n\n    this.dragging = true;\n    e.target.setPointerCapture(e.pointerId);\n    this.prevCoord = charPos;\n    this.dragStart(charPos);\n\n    const lock = this.props.shiftKey;\n    this.shiftLockAxis = lock ? \"shift\" : null;\n    if (lock) {\n      this.lockStartCoord = {\n        ...charPos,\n      };\n    }\n  };\n\n  handlePointerUp = (e: PointerEvent) => {\n    if (this.props.selectedTool == Tool.PanZoom || this.panZoomDragging) {\n      this.handlePanZoomPointerUp(e);\n      return;\n    }\n\n    if (this.dragging) {\n      this.dragEnd();\n    }\n\n    this.rightButton = false;\n    this.dragging = false;\n    this.lockStartCoord = null;\n    this.shiftLockAxis = null;\n  };\n\n  handlePointerMove = (e: PointerEvent) => {\n    if (\n      this.props.selectedTool == Tool.PanZoom ||\n      (this.props.selectedTool !== Tool.Text && this.props.spacebarKey)\n    ) {\n      this.handlePanZoomPointerMove(e);\n      return;\n    }\n\n    const { charPos } = this.currentCharPos(e);\n    this.setCharPos(true, charPos);\n\n    if (\n      this.prevCharPos === null ||\n      this.prevCharPos.row !== charPos.row ||\n      this.prevCharPos.col !== charPos.col\n    ) {\n      this.prevCharPos = { ...charPos };\n      this.props.onCharPosChanged({ isActive: this.state.isActive, charPos });\n    }\n\n    if (!this.dragging) {\n      return;\n    }\n\n    // Note: prevCoord is known to be not null here as it's been set\n    // in mouse down\n    const coord = charPos;\n    if (\n      this.prevCoord!.row !== coord.row ||\n      this.prevCoord!.col !== coord.col\n    ) {\n      if (this.shiftLockAxis === \"shift\") {\n        if (this.prevCoord!.row === coord.row) {\n          this.shiftLockAxis = \"row\";\n        } else if (this.prevCoord!.col === coord.col) {\n          this.shiftLockAxis = \"col\";\n        }\n      }\n\n      if (this.shiftLockAxis !== null) {\n        let lockedCharPos = {\n          ...this.lockStartCoord!,\n        };\n\n        if (this.shiftLockAxis === \"row\") {\n          lockedCharPos.col = charPos.col;\n        } else if (this.shiftLockAxis === \"col\") {\n          lockedCharPos.row = charPos.row;\n        }\n        this.dragMove(lockedCharPos);\n      } else {\n        this.dragMove(charPos);\n      }\n      this.prevCoord = charPos;\n    }\n  };\n  //---------------------------------------------------------------------\n  // Pan/zoom mouse event handlers.  Called by the bound handlePointerDown/Move/Up\n  // functions if the pan/zoom tool is selected.\n\n  private panZoomDragging = false;\n\n  handlePanZoomPointerDown(e: any) {\n    this.panZoomDragging = true;\n    e.currentTarget.setPointerCapture(e.pointerId);\n  }\n\n  handlePanZoomPointerUp(_e: any) {\n    this.panZoomDragging = false;\n  }\n\n  xZoom = (zoom: Zoom) => {\n  };\n\n  // Mutable dst\n  clampToWindow(xform: matrix.Matrix3x3): matrix.Matrix3x3 {\n\n    var xCanvas = document.getElementById(\"MainCanvas\");\n    var currentScale = Number(xCanvas?.style.transform.split(',')[3]);\n\n    return xform as matrix.Matrix3x3;\n  }\n\n  handlePanZoomPointerMove(e: any) {\n    if (this.panZoomDragging) {\n      const dx = e.nativeEvent.movementX;\n      const dy = e.nativeEvent.movementY;\n\n      const prevUIState = this.props.framebufUIState;\n      const prevTransform = prevUIState.canvasTransform;\n\n      const invXform = matrix.invert(prevTransform);\n      const srcDxDy = matrix.multVect3(invXform, [dx, dy, 0]);\n\n      const xform = matrix.mult(\n        prevTransform,\n        matrix.translate(srcDxDy[0], srcDxDy[1])\n      );\n\n\n      this.props.Toolbar.setCurrentFramebufUIState({\n        ...prevUIState,\n        canvasTransform: this.clampToWindow(xform),\n      });\n    }\n  }\n\n  // Reset canvas scale transform to identity on double click.\n  handleDoubleClick = () => {\n    if (this.props.selectedTool != Tool.PanZoom) {\n      return;\n    }\n    const prevUIState = this.props.framebufUIState;\n    this.props.Toolbar.setCurrentFramebufUIState({\n      ...prevUIState,\n      canvasTransform: matrix.ident(),\n    });\n  };\n\n  handleWheel = (e: WheelEvent) => {\n    if (this.props.selectedTool == Tool.Text) {\n      return;\n    }\n\n    if (!this.ref.current) {\n      return;\n    }\n\n    if (e.deltaY == 0) {\n      return;\n    }\n\n    let xform;\n\n    const wheelScale = 1;\n    const delta = Math.min(Math.abs(e.deltaY), wheelScale);\n    let scaleDelta =\n      e.deltaY < 0.0\n        ? 1.0 / (1.0 - delta / (wheelScale + 1.0))\n        : 1.0 - delta / (wheelScale + 1.0);\n\n    const scaleDir = e.deltaY < 0 ? 1 : -1;\n\n    var xCanvas = document.getElementById(\"MainCanvas\");\n    var ParentCanvas = document.getElementById(\"MainCanvas\")?.parentElement;\n    var currentScale = Number(xCanvas?.style.transform.split(',')[3]);\n\n    var updatedScale = currentScale + (.5*scaleDir);\n\n    const bbox = this.ref.current.getBoundingClientRect();\n    let mouseX = e.nativeEvent.clientX - bbox.left;\n    let mouseY = e.nativeEvent.clientY - bbox.top;\n\n    const prevUIState = this.props.framebufUIState;\n\n    let invXform = matrix.invert(prevUIState.canvasTransform);\n    let srcPos = matrix.multVect3(invXform, [mouseX, mouseY, 1]);\n\n    const framewidthpx =\n      this.props.framebufWidth * 8 + Number(this.props.borderOn) * 64; //need to calc border and custom frame sizes..(non 320/200 etc)\n    const frameheightpx =\n      this.props.framebufHeight * 8 + Number(this.props.borderOn) * 64;\n\n    if (this.props.ctrlKey && !this.props.shiftKey) {\n      xform =\n        matrix.scale(updatedScale)\n        xform.v[0][2] =\n        Math.ceil(bbox.width / 2) -\n        xform.v[0][0] * Math.ceil(framewidthpx / 2);\n      xform.v[1][2] =\n        Math.ceil(bbox.height / 2) -\n        xform.v[0][0] * Math.ceil(frameheightpx / 2);\n      ;\n    } else if (this.props.ctrlKey && this.props.shiftKey) {\n      xform =\n        matrix.mult(\n          matrix.translate(0,0),\n          matrix.scale(updatedScale)\n\n      );\n      xform.v[0][2] = 0;\n      xform.v[1][2] = 0;\n    } else {\n      xform = matrix.mult(\n        prevUIState.canvasTransform,\n        matrix.mult(\n          matrix.translate(\n            Math.trunc(srcPos[0] - scaleDelta * srcPos[0]),\n            Math.trunc(srcPos[1] - scaleDelta * srcPos[1])\n          ),\n          matrix.scale(scaleDelta)\n        )\n      );\n    }\n\n    if (xform.v[0][0] <= 0.5) {\n      xform.v[0][0] = 0.5;\n      xform.v[1][1] = 0.5;\n    }\n    else if (xform.v[0][0] >= 0.51 && xform.v[0][0] < 8) {\n\n    }\n    else if (xform.v[0][0] >= 8 || xform.v[1][1] >= 8) {\n      xform.v[0][0] = 8;\n      xform.v[1][1] = 8;\n    }\n\n    // Mousewheel scale can be anything (depends on PC mouse sensitivity), we just want the direction\n\n\n    let zoom;\n\n    if (xform.v[0][0] == prevUIState.canvasTransform.v[0][0]) {\n    } else {\n      this.props.framebufLayout.pixelScale = xform.v[0][0] * scaleDir;\n\n      if (this.props.ctrlKey && !this.props.shiftKey) {\n        zoom = {\n          zoomLevel: Number(updatedScale.toFixed(2)),\n          alignment: \"center\",\n        };\n\n      } else if (this.props.ctrlKey && this.props.shiftKey) {\n        zoom = {\n          zoomLevel: Number(updatedScale.toFixed(2)),\n          alignment: \"left\",\n        };\n      } else {\n        zoom = {\n          zoomLevel: Number(updatedScale.toFixed(2)),\n          alignment: \"mouse\",\n        };\n      }\n\n\n      //this.props.Toolbar.setZoom(zoom.zoomLevel,zoom.alignment);\n    this.props.Framebuffer.setZoom(zoom);\n\n      this.props.Toolbar.setCurrentFramebufUIState({\n        ...prevUIState,\n        canvasTransform: this.clampToWindow(xform),\n      });\n    }\n  };\n\n  render() {\n    // Editor needs to specify a fixed width/height because the contents use\n    // relative/absolute positioning and thus seem to break out of the CSS\n    // grid.\n    const charWidth = this.props.framebufWidth;\n    const charHeight = this.props.framebufHeight;\n\n\n\n    const backg = utils.colorIndexToCssRgb(\n      this.props.colorPalette,\n      this.props.backgroundColor\n    );\n    const borderColor = utils.colorIndexToCssRgb(\n      this.props.colorPalette,\n      this.props.borderColor\n    );\n\n    const { selectedTool } = this.props;\n    let overlays = null;\n    let screencodeHighlight: number | undefined = this.props.curScreencode;\n    let colorHighlight: number | undefined = this.props.textColor;\n    let highlightCharPos = true;\n\n    if (this.state.isActive) {\n      if (selectedTool === Tool.Brush) {\n        highlightCharPos = false;\n        if (this.props.brush !== null) {\n          overlays = (\n            <BrushOverlay\n              charPos={this.state.charPos}\n              framebufWidth={this.props.framebufWidth}\n              framebufHeight={this.props.framebufHeight}\n              backgroundColor={backg}\n              colorPalette={this.props.colorPalette}\n              font={this.props.font}\n              brush={this.props.brush}\n              borderOn={this.props.borderOn}\n            />\n          );\n        } else {\n          overlays = (\n            <BrushSelectOverlay\n              charPos={this.state.charPos}\n              framebufWidth={this.props.framebufWidth}\n              framebufHeight={this.props.framebufHeight}\n              brushRegion={this.props.brushRegion}\n              borderOn={this.props.borderOn}\n            />\n          );\n        }\n      } else if (\n        selectedTool === Tool.Draw ||\n        selectedTool === Tool.Colorize ||\n        selectedTool === Tool.CharDraw ||\n        selectedTool === Tool.FloodFill\n      ) {\n        overlays = (\n          <CharPosOverlay\n            framebufWidth={this.props.framebufWidth}\n            framebufHeight={this.props.framebufHeight}\n            charPos={this.state.charPos}\n            borderOn={this.props.borderOn}\n            opacity={1.0}\n          />\n        );\n        if (selectedTool === Tool.Colorize) {\n          screencodeHighlight = undefined;\n        } else if (selectedTool === Tool.CharDraw) {\n          colorHighlight = undefined;\n        }\n        // Don't show current char/color when the ALT color/char picker is active\n        if (this.props.altKey) {\n          highlightCharPos = false;\n        }\n      } else {\n        highlightCharPos = false;\n        screencodeHighlight = undefined;\n        colorHighlight = undefined;\n      }\n    }\n\n    if (selectedTool === Tool.Text) {\n      screencodeHighlight = undefined;\n      colorHighlight = undefined;\n      const { textCursorPos, textColor } = this.props;\n      let textCursorOverlay = null;\n      if (textCursorPos !== null) {\n        const color = utils.colorIndexToCssRgb(\n          this.props.colorPalette,\n          textColor\n        );\n        textCursorOverlay = (\n          <TextCursorOverlay\n            framebufWidth={this.props.framebufWidth}\n            framebufHeight={this.props.framebufHeight}\n            charPos={textCursorPos}\n            fillColor={color}\n            opacity={0.5}\n            borderOn={this.props.borderOn}\n          />\n        );\n      }\n      overlays = (\n        <Fragment>\n          {textCursorOverlay}\n          {this.state.isActive ? (\n            <CharPosOverlay\n              framebufWidth={this.props.framebufWidth}\n              framebufHeight={this.props.framebufHeight}\n              charPos={this.state.charPos}\n              opacity={0.5}\n              borderOn={this.props.borderOn}\n            />\n          ) : null}\n        </Fragment>\n      );\n    }\n\n    const transform = this.props.framebufUIState.canvasTransform;\n\n\n\n    const scale: CSSProperties = {\n      display: \"flex\",\n      flexDirection: \"row\",\n      alignItems: \"flex-start\",\n      imageRendering: \"pixelated\",\n      overflowX: \"hidden\",\n      overflowY: \"hidden\",\n      transformOrigin: \"0,0\",\n      border: \"1px solid rgba(255,255,255,.25)\",\n      transition: \"transform 2s\",\n      width: `100%`,\n      height: `100%`,\n    };\n    const canvasContainerStyle: CSSProperties = {\n      transform: matrix.toCss(\n        matrix.mult(matrix.scale(1), this.clampToWindow(transform))\n      ),\n    };\n\n    return (\n      <div\n        id=\"MainContainer\"\n        style={scale}\n        ref={this.ref}\n        onWheel={this.handleWheel}\n        onDoubleClick={this.handleDoubleClick}\n        onMouseEnter={this.handleMouseEnter}\n        onMouseLeave={this.handleMouseLeave}\n        onPointerDown={(e) => this.handlePointerDown(e)}\n        onPointerMove={(e) => this.handlePointerMove(e)}\n        onPointerUp={(e) => this.handlePointerUp(e)}\n      >\n        <div id=\"MainCanvas\" style={canvasContainerStyle}>\n          <CharGrid\n            width={charWidth}\n            height={charHeight}\n            grid={false}\n            backgroundColor={backg}\n            framebuf={this.props.framebuf}\n            charPos={\n              this.state.isActive && highlightCharPos\n                ? this.state.charPos\n                : undefined\n            }\n            curScreencode={screencodeHighlight}\n            textColor={colorHighlight}\n            font={this.props.font}\n            colorPalette={this.props.colorPalette}\n            borderOn={this.props.borderOn}\n            borderWidth={32}\n            borderColor={borderColor}\n            isDirart={this.props.isDirart}\n\n\n          />\n          {overlays}\n          {this.props.canvasGrid ? (\n            <GridOverlay\n              width={charWidth}\n              height={charHeight}\n              color={gridColor}\n              borderWidth={32}\n              borderColor={borderColor}\n              borderOn={this.props.borderOn}\n            />\n          ) : null}\n        </div>\n      </div>\n    );\n  }\n}\n\nfunction computeFramebufLayout(args: {\n  containerSize: { width: number; height: number };\n  framebufSize: { charWidth: number; charHeight: number };\n  canvasFit: FramebufUIState[\"canvasFit\"];\n  borderOn: boolean;\n  zoom: Zoom;\n  zoomReady: boolean;\n\n}) {\n  const bottomPad = 0;\n  const rightPad = 0;\n  const { charWidth, charHeight } = args.framebufSize;\n  const maxWidth = args.containerSize.width - rightPad;\n  const maxHeight = args.containerSize.height - bottomPad;\n\n  const canvasWidth = Math.trunc(charWidth * 8 + Number(args.borderOn) * 32);\n  const canvasHeight = Math.trunc(charHeight * 8 + Number(args.borderOn) * 32);\n\n\n\n  let ws = maxWidth / canvasWidth;\n  let divWidth = canvasWidth * ws;\n  let divHeight = canvasHeight * ws;\n\n  if (args.canvasFit == \"nofit\") {\n    ws = 2;\n  } else if (args.canvasFit == \"fitWidth\") {\n    if (divHeight > maxHeight) {\n      divHeight = maxHeight;\n    }\n  } else if (args.canvasFit == \"fitWidthHeight\") {\n    // If height is now larger than what we can fit in vertically, scale further\n    if (divHeight > maxHeight) {\n      const s = maxHeight / divHeight;\n      divWidth *= s;\n      divHeight *= s;\n      ws *= s;\n    }\n  } else if (args.canvasFit == \"fitHeight\") {\n    if (divWidth > maxWidth) {\n      const s = maxWidth / divWidth;\n      divWidth *= s;\n      divHeight *= s;\n      ws *= s;\n    }\n  }\n\n  // no div scaling, lock to 1\n  ws = 1;\n\n  return {\n    width: divWidth,\n    height: divHeight,\n    pixelScale: ws,\n  };\n}\n\nconst FramebufferCont = connect(\n  (state: RootState) => {\n    const selected = state.toolbar.selectedChar;\n    const charTransform = state.toolbar.charTransform;\n    const framebuf = selectors.getCurrentFramebuf(state)!;\n    const charset = framebuf.charset;\n    if (framebuf == null) {\n      throw new Error(\n        \"cannot render FramebufferCont with a null framebuf, see Editor checks.\"\n      );\n    }\n\n\n\n\n\n    const framebufIndex = screensSelectors.getCurrentScreenFramebufIndex(state);\n    const { font } = selectors.getCurrentFramebufFont(state);\n    return {\n      framebufIndex,\n      framebuf: framebuf.framebuf,\n      framebufWidth: framebuf.width,\n      framebufHeight: framebuf.height,\n      backgroundColor: framebuf.backgroundColor,\n      borderColor: framebuf.borderColor,\n      borderOn: framebuf.borderOn,\n      zoom: framebuf.zoom,\n      zoomReady: framebuf.zoomReady,\n      undoId: state.toolbar.undoId,\n      curScreencode: selectors.getScreencodeWithTransform(\n        selected,\n        font,\n        charTransform\n      ),\n      selectedTool: state.toolbar.selectedTool,\n      textColor: state.toolbar.textColor,\n      brush: selectors.transformBrush(\n        state.toolbar.brush,\n        state.toolbar.brushTransform,\n        font\n      ),\n      brushRegion: state.toolbar.brushRegion,\n      textCursorPos: state.toolbar.textCursorPos,\n      shiftKey: state.toolbar.shiftKey,\n      altKey: state.toolbar.altKey,\n      spacebarKey: state.toolbar.spacebarKey,\n      ctrlKey: state.toolbar.ctrlKey,\n      font,\n      colorPalette: getSettingsCurrentColorPalette(state),\n      canvasGrid: state.toolbar.canvasGrid,\n      isDirart: framebuf.charset=='dirart',\n\n    };\n  },\n  (dispatch) => {\n    return {\n      Framebuffer: Framebuffer.bindDispatch(dispatch),\n      Toolbar: Toolbar.bindDispatch(dispatch),\n    };\n  },\n  framebufIndexMergeProps\n)(FramebufferView);\n\ninterface EditorProps {\n  framebuf: Framebuf | null;\n  framebufUIState: FramebufUIState | undefined;\n  textColor: number;\n  colorPalette: Rgb[];\n  paletteRemap: number[];\n  selectedTool: Tool;\n  spacebarKey: boolean;\n  ctrlKey:boolean;\n  brushActive: boolean;\n  integerScale: boolean;\n  containerSize: {width:number,height:number} | null;\n  //isDirart: boolean;\n\n}\n// moved from EditorProps\n//zoom: Zoom;\n//zoomReady: boolean;\n\ninterface EditorDispatch {\n  Toolbar: toolbar.PropsFromDispatch;\n}\n\nclass Editor extends Component<EditorProps & EditorDispatch> {\n  state = {\n    isActive: false,\n    charPos: { row: -1, col: 0 },\n  };\n\n  handleSetColor = (color: number) => {\n    this.props.Toolbar.setCurrentColor(color);\n  };\n\n  handleCharPosChanged = (args: { isActive: boolean; charPos: Coord2 }) => {\n    this.setState({\n      charPos: args.charPos,\n      isActive: args.isActive,\n    });\n  };\n\n  render() {\n    if (\n      this.props.framebuf === null ||\n      this.props.containerSize == null ||\n      !this.props.framebufUIState\n    ) {\n      return null;\n    }\n    const { colorPalette } = this.props;\n    //const borderColor = utils.colorIndexToCssRgb(colorPalette, this.props.framebuf.borderColor)\n\n\n\n    const framebufSize = computeFramebufLayout({\n      containerSize: this.props.containerSize,\n      framebufSize: {\n        charWidth: this.props.framebuf.width,\n        charHeight: this.props.framebuf.height,\n      },\n      canvasFit: this.props.framebufUIState.canvasFit,\n      borderOn: this.props.framebuf.borderOn,\n      zoom: this.props.framebuf.zoom,\n      zoomReady: this.props.framebuf.zoomReady,\n      //isDirart: this.props.framebuf.charset=='dirart'?true:false,\n    });\n\n\n\n\n    const framebufStyle = {\n      position: \"absolute\",\n      left: \"10px\",\n      bottom: \"20px\",\n      right: \"320px\",\n      top: \"0px\",\n      borderColor: \"#3b3b3b\",\n      borderStyle: \"solid\",\n      borderWidth: `${4}px`,\n    } as React.CSSProperties;\n\n    const spacebarKey = this.props.spacebarKey;\n    const brushSelected = this.props.brushActive;\n\n    //const brushSelected = true;\n    const scaleX = 2;\n    const scaleY = 2;\n    const fbContainerClass = classNames(\n      styles.fbContainer,\n\n      this.props.selectedTool == Tool.Text ? styles.text : null,\n      this.props.selectedTool == Tool.Brush && !brushSelected && !spacebarKey\n        ? styles.select\n        : null,\n      this.props.selectedTool == Tool.Brush && brushSelected && !spacebarKey\n        ? styles.brushstamp\n        : null,\n      this.props.selectedTool == Tool.PanZoom || spacebarKey\n        ? styles.panzoom\n        : null\n    );\n    return (\n      <div className={styles.editorLayoutContainer}>\n        <div>\n          <div className={fbContainerClass} style={framebufStyle}>\n            {this.props.framebuf ? (\n              <FramebufferCont\n                framebufLayout={framebufSize}\n                framebufUIState={this.props.framebufUIState}\n                onCharPosChanged={this.handleCharPosChanged}\n              />\n            ) : null}\n          </div>\n        </div>\n        <div\n          style={{\n            display: \"block\",\n            position: \"absolute\",\n            right: \"0\",\n            marginLeft: \"8px\",\n            marginRight: \"16px\"\n\n          }}\n        >\n          <div style={{ marginBottom: \"10px\" }}>\n            <ColorPicker\n              selected={this.props.textColor}\n              paletteRemap={this.props.paletteRemap}\n              colorPalette={colorPalette}\n              onSelectColor={this.handleSetColor}\n              twoRows={true}\n              scale={{ scaleX, scaleY }}\n              ctrlKey={this.props.ctrlKey}\n            />\n          </div>\n          <CharSelect textColor={this.props.textColor} canvasScale={{ scaleX, scaleY }} />\n\n\n        </div>\n\n        <div\n          style={{\n            display: \"relative\",\n            position: \"absolute\",\n            left: \"0\",\n            bottom: \"0\",\n            paddingLeft: \"20px\",\n          }}\n        >\n          <CanvasStatusbar\n            framebuf={this.props.framebuf}\n            isActive={this.state.isActive}\n            charPos={this.state.charPos}\n            zoom={this.props.framebuf.zoom}\n          />\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default connect(\n  (state: RootState) => {\n    const framebuf = selectors.getCurrentFramebuf(state);\n    const framebufIndex = screensSelectors.getCurrentScreenFramebufIndex(state);\n\n\n\n    return {\n      framebuf,\n      textColor: state.toolbar.textColor,\n      selectedTool: state.toolbar.selectedTool,\n      paletteRemap: getSettingsPaletteRemap(state),\n      colorPalette: getSettingsCurrentColorPalette(state),\n      integerScale: getSettingsIntegerScale(state),\n      framebufUIState: selectors.getFramebufUIState(state, framebufIndex),\n      spacebarKey: state.toolbar.spacebarKey,\n      ctrlKey: state.toolbar.ctrlKey,\n      brushActive: state.toolbar.brush !== null ? true : false,\n\n    };\n  },\n  (dispatch) => {\n    return {\n      Toolbar: Toolbar.bindDispatch(dispatch),\n    };\n  }\n)(Editor);\n","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\reducers\\index.ts",[],"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\external\\react-sortable-hoc\\utils.js",[],"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\importers\\index.ts",[],"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\exporters\\index.ts",[],"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\components\\formHelpers.js",[],"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\importers\\png2petscii.ts",["345"],"// This needs to be completely stand-alone as it may be used\n// as a web worker.\n\n// Note: currently supports only 320x200 borderless or 384x272 bordered inputs.\n\nconst SCREEN_WIDTH = 320;\nconst SCREEN_HEIGHT = 200;\n\n// These match the dimensions that VICE uses for PNG export.\nconst BORDER_LEFT_WIDTH = 32;\nconst BORDER_RIGHT_WIDTH = 32;\nconst BORDER_TOP_HEIGHT = 35;\nconst BORDER_BOTTOM_HEIGHT = 37;\n\ntype Rgb = {\n  r: number,\n  g: number,\n  b: number\n};\n\nexport interface Args {\n  width: number;\n  height: number;\n  data: Uint8Array;\n  fontBits: Uint8Array,\n  rgbPalettes: Rgb[][];\n}\n\nexport interface Match {\n  backgroundColor: number;\n  screencodes: Uint8Array;\n  colors: (number|undefined)[];\n};\n\nexport interface Result {\n  width: number;\n  height: number;\n  hasBorder: boolean;\n  borderColor?: number; // this is not set if the image didn't include border\n  matches: Match[];\n}\n\nexport interface Err {\n  error: string;\n}\n\nexport function isError(v: Result|Err): v is Err {\n  return v.hasOwnProperty('error');\n}\n\nfunction sqr(a: number) {\n  return a*a;\n}\n\n// Convert from RGB to our fixed C64 palette\nfunction toIndexed(data: Uint8Array, rgbPalette: Rgb[], numPixels: number) {\n  const indexed = new Uint8Array(numPixels);\n  let mse = 0.0;\n  for (let i = 0; i < numPixels; i++) {\n    const rr = data[i*4+0];\n    const rg = data[i*4+1];\n    const rb = data[i*4+2];\n\n    let minDist = 3*256*256;\n    let minIdx  = 0;\n    for (let ci = 0; ci < 16; ci++) {\n      const dist = sqr(rr - rgbPalette[ci].r) + sqr(rg - rgbPalette[ci].g) + sqr(rb - rgbPalette[ci].b);\n      if (dist < minDist) {\n        minDist = dist;\n        minIdx = ci;\n      }\n    }\n    mse += minDist;\n    indexed[i] = minIdx;\n  }\n  return {\n    indexed,\n    mse: mse / numPixels\n  }\n}\n\nfunction crop(\n  data: Uint8Array,\n  stride: number,\n  outWidth: number,\n  outHeight: number,\n  offsetX: number,\n  offsetY: number\n) {\n  if (offsetX == 0 && offsetY == 0 && stride == outWidth) {\n    return data;\n  }\n  const dst = new Uint8Array(outWidth * outHeight);\n  let dstIdx = 0;\n  for (let y = 0; y < outHeight; y++) {\n    for (let x = 0; x < outWidth; x++, dstIdx++) {\n      dst[dstIdx] = data[(y + offsetY) * stride + x + offsetX];\n    }\n  }\n  return dst;\n}\n\nfunction findBorderColor(data: Uint8Array, hasBorder: boolean, width: number, height: number) {\n  if (!hasBorder) {\n    return undefined;\n  }\n  // Take a pixel from the middle of the left border (for a completely clean\n  // input the location shouldn't really matter.)\n  return data[Math.floor(BORDER_LEFT_WIDTH/2) + Math.floor((height/2))*width];\n}\n\nfunction getBlockBits(data: Uint8Array, offs: number, stride: number, bg: number) {\n  const b = new Uint8Array(8);\n  let yoffs = offs;\n  let color = undefined;\n  for (let y = 0; y < 8; y++, yoffs += stride) {\n    let bits = 0;\n    for (let x = 0; x < 8; x++) {\n      const pix = data[yoffs + x];\n      if (pix != bg) {\n        bits |= 1 << (7 - x);\n        // If there are multiple colors, then the background color must be wrong\n        // and we should bail out from this decoding attempt.\n        if (color != undefined) {\n          if (color != pix) {\n            return undefined;\n          }\n        }\n        color = pix;\n      }\n    }\n    b[y] = bits;\n  }\n  return {\n    color,\n    block: b\n  };\n}\n\nfunction matchScreencode(fontBits: Uint8Array, blockBits: Uint8Array): number|undefined {\n  for (let ci = 0; ci < 256; ci++) {\n    const offs = ci*8;\n\n    let found = true;\n    for (let i = 0; i < 8; i++) {\n      if (fontBits[offs + i] != blockBits[i]) {\n        found = false;\n        break;\n      }\n    }\n    if (found) {\n      return ci;\n    }\n  }\n  return undefined;\n}\n\nfunction findScreencodes(\n  fontBits: Uint8Array,\n  screenPixels: Uint8Array,\n  width: number,\n  height: number,\n  backgroundColor: number\n): Match|undefined {\n  const blockWidth  = Math.floor(width / 8);\n  const blockHeight = Math.floor(height / 8);\n  const numBlocks   = blockWidth * blockHeight;\n  const stride = width;\n\n  const dstScreencode = new Uint8Array(numBlocks);\n  const dstColor = Array(numBlocks).fill(undefined);\n\n  for (let by = 0; by < blockHeight; by++) {\n    for (let bx = 0; bx < blockWidth; bx++) {\n      const offs = by*8*stride + bx*8;\n      const blockBits = getBlockBits(screenPixels, offs, stride, backgroundColor);\n      if (!blockBits) {\n        return undefined;\n      }\n      const { color, block } = blockBits;\n      const screencode = matchScreencode(fontBits, block);\n      if (screencode == undefined) {\n        return undefined;\n      }\n      const dstOffs = by*blockWidth + bx;\n      dstScreencode[dstOffs] = screencode;\n      dstColor[dstOffs] = color;\n    }\n  }\n  return {\n    backgroundColor,\n    screencodes: dstScreencode,\n    colors: dstColor\n  };\n}\n\n// Pick the RGB->indexed variant that minimizes MSE error between original RGBs\n// and the index quantized version.  There could be a faster way to do this, but\n// this works decently.  The reason we're doing this is that there exist many\n// flavors of the C64 palette and some PETSCII PNGs use a palette that maps\n// color indices to different values if quantized against the default Petmate\n// color palette.\nfunction convertToIndexed(data: Uint8Array, rgbPalettes: Rgb[][], numPixels: number) {\n  let indexedBitmap: Uint8Array;\n  let minMse = Infinity;\n  for (let paletteIdx in rgbPalettes) {\n    const { indexed, mse } = toIndexed(data, rgbPalettes[paletteIdx], numPixels);\n    if (mse < minMse) {\n      indexedBitmap = indexed;\n      minMse = mse;\n    }\n  }\n  return indexedBitmap!;\n}\n\nexport function png2petscii(args: Args): Err|Result  {\n  let hasBorder = false;\n  const { width, height } = args;\n  if (width == SCREEN_WIDTH + BORDER_LEFT_WIDTH + BORDER_RIGHT_WIDTH &&\n      height == SCREEN_HEIGHT + BORDER_TOP_HEIGHT + BORDER_BOTTOM_HEIGHT) {\n    hasBorder = true;\n  } else {\n    if (width != SCREEN_WIDTH || height !== SCREEN_HEIGHT) {\n      return { error: `Only 320x200 borderless or 384x272 bordered inputs are supported.  Got ${width}x${height}` };\n    }\n  }\n  const outWidth = 40;\n  const outHeight = 25;\n  const indexedBitmap = convertToIndexed(args.data, args.rgbPalettes, width*height);\n  const [offsetX, offsetY] = hasBorder ? [BORDER_LEFT_WIDTH, BORDER_TOP_HEIGHT] : [0, 0];\n  const [screenWidth, screenHeight] = hasBorder ? [width - BORDER_LEFT_WIDTH - BORDER_RIGHT_WIDTH, height - BORDER_TOP_HEIGHT - BORDER_BOTTOM_HEIGHT] : [width, height];\n  const screenOnlyIndexed = crop(indexedBitmap, width, SCREEN_WIDTH, SCREEN_HEIGHT, offsetX, offsetY);\n  const borderColor = findBorderColor(indexedBitmap, hasBorder, width, height);\n  const results: Match[] = [];\n  // Try all 16 background colors and see which ones match.\n  for (let bg = 0; bg < 16; bg++) {\n    const fb = findScreencodes(args.fontBits, screenOnlyIndexed, screenWidth, screenHeight, bg);\n    if (fb != undefined) {\n      results.push(fb);\n    }\n  }\n  if (results.length == 0) {\n    return {\n      error: 'Could not match to PETSCII for any background color.  Likely reason: the image is not in 320x200 (no border) or 384x272 (with borders) resolution or it has been scaled.  Please see documentation for more information.'\n    };\n  }\n  return {\n    width: outWidth,\n    height: outHeight,\n    hasBorder: hasBorder,\n    borderColor,\n    matches: results\n  }\n}\n","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\containers\\hoc.tsx",["346"],"\nimport React, { Component } from 'react';\n\ntype Omit<T, K> = Pick<T, Exclude<keyof T, K>>;\ntype Subtract<T, K> = Omit<T, keyof K>;\n\ninterface WithHoverInjectedProps {\n  onToggleActive: () => void;\n  fadeOut: boolean;\n}\n\ninterface WithHoverFadeProps {\n  pickerId: any;\n  active: boolean;\n  containerClassName: string;\n  onSetActive: (pickerId: any, active: boolean) => void;\n}\n\ninterface WithHoverFadeState {\n  fadeOut: boolean;\n}\n\n// See https://medium.com/@jrwebdev/react-higher-order-component-patterns-in-typescript-42278f7590fb\nexport const withHoverFade = <P extends WithHoverInjectedProps>(C: React.ComponentType<P>) => {\n  return class extends Component<Subtract<P, WithHoverInjectedProps> & WithHoverFadeProps, WithHoverFadeState> {\n    state: WithHoverFadeState = {\n      fadeOut: false\n    };\n    timerId: any = null;\n\n    componentWillUnmount () {\n      if (this.timerId !== null) {\n        clearTimeout(this.timerId)\n      }\n    }\n\n    clearHoverTimer = () => {\n      if (this.timerId !== null) {\n        clearTimeout(this.timerId)\n        this.timerId = null\n      }\n    }\n\n    handleMouseEnter = () => {\n      this.setState({fadeOut: false})\n      this.clearHoverTimer()\n    }\n\n    handleMouseLeave = () => {\n      clearTimeout(this.timerId)\n      this.setState({fadeOut: true})\n      this.timerId = setTimeout(() => {\n        this.props.onSetActive(this.props.pickerId, false)\n      }, 500)\n    }\n\n    handleToggleActive = () => {\n      const newIsActive = !this.props.active\n      this.props.onSetActive(this.props.pickerId, newIsActive)\n      if (this.timerId !== null) {\n        this.clearHoverTimer()\n      }\n    }\n\n    render () {\n//      const { pickerId, active, containerClassName, onSetActive, ...rest} = this.props as WithHoverFadeProps;\n      // See: https://github.com/Microsoft/TypeScript/issues/28938\n      const ts32workAround: any = {\n        ...this.props,\n        onToggleActive: this.handleToggleActive,\n        fadeOut: this.state.fadeOut\n      }\n/*\n          <C\n            {...rest}\n            onToggleActive={this.handleToggleActive}\n            fadeOut={this.state.fadeOut}\n          />\n*/\n      return (\n        <div\n          className={this.props.containerClassName}\n          onMouseLeave={this.handleMouseLeave}\n          onMouseEnter={this.handleMouseEnter}\n        >\n          <C\n            {...ts32workAround}\n          />\n        </div>\n      )\n    }\n  }\n}\n\n","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\containers\\ContextMenuArea.tsx",["347"],"import React, { Component } from 'react'\n\nimport { electron } from '../utils/electronImports'\nconst remote = electron.remote;\n\nconst { Menu } = remote;\n\ninterface ContextMenuAreaProps {\n  menuItems: any[];\n  style?: React.CSSProperties;\n};\n\n// Copied from https://github.com/johot/react-electron-contextmenu (with some\n// bug fixes like unregistering event handlers)\nexport default class ContextMenuArea extends Component<ContextMenuAreaProps> {\n  private menu = new Menu();\n  private rootElement = React.createRef<HTMLDivElement>();\n\n  handleContextMenu = (e: Event) => {\n    e.preventDefault();\n    //self._rightClickPosition = { x: e.x, y: e.y };\n   this.menu.popup(remote.getCurrentWindow())\n  }\n\n  componentDidMount() {\n    this.menu = Menu.buildFromTemplate(this.props.menuItems)\n    if (!this.rootElement.current) {\n      throw new Error('should be impossible');\n    }\n    this.rootElement.current.addEventListener(\n      \"contextmenu\",\n      this.handleContextMenu\n    )\n  }\n\n  componentWillUnmount() {\n    if (!this.rootElement.current) {\n      throw new Error('should be impossible');\n    }\n    this.rootElement.current.removeEventListener(\"contextmenu\", this.handleContextMenu)\n  }\n\n  render() {\n    return (\n      <div style={{ ...this.props.style }} ref={this.rootElement}>\n        {this.props.children}\n      </div>\n    );\n  }\n}\n\n","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\containers\\CharSelect.tsx",["348"],"\nimport React, { Component, useRef, useCallback, useState, MouseEvent, CSSProperties } from 'react';\nimport { connect } from 'react-redux'\nimport { Dispatch, bindActionCreators } from 'redux'\n\nimport { RootState, Font, Pixel, Coord2, Rgb, Tool } from '../redux/types'\nimport * as framebuffer from '../redux/editor'\nimport * as cfonts from '../redux/customFonts'\n\nimport { Toolbar } from '../redux/toolbar'\nimport { framebufIndexMergeProps } from '../redux/utils'\n\nimport CharGrid from '../components/CharGrid'\nimport CharPosOverlay from '../components/CharPosOverlay'\nimport { CharSelectStatusbar } from '../components/Statusbar'\n\nimport * as utils from '../utils'\nimport * as fp from '../utils/fp'\nimport * as selectors from '../redux/selectors'\nimport * as screensSelectors from '../redux/screensSelectors'\nimport {\n  getSettingsCurrentColorPalette\n} from '../redux/settingsSelectors'\n\nimport FontSelector from '../components/FontSelector'\n\nimport styles from './CharSelect.module.css'\n\ninterface CharSelectProps {\n  Toolbar: any; // TODO ts\n  Framebuffer: framebuffer.PropsFromDispatch;\n  charset: string;\n  font: Font;\n  customFonts: cfonts.CustomFonts;\n  canvasScale: {\n    scaleX: number, scaleY: number\n  };\n  colorPalette: Rgb[];\n  selected: Coord2 | null;\n  selectedTool: Tool,\n  backgroundColor: number;\n  textColor: number;\n  ctrlKey: boolean;\n}\n\n// Char position & click hook\nfunction useCharPos(\n  charWidth: number,\n  charHeight: number,\n  initialCharPos: Coord2 | null\n) {\n  const ref = useRef<HTMLDivElement>(null);\n  let [isActive, setIsActive] = useState(true);\n  let [charPos, setCharPos] = useState<Coord2|null>(initialCharPos);\n  let onMouseMove = useCallback(function(event: MouseEvent) {\n    if (isActive && ref.current != null) {\n      const bbox = ref.current.getBoundingClientRect();\n      const x = Math.floor((event.clientX - bbox.left)/bbox.width * charWidth);\n      const y = Math.floor((event.clientY - bbox.top)/bbox.height * charHeight);\n      if (x >= 0 && x < charWidth && y >= 0 && y < charHeight) {\n        setCharPos({row: y, col: x});\n      } else {\n        setCharPos(null);\n      }\n    }\n  }, [ref, charWidth, charHeight, setCharPos]);\n\n  let onMouseEnter = useCallback(function() {\n    setIsActive(true);\n  }, []);\n\n  let onMouseLeave = useCallback(function() {\n    setIsActive(false);\n    setCharPos(null);\n  }, []);\n\n  return {\n    charPos,\n    divProps: {\n      ref,\n      onMouseMove,\n      onMouseEnter,\n      onMouseLeave\n    }\n  };\n}\n\nfunction CharSelectView(props: {\n  font: Font;\n  charset: string;\n  customFonts: cfonts.CustomFonts;\n  canvasScale: {\n    scaleX: number, scaleY: number\n  };\n  colorPalette: Rgb[];\n  selected: Coord2;\n  backgroundColor: string;\n  style: CSSProperties;\n  textColor: number;\n\n  fb: Pixel[][];\n  onCharSelected: (pos: Coord2|null) => void;\n  setCharset: (charset: string) => void;\n}) {\n  const W = 16\n  const H = 17\n  const { scaleX, scaleY } = props.canvasScale;\n\n  const { charPos, divProps } = useCharPos(W, H, props.selected);\n\n  let screencode: number|null = utils.charScreencodeFromRowCol(props.font, props.selected);\n  if (charPos !== null) {\n    screencode = utils.charScreencodeFromRowCol(props.font, charPos);\n  }\n\n  let handleOnClick = useCallback(function() {\n    props.onCharSelected(charPos);\n\n  }, [charPos]);\n\n  const customFonts = Object.entries(props.customFonts).map(([id, { name }]) => {\n    return {\n      id,\n      name\n    };\n\n\n\n  })\n  return (\n    <div style={{\n      display: 'flex',\n      flexDirection: 'column'\n    }}>\n      <div className={styles.csContainer} style={props.style}>\n        <div\n          style={{\n            imageRendering: 'pixelated',\n            transform: `scale(${scaleX}, ${scaleY})`,\n            transformOrigin: '0% 0%',\n            width: W*9,\n            height: H*9\n          }}\n          {...divProps}\n          onClick={handleOnClick}\n        >\n\n          <CharGrid\n            width={W}\n            height={H}\n            backgroundColor={props.backgroundColor}\n            grid={true}\n            framebuf={props.fb}\n            font={props.font}\n            colorPalette={props.colorPalette}\n            textColor={props.textColor}\n            isDirart={props.charset=='dirart'}\n\n\n          />\n          {charPos !== null ?\n            <CharPosOverlay\n              framebufWidth={W}\n              framebufHeight={H}\n              grid={true}\n              opacity={0.5}\n              charPos={charPos!}\n              borderOn={false}\n            />\n            : null}\n          {props.selected ?\n            <CharPosOverlay\n              framebufWidth={W}\n              framebufHeight={H}\n              grid={true}\n              opacity={1.0}\n              charPos={props.selected}\n              borderOn={false}\n              />\n            : null}\n        </div>\n      </div>\n\n      <div style={{\n        display: 'flex',\n        flexDirection: 'row',\n        marginTop:'4px',\n        alignItems:'center',\n        justifyContent: 'space-between'\n      }}>\n        <CharSelectStatusbar\n          curScreencode={screencode}\n\n        />\n        <FontSelector\n          currentCharset={props.charset}\n          setCharset={props.setCharset}\n          customFonts={customFonts}\n        />\n      </div>\n    </div>\n  )\n}\n\nclass CharSelect extends Component<CharSelectProps> {\n\n  fb: Pixel[][]|null = null;\n  font: Font|null = null;\n  prevTextColor = -1;\n\n  constructor (props: CharSelectProps) {\n    super(props)\n    this.computeCachedFb(0)\n  }\n\n  computeCachedFb(textColor: number) {\n    const { font } = this.props\n    this.fb = fp.mkArray(17, y => {\n      return fp.mkArray(16, x => {\n        return {\n          code: utils.charScreencodeFromRowCol(font, {row:y, col:x})!,\n          color: textColor\n        }\n      })\n    })\n    this.prevTextColor = textColor\n    this.font = font\n  }\n\n  handleClick = (charPos: Coord2 | null) => {\n\n\n    //charPos is new one\n    //this.props.selected is the old one\n\n    if(this.props.ctrlKey)\n    {\n      if(this.props.selected!=null && charPos != null)\n      {\n        console.log('CharSelect.tsx: swapChars',charPos,this.props.selected);\n        const srcChar = utils.charScreencodeFromRowCol(this.props.font, this.props.selected);\n        const destChar = utils.charScreencodeFromRowCol(this.props.font, charPos);\n\n        const chars = {srcChar,destChar};\n        this.props.Toolbar.swapChars(chars);\n\n      }\n\n\n\n    }\n\n\n    this.props.Toolbar.setCurrentChar(charPos)\n\n\n    switch (this.props.selectedTool)\n    {\n      case Tool.Draw:\n      case Tool.Colorize:\n      case Tool.FloodFill:\n      case Tool.CharDraw:\n      break;\n\n      default:\n        this.props.Toolbar.setSelectedTool(Tool.Draw);\n        break;\n\n    }\n\n  }\n\n  render () {\n    const { colorPalette } = this.props\n    // Editor needs to specify a fixed width/height because the contents use\n    // relative/absolute positioning and thus seem to break out of the CSS\n    // grid.\n    const { scaleX, scaleY } = this.props.canvasScale\n    const w = `${Math.floor(scaleX*8*16+scaleX*16)}px`\n    const h = `${Math.floor(scaleY*8*17+scaleY*17)}px`\n\n\n    let backg = utils.colorIndexToCssRgb(colorPalette, this.props.backgroundColor)\n\n    if(this.props.backgroundColor==this.props.textColor)\n    {\n      if(this.props.backgroundColor==0){\n        backg = \"rgba(25,25,25,.1)\";\n      }\n      else{\n      backg = backg.replace('rgb','rgba')+\",.8)\"\n      }\n    }\n    else\n    {\n      backg = backg.replace('rgb','rgba')+\",1)\"\n    }\n\n\n\n\n    const s = {width: w, height:h}\n    if (this.prevTextColor !== this.props.textColor ||\n      this.font !== this.props.font) {\n      this.computeCachedFb(this.props.textColor)\n    }\n    if (!this.fb) {\n      throw new Error('FB cannot be null here');\n    }\n    return (\n\n      <CharSelectView\n        canvasScale={this.props.canvasScale}\n        backgroundColor={backg}\n        style={s}\n        fb={this.fb}\n        charset={this.props.charset}\n        font={this.props.font}\n        customFonts={this.props.customFonts}\n        colorPalette={colorPalette}\n        selected={this.props.selected!}\n        onCharSelected={this.handleClick}\n        setCharset={this.props.Framebuffer.setCharset}\n        textColor={this.props.textColor}\n      />\n    )\n  }\n}\n\nconst mapDispatchToProps = (dispatch: Dispatch) => {\n  return {\n    Framebuffer: bindActionCreators(framebuffer.actions, dispatch),\n    Toolbar: Toolbar.bindDispatch(dispatch)\n  }\n}\n\nconst mapStateToProps = (state: RootState) => {\n  const framebuf = selectors.getCurrentFramebuf(state)\n  const { charset, font } = selectors.getCurrentFramebufFont(state)\n  const selected =\n    selectors.getCharRowColWithTransform(\n      state.toolbar.selectedChar,\n      font,\n      state.toolbar.charTransform\n    );\n  return {\n    framebufIndex: screensSelectors.getCurrentScreenFramebufIndex(state),\n    backgroundColor: framebuf ? framebuf.backgroundColor : framebuffer.DEFAULT_BACKGROUND_COLOR,\n    selected,\n    textColor: state.toolbar.textColor,\n    selectedTool: state.toolbar.selectedTool,\n    ctrlKey:state.toolbar.ctrlKey,\n    charset,\n    font,\n    customFonts: selectors.getCustomFonts(state),\n    colorPalette: getSettingsCurrentColorPalette(state)\n  }\n}\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps,\n  framebufIndexMergeProps\n)(CharSelect)\n","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\components\\ColorPicker.tsx",[],"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\components\\CharGrid.tsx",["349"],"\nimport React, { Component } from 'react';\nimport { Rgb, Font, Pixel, Coord2 } from '../redux/types';\nimport * as selectors from '../redux/selectors'\n\nclass CharsetCache {\n  private images: ImageData[][] = Array(17);\n\n  constructor (\n    ctx: CanvasRenderingContext2D,\n    fontBits: number[],\n    colorPalette: Rgb[],\n    isTransparent: boolean,\n    isDirart:boolean,\n  ) {\n    const data = fontBits\n\n    if(isTransparent==null)\n      isTransparent=false;\n\n\n\n    const dirartChars = [34,128,141,148,160,161,162,163,164,165,166,167,168,169,170,171,172,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,205,\n    224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255]\n\n    for (let colorIdx = 0; colorIdx < 16; colorIdx++) {\n      const color = colorPalette[colorIdx]\n      this.images[colorIdx] = []\n\n      for (let c = 0; c < 272; c++) {\n        const boffs = c*8;\n\n        let dstIdx = 0\n        let img = ctx.createImageData(8, 8);\n\n        let bits = img.data\n\n\n        if(c==256 && isTransparent)\n        {\n          for (let y = 0; y < 8; y++) {\n            const p = data[boffs+y]\n            for (let i = 0; i < 8; i++) {\n              const v = ((128 >> i) & p) ? 255 : 0\n              bits[dstIdx+0] = 0\n              bits[dstIdx+1] = 0\n              bits[dstIdx+2] = 0\n              bits[dstIdx+3] = 0\n              dstIdx += 4\n            }\n          }\n\n        }\n\n\n        if(isDirart && dirartChars.includes(c))\n        {\n          for (let y = 0; y < 8; y++) {\n            const p = data[boffs+y]\n            for (let i = 0; i < 8; i++) {\n              const v = ((128 >> i) & p) ? 255 : 0\n              bits[dstIdx+0] = 255\n              bits[dstIdx+1] = 64\n              bits[dstIdx+2] = 64\n              bits[dstIdx+3] = v<64 ? 64 : v\n              dstIdx += 4\n            }\n          }\n\n        }\n\n\n\nelse{\n        for (let y = 0; y < 8; y++) {\n          const p = data[boffs+y]\n          for (let i = 0; i < 8; i++) {\n            const v = ((128 >> i) & p) ? 255 : 0\n            bits[dstIdx+0] = color.r\n            bits[dstIdx+1] = color.g\n            bits[dstIdx+2] = color.b\n            bits[dstIdx+3] = v\n            dstIdx += 4\n          }\n        }\n      }\n\n        this.images[colorIdx].push(img)\n      }\n    }\n  }\n\n  getImage(screencode: number, color: number) {\n    return this.images[color][screencode]\n  }\n}\n\ninterface CharGridProps {\n  width: number;\n  height: number;\n  srcX: number;\n  srcY: number;\n  charPos: Coord2;\n  curScreencode?: number;\n  textColor?: number;\n  backgroundColor: string;\n  borderColor: string;\n  grid: boolean;\n  colorPalette: Rgb[];\n  font: Font;\n  framebuf: Pixel[][];\n  borderWidth: number;\n  borderOn: boolean;\n  isTransparent: boolean;\n  isDirart:boolean;\n}\n\nexport default class CharGrid extends Component<CharGridProps> {\n  static defaultProps = {\n    srcX: 0,\n    srcY: 0,\n    charPos: null,\n    borderWidth: 0,\n    borderColor: '#fff',\n    borderOn: false,\n    isTransparent: false,\n    isDirart:false,\n  }\n\n  private font: CharsetCache | null = null;\n  private canvasRef = React.createRef<HTMLCanvasElement>();\n\n  componentDidMount() {\n    this.draw()\n  }\n\n  componentDidUpdate (prevProps: Readonly<CharGridProps>) {\n    if (this.props.width !== prevProps.width ||\n      this.props.height !== prevProps.height ||\n      this.props.srcX !== prevProps.srcX ||\n      this.props.srcY !== prevProps.srcY ||\n      this.props.framebuf !== prevProps.framebuf ||\n      this.props.charPos !== prevProps.charPos ||\n      this.props.curScreencode !== prevProps.curScreencode ||\n      this.props.textColor !== prevProps.textColor ||\n      this.props.backgroundColor !== prevProps.backgroundColor ||\n      this.props.font !== prevProps.font ||\n      this.props.colorPalette !== prevProps.colorPalette) {\n      this.draw(prevProps)\n    }\n  }\n\n  draw (prevProps?: CharGridProps) {\n    const canvas = this.canvasRef.current\n    if (!canvas) {\n      return;\n    }\n    const ctx = canvas.getContext(\"2d\")!\n    const framebuf = this.props.framebuf\n    let invalidate = false\n    if (this.font === null ||\n      this.props.font !== prevProps!.font ||\n      this.props.colorPalette !== prevProps!.colorPalette) {\n      this.font = new CharsetCache(ctx, this.props.font.bits, this.props.colorPalette, this.props.isTransparent, this.props.isDirart)\n      invalidate = true\n    }\n\n    const { grid, srcX, srcY } = this.props\n\n    const xScale = grid ? 9 : 8\n    const yScale = grid ? 9 : 8\n\n\n\n    const dstSrcChanged =\n      prevProps !== undefined ?\n        (this.props.width !== prevProps.width ||\n         this.props.height !== prevProps.height ||\n         this.props.srcX !== prevProps.srcX ||\n         this.props.srcY !== prevProps.srcY ||\n         invalidate)\n        :\n        true\n    for (var y = 0; y < this.props.height; y++) {\n      const charRow = framebuf[y + srcY]\n      if (!dstSrcChanged && charRow === prevProps!.framebuf[y + srcY]) {\n        continue\n      }\n      for (var x = 0; x < this.props.width; x++) {\n        const c = charRow[x + srcX]\n        const img = this.font.getImage(c.code, c.color)\n\n        ctx.putImageData(img, Math.trunc(x*xScale), Math.trunc(y*yScale))\n\n      }\n    }\n\n    // Delete previous char highlighter\n    if (prevProps !== undefined && prevProps.charPos !== null) {\n      const charPos = prevProps.charPos\n      if (charPos.row >= 0 && charPos.row < this.props.height &&\n          charPos.col >= 0 && charPos.col < this.props.width) {\n        const c = framebuf[charPos.row][charPos.col]\n        const img = this.font.getImage(c.code, c.color)\n        ctx.putImageData(img, Math.trunc(charPos.col*xScale), Math.trunc(charPos.row*yScale))\n      }\n    }\n    // Render current char highlighter\n    if (this.props.charPos !== null) {\n      const charPos = this.props.charPos\n      if (charPos.row >= 0 && charPos.row < this.props.height &&\n          charPos.col >= 0 && charPos.col < this.props.width) {\n        const c = {\n          code: this.props.curScreencode !== undefined ?\n            this.props.curScreencode :\n            framebuf[charPos.row][charPos.col].code,\n          color: this.props.textColor !== undefined ?\n            this.props.textColor :\n            framebuf[charPos.row][charPos.col].color\n        }\n        const img = this.font.getImage(c.code, c.color)\n        ctx.putImageData(img, Math.trunc(charPos.col*xScale), Math.trunc(charPos.row*yScale))\n      }\n    }\n\n    if (grid) {\n      ctx.fillStyle = 'rgb(0,0,0,255)'\n      for (var y = 0; y < this.props.height; y++) {\n        ctx.fillRect(0, Math.trunc(y*yScale+8), Math.trunc(this.props.width*xScale), 1)\n      }\n      for (var x = 0; x < this.props.width; x++) {\n        ctx.fillRect(Math.trunc(x*xScale+8), 0, 1, Math.trunc(this.props.height*yScale))\n        ctx.fillRect(Math.trunc(x*xScale+8), 0, 1, Math.trunc(this.props.height*yScale))\n      }\n    }\n\n  }\n\n  render () {\n\n\n    const scale = this.props.grid ? 9 : 8\n    return (\n      <canvas\n        ref={this.canvasRef}\n        style={{\n\n         backgroundColor: this.props.backgroundColor,\n          position: 'absolute',\n          top: '0px',\n          left: '0px',\n          width: `${Math.trunc(this.props.width*scale)}px`,\n          height: `${Math.trunc(this.props.height*scale)}px`,\n          border: `${this.props.borderWidth*Number(this.props.borderOn)}px solid ${this.props.borderColor}`,\n\n\n        }}\n        width={Math.trunc(this.props.width*scale)}\n        height={Math.trunc(this.props.height*scale)}>\n      </canvas>\n    )\n  }\n}\n","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\components\\GridOverlay.tsx",[],"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\components\\FontSelector.tsx",[],"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\components\\Statusbar.tsx",["350"],"import React, { PureComponent } from \"react\";\nimport PropTypes from \"prop-types\";\n\nimport { Framebuf, Coord2 } from \"../redux/types\";\n\n\n\n\nconst FixedWidthCoord = (props: {\n  axis: string;\n  number: number | string | null;\n  numberPixelWidth?: number;\n}) => {\n  const { axis, number, numberPixelWidth = 50 } = props;\n  return (\n    <div style={{ display: \"flex\", flexDirection: \"row\" }}>\n      <div style={{ color: \"var(--main-text-darker-color)\" }}>{axis}:</div>\n      <div\n        style={{\n          width: `${numberPixelWidth}px`,\n          color: \"var(--main-text-color)\",\n        }}\n      >\n        {number}\n      </div>\n    </div>\n  );\n};\n\nfunction formatScreencode(num: number | null) {\n  return num !== null ? `$${num.toString(16).toUpperCase()}/${num}` : null;\n}\nfunction formatPetsciicode(num: number | null) {\n\n    let byte_char = num!;\n  if ((byte_char >= 0) && (byte_char <= 0x1f)) {\n    byte_char = byte_char + 0x40;\n  }\n  else\n  {\n      if ((byte_char >= 0x40) && (byte_char <= 0x5d))\n      {\n        byte_char = byte_char + 0x80;\n      }\n      else\n      {\n          if (byte_char == 0x5e) {\n            byte_char = 0xff;\n          }\n          else\n          {\n              if (byte_char == 0x5f) {\n                byte_char = 0xdf;\n              }\n              else\n              {\n                  if (byte_char == 0x95)\n                  {\n                    byte_char = 0xdf;\n                  }\n                  else\n                  {\n                      if ((byte_char >= 0x60) && (byte_char <= 0x7f))\n                      {\n                        byte_char = byte_char + 0x40;\n                      }\n                      else\n                      {\n                          if ((byte_char >= 0x80) && (byte_char <= 0xbf))\n                          {\n                            byte_char = byte_char - 0x80;\n                          }\n                          else\n                          {\n                              if ((byte_char >= 0xc0) && (byte_char <= 0xff))\n                              {\n                                byte_char = byte_char - 0x40;\n                              }\n                          }\n                      }\n                  }\n              }\n          }\n      }\n  }\n\n\n  return byte_char !== null ? `$${byte_char.toString(16).toUpperCase()}/${byte_char}${num!>128 ? ' (RVS)' : ''}` : null;\n}\n\n\ninterface CharSelectStatusbarProps {\n  curScreencode: number | null;\n\n}\n\nexport class CharSelectStatusbar extends PureComponent<CharSelectStatusbarProps> {\n  render() {\n    const { curScreencode } = this.props;\n    return (\n      <div style={{ fontSize: \"0.8em\", display: \"flex\", flexDirection: \"row\" }}>\n        <FixedWidthCoord\n          axis=\"F\"\n          number={formatScreencode(curScreencode)}\n          numberPixelWidth={60}\n        />\n        <FixedWidthCoord\n          axis=\"P\"\n          number={formatPetsciicode(curScreencode)}\n          numberPixelWidth={90}\n        />\n      </div>\n    );\n  }\n}\n\ninterface CanvasStatusbarProps {\n  framebuf: Framebuf;\n  isActive: boolean;\n  charPos: Coord2 | null;\n  zoom: {zoomLevel:number,alignment:string},\n}\n\nexport class CanvasStatusbar extends PureComponent<CanvasStatusbarProps> {\n  static propTypes = {\n    framebuf: PropTypes.object.isRequired,\n    isActive: PropTypes.bool,\n    charPos: PropTypes.object,\n    zoom: PropTypes.object\n  };\n  render() {\n    const { isActive, charPos, framebuf } = this.props;\n    const { width, height } = framebuf;\n    const cp = isActive ? charPos : null;\n    let cc = null;\n\n    if (cp !== null) {\n      if (cp.row >= 0 && cp.row < height && cp.col >= 0 && cp.col < width) {\n        cc = framebuf.framebuf[cp.row][cp.col].code;\n      }\n    }\n    let zoomLevel = this.props.zoom.zoomLevel/.5;\n    let zoomAlignment = this.props.zoom.alignment;\n    const widthHeight = `${framebuf.width}x${framebuf.height}`;\n\n\n\n\n\n    return (\n      <div\n        style={{\n          padding: \"4px\",\n          fontSize: \"0.8em\",\n          display: \"flex\",\n          flexDirection: \"row\",\n          border: \"0px solid #eee\"\n        }}\n      >\n        <FixedWidthCoord axis=\"X\" number={cc !== null ? cp!.col : null} />\n        <FixedWidthCoord axis=\"Y\" number={cc !== null ? cp!.row : null} />\n        <FixedWidthCoord\n          axis=\"CHAR\"\n          number={formatScreencode(cc)}\n          numberPixelWidth={62}\n        />\n        <FixedWidthCoord\n          axis=\"SCRN\"\n          number={\n            cc !== null\n              ? formatScreencode(1024 + cp!.row * width + cp!.col)\n              : null\n          }\n          numberPixelWidth={140}\n        />\n        <FixedWidthCoord\n          axis=\"COLR\"\n          number={\n            cc !== null\n              ? formatScreencode(55296 + cp!.row * width + cp!.col)\n              : null\n          }\n          numberPixelWidth={140}\n        />\n\n        <FixedWidthCoord\n          axis=\"Size\"\n          number={widthHeight}\n          numberPixelWidth={70}\n        />\n\n\n\n      </div>\n    );\n  }\n}\n//<FixedWidthCoord axis=\"Zoom\" number={zoomLevel}    numberPixelWidth={40}   />\n//<FixedWidthCoord axis={'ZOOM ('+zoomAlignment+')'} number={zoomLevel} numberPixelWidth={80} />\n","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\components\\Modal.tsx",["351"],"\nimport React, { Component, Fragment } from 'react'\nimport ReactDOM from 'react-dom'\n\nimport styles from './Modal.module.css'\n\nconst modalRoot = document.getElementById('modal-root')\n\nclass ModalBase extends Component {\n  private el = document.createElement('div')\n\n  componentDidMount() {\n    // The portal element is inserted in the DOM tree after\n    // the Modal's children are mounted, meaning that children\n    // will be mounted on a detached DOM node. If a child\n    // component requires to be attached to the DOM tree\n    // immediately when mounted, for example to measure a\n    // DOM node, or uses 'autoFocus' in a descendant, add\n    // state to Modal and only render the children when Modal\n    // is inserted in the DOM tree.\n    if (modalRoot) {\n      modalRoot.appendChild(this.el)\n    }\n  }\n\n  componentWillUnmount() {\n    if (modalRoot) {\n      modalRoot.removeChild(this.el)\n    }\n  }\n\n  render() {\n    return ReactDOM.createPortal(\n      this.props.children,\n      this.el\n    )\n  }\n}\n\ninterface ModalAnimWrapperState {\n    init: boolean;\n}\nclass ModalAnimWrapper extends Component<{}, ModalAnimWrapperState> {\n  state = {\n    init: true\n  }\n\n  private ref: HTMLDivElement|null = null;\n\n  componentDidMount () {\n    // This is required to trigger the CSS animation\n    const ANIMATION_TIMEOUT = 20\n    setTimeout(() => {\n      // This is for to force a repaint,\n      // which is necessary in order to transition styles.\n      // (jjhellst: or so I think..  From https://github.com/reactjs/react-transition-group/blob/780e8e5bf62efa655a2683c216cdabd7f7a09897/src/CSSTransition.js#L210-L217)\n      /* eslint-disable @typescript-eslint/no-unused-expressions */\n      this.ref && this.ref.scrollTop\n      /* eslint-enable @typescript-eslint/no-unused-expressions */\n      this.setState({init: false})\n    }, ANIMATION_TIMEOUT)\n  }\n\n  render () {\n    return (\n      <Fragment>\n        <div ref={(r) => this.ref = r}>\n          <div\n            className={styles.modalBackground}\n            style={{\n              opacity: this.state.init ? 0.0 : 1.0,\n              transition: 'opacity 0.2s linear'\n            }}\n          />\n          <div\n            className={styles.modal}\n            style={{\n              opacity: this.state.init ? 0.0 : 1.0,\n              transform: this.state.init ? 'translate(-50%, -40%)' : 'translate(-50%, -50%)',\n              transition: 'opacity 0.2s linear, transform 0.2s linear'\n            }}>\n            {this.props.children}\n          </div>\n        </div>\n      </Fragment>\n    )\n  }\n}\n\ninterface ModalProps {\n  showModal: boolean;\n}\n\nexport default class Modal extends Component<ModalProps> {\n  modalBody = () => {\n    return (\n      <ModalAnimWrapper>\n        {this.props.children}\n      </ModalAnimWrapper>\n    )\n  }\n\n  render () {\n    return (\n      <ModalBase>\n        {this.props.showModal ? this.modalBody() : null}\n      </ModalBase>\n    )\n  }\n}\n","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\components\\CharPosOverlay.tsx",["352"],"\nimport React, { Component, CSSProperties } from 'react'\n\nimport styles from './CharPosOverlay.module.css'\nimport { Coord2 } from '../redux/types';\n\nconst charPosOverlayStyleBase: CSSProperties = {\n  position: 'absolute',\n  outlineStyle: 'solid',\n  outlineWidth: '1px',\n  backgroundColor: 'rgba(255,255,255,0)',\n  zIndex: 1,\n  pointerEvents:'none',\n  outlineOffset:'0px'\n}\n\ninterface TextCursorOverlay {\n  framebufWidth: number;\n  framebufHeight: number;\n  charPos: Coord2;\n  grid?: boolean;\n  color?: string;\n  fillColor: string;\n  opacity?: number;\n  borderOn: boolean;\n}\n\ntype CharPosOverlayProps = TextCursorOverlay & { blink: boolean };\n\nexport default class CharPosOverlay extends Component<CharPosOverlayProps> {\n  static defaultProps = {\n    blink: false,\n    fillColor: 'rgb(255,255,255)',\n    grid: false,\n    borderOn: true\n  }\n\n  render () {\n\n    const { charPos, grid, framebufWidth, framebufHeight, blink, borderOn } = this.props\n    const scale = grid ? 9 : 8\n    let borderval = Number(borderOn)*4;\n    let alpha = this.props.opacity != undefined ? this.props.opacity : 0.5;\n    alpha = .9\n    let outlineColor = `rgba(255, 255, 255, ${alpha})`\n    if (this.props.color !== undefined) {\n      outlineColor = this.props.color\n    }\n\n    if (charPos.row < 0 || charPos.row+borderval >= framebufHeight+borderval ||\n        charPos.col < 0 || charPos.col+borderval >= framebufWidth+borderval) {\n     return null\n   }\n\n\n    const s = {\n      ...charPosOverlayStyleBase,\n      outlineColor: outlineColor,\n      left: Math.trunc((charPos.col+borderval)*scale),\n      top: Math.trunc((charPos.row+borderval)*scale),\n      width: `${8}px`,\n      height: `${8}px`\n    }\n    const { fillColor } = this.props\n    return (\n      <div style={s}>\n        {blink ?\n          <div style={{\n              width:'100%', height:'100%',\n              backgroundColor: fillColor\n            }}\n            className={styles.blink}>\n          </div> :\n          null}\n      </div>\n    )\n  }\n}\n\nexport const TextCursorOverlay = (props: TextCursorOverlay) => {\n  return (\n    <CharPosOverlay {...props} blink={true} />\n  )\n}","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\redux\\framebufList.ts",["353"],"\nimport { Reducer, Action, AnyAction } from 'redux'\nimport undoable from 'redux-undo'\nimport * as framebuffer from './editor'\nimport { Framebuffer } from './editor'\nimport {\n  UndoableFramebuf,\n  Framebuf\n} from './types'\nimport { ActionsUnion, createAction } from './typeUtils'\n\nimport * as fp from '../utils/fp'\n\nconst ADD_FRAMEBUF = 'ADD_FRAMEBUF'\nconst REMOVE_FRAMEBUF = 'REMOVE_FRAMEBUF'\n\nconst actionCreators = {\n  addFramebuf: (dims: { width: number, height: number}) => createAction(ADD_FRAMEBUF, dims),\n  removeFramebuf: (index: number) => createAction(REMOVE_FRAMEBUF, index)\n};\n\nexport type Actions = ActionsUnion<typeof actionCreators>\n\nexport const actions = actionCreators;\n\ntype UndoableFbReducer = (histFb: UndoableFramebuf|undefined, action: framebuffer.Actions) => UndoableFramebuf;\n\nfunction framebufListReducer(reducer: UndoableFbReducer) {\n  return function (state: UndoableFramebuf[] = [], action: Actions|framebuffer.Actions): UndoableFramebuf[] {\n    switch (action.type) {\n    case ADD_FRAMEBUF:\n      // Add a new framebuf with desired width/height\n      const setDims = framebuffer.actions.setDims(action.data, -1);\n\n      return state.concat(reducer(undefined, setDims));\n    case REMOVE_FRAMEBUF: {\n      return fp.arrayRemoveAt(state, action.data);\n    }\n    default:\n      const framebufIndex = action.framebufIndex;\n      if (typeof framebufIndex !== 'undefined') {\n        return state.map((item, i) => {\n          if (framebufIndex === i) {\n            return reducer(item, action);\n          } else {\n            return item;\n          }\n        })\n      }\n      return state;\n    }\n  }\n}\n\nconst groupByUndoId = (action: Action<any>) => {\n  const tmpAction = action as framebuffer.Actions;\n  if (tmpAction.undoId !== undefined) {\n    return tmpAction.undoId;\n  }\n  return null;\n}\n\nconst mkReducer = () => {\n  const r = undoable(Framebuffer.reducer as Reducer<Framebuf, AnyAction>, {\n    groupBy: groupByUndoId\n  });\n  return framebufListReducer(r);\n}\n\nexport const reducer = mkReducer();\n","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\external\\react-sortable-hoc\\SortableElement\\index.js",[],"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\external\\react-sortable-hoc\\SortableContainer\\index.js",[],"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\external\\react-sortable-hoc\\SortableHandle\\index.js",[],"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\importers\\cbase2petscii.ts",[],"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\importers\\seq2petscii.ts",[],"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\importers\\d64.ts",[],"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\exporters\\basic.ts",[],"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\exporters\\gif.ts",[],"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\exporters\\asm.ts",["354"],"\nimport { chunkArray } from '../../utils'\n\nimport { fs } from '../electronImports'\nimport { CHARSET_UPPER, CHARSET_LOWER } from '../../redux/editor';\nimport { FileFormatAsm, FramebufWithFont } from  '../../redux/types';\nimport * as fp from '../fp'\n\ninterface InitCodeParams {\n  borderColor: number;\n  backgroundColor: number;\n  charsetBits: string;\n  label: string;\n}\n\nconst syntaxes: { [index: string]: { cli: string, comment: string, byte: string, label: string } } = {\n  'kickass': {\n    cli: '; java -jar KickAss.jar foo.asm -o foo.prg',\n    comment: '//',\n    byte: '.byte',\n    label: ':'\n  },\n  'acme': {\n    cli: '; acme --cpu 6510 --format cbm --outfile foo.prg foo.asm',\n    comment: ';',\n    byte: '!byte',\n    label: ' '\n  },\n  'c64tass': {\n    cli: '; 64tass -C -a --cbm-prg foo.asm -o foo.prg',\n    comment: ';',\n    byte: '.byte',\n    label: ' '\n  },\n  'c64jasm': {\n    cli: '; c64jasm foo.asm --out foo.prg',\n    comment: ';',\n    byte: '!byte',\n    label: ':'\n  },\n  'ca65': {\n    cli: '',\n    comment: ';',\n    byte: '.byte',\n    label: ':'\n  },\n};\n\nconst binaryFormatHelp = `\n; PETSCII memory layout (example for a 40x25 screen)'\n; byte  0         = border color'\n; byte  1         = background color'\n; bytes 2-1001    = screencodes'\n; bytes 1002-2001 = color\n`;\n\n// Written in\nconst initCode = ({\n  charsetBits,\n  label\n}: InitCodeParams) => `\n* = $0801          ; BASIC start address (#2049)\n!byte $0C, $08, $00, $00, $9E, $32, $30, $36\n!byte $31, $00, $00, $00\n\nstart:\n    lda ${label}\n    sta $d020\n    lda ${label}+1\n    sta $d021\n    lda #${charsetBits}\n    sta $d018\n\n    ldx #$00\nloop:\n    lda ${label}+2,x\n    sta $0400,x\n    lda ${label}+$3ea,x\n    sta $d800,x\n\n    lda ${label}+$102,x\n    sta $0500,x\n    lda ${label}+$4ea,x\n    sta $d900,x\n\n    lda ${label}+$202,x\n    sta $0600,x\n    lda ${label}+$5ea,x\n    sta $da00,x\n\n    lda ${label}+$2ea,x\n    sta $06e8,x\n    lda ${label}+$6d2,x\n    sta $dae8,x\n    inx\n    bne loop\n    jmp *\n`;\n\nfunction toHex8(v: number): string {\n  return `${v.toString(16).toUpperCase().padStart(2, '0')}`\n}\n\nfunction bytesToCommaDelimited(dstLines: string[], bytes: number[], bytesPerLine: number, hex: boolean) {\n  let lines = chunkArray(bytes, bytesPerLine)\n  for (let i = 0; i < lines.length; i++) {\n    const nums = lines[i].map(n => hex ? `$${toHex8(n)}` : `${n}`);\n    dstLines.push(`!byte ${nums.join(',')}`);\n  }\n}\n\nfunction maybeLabelName(name: string | undefined) {\n  return fp.maybeDefault(name, 'untitled' as string);\n}\n\nfunction convertToAsm(lines: string[], fb: FramebufWithFont, hex: boolean) {\n  const { width, height, framebuf, backgroundColor, borderColor, name } = fb;\n\n  lines.push(`${maybeLabelName(name)}:`);\n\n  let bytes = [];\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      bytes.push(framebuf[y][x].code);\n    }\n  }\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      bytes.push(framebuf[y][x].color);\n    }\n  }\n  lines.push(`!byte ${borderColor},${backgroundColor}`);\n  bytesToCommaDelimited(lines, bytes, width, hex);\n\n  // Save font bits\n  if (fb.charset !== CHARSET_UPPER && fb.charset !== CHARSET_LOWER) {\n    lines.push('', `* = $3000`);\n    lines.push(`${maybeLabelName(name)}_font:`);\n    bytesToCommaDelimited(lines, fb.font.bits, 16, hex);\n  }\n}\n\nfunction convertSyntax(asm: string, syntax: typeof syntaxes['c64jasm']) {\n  function convertLine(line: string) {\n    let m;\n    if (m = /^!byte (.*)/.exec(line)) {\n      return `${syntax.byte} ${m[1]}`;\n    }\n    if (m = /^([^;]*); (.*)/.exec(line)) {\n      return `${m[1]}${syntax.comment} ${m[2]}`;\n    }\n    if (m = /^([a-zA-Z_]+[a-zA-Z_0-9]*):(.*)/.exec(line)) {\n      return `${m[1]}${syntax.label}${m[2]}`;\n    }\n    return line;\n  }\n  const lines = asm.split('\\n');\n  return lines.map(convertLine).join('\\n');\n}\n\nexport function genAsm(fbs: FramebufWithFont[], fmt: FileFormatAsm) {\n  const options = fmt.exportOptions;\n  let lines: string[] = [];\n  // Single screen export?\n  const hexOutput = fmt.exportOptions.hex;\n  const selectedFb = fbs[fmt.commonExportParams.selectedFramebufIndex];\n  if (fmt.exportOptions.currentScreenOnly) {\n    convertToAsm(lines, selectedFb, hexOutput);\n  } else {\n    fbs.forEach((fb) => convertToAsm(lines, fb, hexOutput));\n  }\n  let backgroundColor = selectedFb.backgroundColor;\n  let borderColor = selectedFb.borderColor;\n  const label = maybeLabelName(selectedFb.name);\n  let charsetBits;\n  switch(selectedFb.charset) {\n    case 'upper': charsetBits = \"$15\"; break;\n    case 'lower': charsetBits = \"$17\"; break;\n    default:      charsetBits = `%00010000 | ((${label}_font/2048)*2)`; break;\n  }\n  const syntax = syntaxes[fmt.exportOptions.assembler];\n  const init = options.standalone ? `${syntax.cli}\\n${initCode({ backgroundColor, borderColor, charsetBits, label })}` : '';\n  return convertSyntax(init + '\\n' + binaryFormatHelp + '\\n' + lines.join('\\n') + '\\n', syntax);\n}\n\nconst saveAsm = (filename: string, fbs: FramebufWithFont[], fmt: FileFormatAsm) => {\n  try {\n    const src = genAsm(fbs, fmt);\n    fs.writeFileSync(filename, src, null);\n  } catch(e) {\n    alert(`Failed to save file '${filename}'!`);\n    console.error(e);\n  }\n}\n\nexport { saveAsm }\n","C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\exporters\\seq.ts",[],"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\exporters\\png.ts",[],"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\exporters\\json.ts",[],"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\exporters\\d64.ts",[],"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\exporters\\player.ts",["355"],"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\exporters\\pet.ts",[],"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\exporters\\cbase.ts",[],"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\external\\react-sortable-hoc\\Manager.js",[],"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\x1541.ts",[],"C:\\C64\\Projects\\_Petmate\\petmate9\\src\\utils\\exporters\\util.ts",[],{"ruleId":null,"fatal":true,"severity":2,"message":"356","line":48,"column":35},{"ruleId":null,"fatal":true,"severity":2,"message":"357","line":48,"column":89},{"ruleId":null,"fatal":true,"severity":2,"message":"358","line":27,"column":12},{"ruleId":null,"fatal":true,"severity":2,"message":"359","line":56,"column":122},{"ruleId":null,"fatal":true,"severity":2,"message":"360","line":264,"column":47},{"ruleId":null,"fatal":true,"severity":2,"message":"361","line":4,"column":28},{"ruleId":null,"fatal":true,"severity":2,"message":"362","line":44,"column":37},{"ruleId":null,"fatal":true,"severity":2,"message":"363","line":227,"column":38},{"ruleId":null,"fatal":true,"severity":2,"message":"364","line":4,"column":16},{"ruleId":null,"fatal":true,"severity":2,"message":"365","line":44,"column":11},{"ruleId":null,"fatal":true,"severity":2,"message":"366","line":56,"column":33},{"ruleId":null,"fatal":true,"severity":2,"message":"367","line":14,"column":110},{"ruleId":null,"fatal":true,"severity":2,"message":"368","line":96,"column":41},{"ruleId":null,"fatal":true,"severity":2,"message":"369","line":95,"column":26},{"ruleId":null,"fatal":true,"severity":2,"message":"370","line":142,"column":20},{"ruleId":null,"fatal":true,"severity":2,"message":"371","line":432,"column":14},{"ruleId":null,"fatal":true,"severity":2,"message":"372","line":85,"column":31},{"ruleId":null,"fatal":true,"severity":2,"message":"373","line":465,"column":41},{"ruleId":null,"fatal":true,"severity":2,"message":"374","line":47,"column":43},{"ruleId":null,"fatal":true,"severity":2,"message":"375","line":4,"column":41},{"ruleId":null,"fatal":true,"severity":2,"message":"376","line":16,"column":11},{"ruleId":null,"fatal":true,"severity":2,"message":"377","line":167,"column":31},{"ruleId":null,"fatal":true,"severity":2,"message":"378","line":7,"column":11},{"ruleId":null,"fatal":true,"severity":2,"message":"379","line":35,"column":24},{"ruleId":null,"fatal":true,"severity":2,"message":"380","line":10,"column":11},{"ruleId":null,"fatal":true,"severity":2,"message":"381","line":80,"column":14},{"ruleId":null,"fatal":true,"severity":2,"message":"382","line":56,"column":27},{"ruleId":null,"fatal":true,"severity":2,"message":"383","line":113,"column":43},{"ruleId":null,"fatal":true,"severity":2,"message":"384","line":113,"column":43},"Parsing error: Unexpected token, expected \",\"\n\n\u001b[0m \u001b[90m 46 |\u001b[39m   \u001b[36mreturn\u001b[39m {\n \u001b[90m 47 |\u001b[39m     \u001b[33m...\u001b[39mtransform\u001b[33m,\u001b[39m\n\u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 48 |\u001b[39m     rotate\u001b[33m:\u001b[39m ((newRotation) \u001b[33m%\u001b[39m \u001b[35m360\u001b[39m) \u001b[36mas\u001b[39m \u001b[33mAngle360\u001b[39m\n \u001b[90m    |\u001b[39m                                   \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n \u001b[90m 49 |\u001b[39m   }\n \u001b[90m 50 |\u001b[39m }\n \u001b[90m 51 |\u001b[39m\u001b[0m","Parsing error: Missing semicolon.\n\n\u001b[0m \u001b[90m 46 |\u001b[39m     \u001b[36mconst\u001b[39m state \u001b[33m=\u001b[39m getState()\u001b[33m;\u001b[39m\n \u001b[90m 47 |\u001b[39m     \u001b[36mconst\u001b[39m screens \u001b[33m=\u001b[39m screensSelectors\u001b[33m.\u001b[39mgetScreens(state)\u001b[33m;\u001b[39m\n\u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 48 |\u001b[39m     \u001b[36mconst\u001b[39m getFramebufByIndex \u001b[33m=\u001b[39m (idx\u001b[33m:\u001b[39m number) \u001b[33m=>\u001b[39m selectors\u001b[33m.\u001b[39mgetFramebufByIndex(state\u001b[33m,\u001b[39m idx)\u001b[33m!\u001b[39m\u001b[33m;\u001b[39m\n \u001b[90m    |\u001b[39m                                                                                         \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n \u001b[90m 49 |\u001b[39m     \u001b[36mconst\u001b[39m customFontMap \u001b[33m=\u001b[39m selectors\u001b[33m.\u001b[39mgetCustomFonts(state)\u001b[33m;\u001b[39m\n \u001b[90m 50 |\u001b[39m     dialogSaveAsWorkspace(\n \u001b[90m 51 |\u001b[39m       screens\u001b[33m,\u001b[39m\u001b[0m","Parsing error: Unexpected token, expected \":\"\n\n\u001b[0m \u001b[90m 25 |\u001b[39m\n \u001b[90m 26 |\u001b[39m \u001b[36mexport\u001b[39m \u001b[36minterface\u001b[39m \u001b[33mFramebuf\u001b[39m {\n\u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 27 |\u001b[39m   readonly framebuf\u001b[33m:\u001b[39m \u001b[33mPixel\u001b[39m[][]\u001b[33m;\u001b[39m\n \u001b[90m    |\u001b[39m            \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n \u001b[90m 28 |\u001b[39m   readonly width\u001b[33m:\u001b[39m number\u001b[33m;\u001b[39m\n \u001b[90m 29 |\u001b[39m   readonly height\u001b[33m:\u001b[39m number\u001b[33m;\u001b[39m\n \u001b[90m 30 |\u001b[39m   readonly backgroundColor\u001b[33m:\u001b[39m number\u001b[33m;\u001b[39m\u001b[0m","Parsing error: Unexpected token, expected \",\"\n\n\u001b[0m \u001b[90m 54 |\u001b[39m\n \u001b[90m 55 |\u001b[39m \u001b[36mconst\u001b[39m actionCreators \u001b[33m=\u001b[39m {\n\u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 56 |\u001b[39m   addScreen\u001b[33m:\u001b[39m (framebufId\u001b[33m:\u001b[39m number\u001b[33m,\u001b[39m insertAfterIndex\u001b[33m:\u001b[39m number) \u001b[33m=>\u001b[39m createAction(\u001b[33mADD_SCREEN\u001b[39m\u001b[33m,\u001b[39m { framebufId\u001b[33m,\u001b[39m insertAfterIndex } \u001b[36mas\u001b[39m \u001b[33mAddScreenArgs\u001b[39m)\u001b[33m,\u001b[39m\n \u001b[90m    |\u001b[39m                                                                                                                          \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n \u001b[90m 57 |\u001b[39m   addScreenAndFramebuf\u001b[33m:\u001b[39m (insertAfterIndex\u001b[33m?\u001b[39m\u001b[33m:\u001b[39m number) \u001b[33m=>\u001b[39m createAction(\u001b[33mADD_SCREEN_AND_FRAMEBUF\u001b[39m\u001b[33m,\u001b[39m insertAfterIndex)\u001b[33m,\u001b[39m\n \u001b[90m 58 |\u001b[39m   removeScreenAction\u001b[33m:\u001b[39m (index\u001b[33m:\u001b[39m number) \u001b[33m=>\u001b[39m createAction(\u001b[33mREMOVE_SCREEN\u001b[39m\u001b[33m,\u001b[39m index)\u001b[33m,\u001b[39m\n \u001b[90m 59 |\u001b[39m   moveScreen\u001b[33m:\u001b[39m (dir\u001b[33m:\u001b[39m number) \u001b[33m=>\u001b[39m createAction(\u001b[33mMOVE_SCREEN\u001b[39m\u001b[33m,\u001b[39m dir)\u001b[33m,\u001b[39m\u001b[0m","Parsing error: Unexpected token, expected \",\"\n\n\u001b[0m \u001b[90m 262 |\u001b[39m     \u001b[36mreturn\u001b[39m saveD64(filename\u001b[33m,\u001b[39m selectedFramebuf\u001b[33m,\u001b[39mfonts\u001b[33m,\u001b[39m fmt)\u001b[33m;\u001b[39m\n \u001b[90m 263 |\u001b[39m   } \u001b[36melse\u001b[39m \u001b[36mif\u001b[39m (fmt\u001b[33m.\u001b[39mext \u001b[33m===\u001b[39m \u001b[32m'prg'\u001b[39m \u001b[33m&&\u001b[39m fmt\u001b[33m.\u001b[39mname \u001b[33m===\u001b[39m\u001b[32m'cbaseFile'\u001b[39m) {\n\u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 264 |\u001b[39m     \u001b[36mreturn\u001b[39m saveCbase(filename\u001b[33m,\u001b[39m framebufs\u001b[33m,\u001b[39m fmt \u001b[36mas\u001b[39m \u001b[33mFileFormatCbase\u001b[39m)\u001b[33m;\u001b[39m\n \u001b[90m     |\u001b[39m                                               \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n \u001b[90m 265 |\u001b[39m   }\u001b[36melse\u001b[39m \u001b[36mif\u001b[39m (fmt\u001b[33m.\u001b[39mext \u001b[33m===\u001b[39m \u001b[32m'prg'\u001b[39m \u001b[33m&&\u001b[39m fmt\u001b[33m.\u001b[39mname \u001b[33m===\u001b[39m\u001b[32m'prgPlayer'\u001b[39m) {\n \u001b[90m 266 |\u001b[39m     \u001b[36mreturn\u001b[39m savePlayer(filename\u001b[33m,\u001b[39m framebufs\u001b[33m,\u001b[39m fmt)\u001b[33m;\u001b[39m\n \u001b[90m 267 |\u001b[39m   }\u001b[0m","Parsing error: Unexpected token, expected \",\"\n\n\u001b[0m \u001b[90m 2 |\u001b[39m \u001b[36mimport\u001b[39m { \u001b[33mAction\u001b[39m } \u001b[36mfrom\u001b[39m \u001b[32m'redux'\u001b[39m\n \u001b[90m 3 |\u001b[39m\n\u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 4 |\u001b[39m \u001b[36minterface\u001b[39m \u001b[33mActionWithData\u001b[39m\u001b[33m<\u001b[39m\u001b[33mT\u001b[39m \u001b[36mextends\u001b[39m string\u001b[33m,\u001b[39m \u001b[33mD\u001b[39m\u001b[33m>\u001b[39m \u001b[36mextends\u001b[39m \u001b[33mAction\u001b[39m\u001b[33m<\u001b[39m\u001b[33mT\u001b[39m\u001b[33m>\u001b[39m {\n \u001b[90m   |\u001b[39m                            \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n \u001b[90m 5 |\u001b[39m   data\u001b[33m:\u001b[39m \u001b[33mD\u001b[39m\u001b[33m;\u001b[39m\n \u001b[90m 6 |\u001b[39m }\n \u001b[90m 7 |\u001b[39m\u001b[0m","Parsing error: Unexpected token, expected \",\"\n\n\u001b[0m \u001b[90m 42 |\u001b[39m\n \u001b[90m 43 |\u001b[39m\n\u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 44 |\u001b[39m \u001b[36mexport\u001b[39m \u001b[36minterface\u001b[39m \u001b[33mFbActionWithData\u001b[39m\u001b[33m<\u001b[39m\u001b[33mT\u001b[39m \u001b[36mextends\u001b[39m string\u001b[33m,\u001b[39m \u001b[33mD\u001b[39m\u001b[33m>\u001b[39m \u001b[36mextends\u001b[39m \u001b[33mAction\u001b[39m\u001b[33m<\u001b[39m\u001b[33mT\u001b[39m\u001b[33m>\u001b[39m {\n \u001b[90m    |\u001b[39m                                     \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n \u001b[90m 45 |\u001b[39m   data\u001b[33m:\u001b[39m \u001b[33mD\u001b[39m\u001b[33m;\u001b[39m\n \u001b[90m 46 |\u001b[39m   undoId\u001b[33m:\u001b[39m number \u001b[33m|\u001b[39m \u001b[36mnull\u001b[39m\u001b[33m;\u001b[39m\n \u001b[90m 47 |\u001b[39m   framebufIndex\u001b[33m:\u001b[39m number \u001b[33m|\u001b[39m \u001b[36mnull\u001b[39m\u001b[33m;\u001b[39m\u001b[0m","Parsing error: Unexpected token, expected \",\"\n\n\u001b[0m \u001b[90m 225 |\u001b[39m \u001b[36mconst\u001b[39m computeScreencodeWithTransform \u001b[33m=\u001b[39m (rowcol\u001b[33m:\u001b[39m \u001b[33mCoord2\u001b[39m\u001b[33m,\u001b[39m font\u001b[33m:\u001b[39m \u001b[33mFont\u001b[39m\u001b[33m,\u001b[39m transform\u001b[33m:\u001b[39m \u001b[33mTransform\u001b[39m) \u001b[33m=>\u001b[39m {\n \u001b[90m 226 |\u001b[39m   \u001b[36mconst\u001b[39m sc \u001b[33m=\u001b[39m charScreencodeFromRowCol(font\u001b[33m,\u001b[39m rowcol)\n\u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 227 |\u001b[39m   \u001b[36mreturn\u001b[39m findTransformedChar(font\u001b[33m,\u001b[39m sc\u001b[33m!\u001b[39m\u001b[33m,\u001b[39m transform)\n \u001b[90m     |\u001b[39m                                      \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n \u001b[90m 228 |\u001b[39m }\n \u001b[90m 229 |\u001b[39m \u001b[36mconst\u001b[39m computeScreencodeWithTransformMemoized \u001b[33m=\u001b[39m memoize(computeScreencodeWithTransform)\n \u001b[90m 230 |\u001b[39m \u001b[36mexport\u001b[39m \u001b[36mconst\u001b[39m getScreencodeWithTransform \u001b[33m=\u001b[39m (rowcol\u001b[33m:\u001b[39m \u001b[33mCoord2\u001b[39m\u001b[33m,\u001b[39m font\u001b[33m:\u001b[39m \u001b[33mFont\u001b[39m\u001b[33m,\u001b[39m transform\u001b[33m:\u001b[39m \u001b[33mTransform\u001b[39m) \u001b[33m=>\u001b[39m {\u001b[0m","Parsing error: Missing semicolon.\n\n\u001b[0m \u001b[90m 2 |\u001b[39m\n \u001b[90m 3 |\u001b[39m \u001b[36mfunction\u001b[39m copyVec3(v\u001b[33m:\u001b[39m \u001b[33mVec3\u001b[39m)\u001b[33m:\u001b[39m \u001b[33mVec3\u001b[39m {\n\u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 4 |\u001b[39m   \u001b[36mreturn\u001b[39m [\u001b[33m...\u001b[39mv] \u001b[36mas\u001b[39m \u001b[33mVec3\u001b[39m\u001b[33m;\u001b[39m\n \u001b[90m   |\u001b[39m                \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n \u001b[90m 5 |\u001b[39m }\n \u001b[90m 6 |\u001b[39m\n \u001b[90m 7 |\u001b[39m \u001b[36mexport\u001b[39m \u001b[36minterface\u001b[39m \u001b[33mMatrix3x3\u001b[39m {\u001b[0m","Parsing error: Unexpected token\n\n\u001b[0m \u001b[90m 42 |\u001b[39m \u001b[36mclass\u001b[39m \u001b[33mDivSize\u001b[39m \u001b[36mextends\u001b[39m \u001b[33mComponent\u001b[39m\u001b[33m<\u001b[39m\u001b[33mDivSizeProps\u001b[39m\u001b[33m,\u001b[39m \u001b[33mDivSizeState\u001b[39m\u001b[33m>\u001b[39m {\n \u001b[90m 43 |\u001b[39m\n\u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 44 |\u001b[39m   \u001b[36mprivate\u001b[39m ref \u001b[33m=\u001b[39m \u001b[33mReact\u001b[39m\u001b[33m.\u001b[39mcreateRef\u001b[33m<\u001b[39m\u001b[33mHTMLDivElement\u001b[39m\u001b[33m>\u001b[39m()\u001b[33m;\u001b[39m\n \u001b[90m    |\u001b[39m           \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n \u001b[90m 45 |\u001b[39m   \u001b[36mprivate\u001b[39m ro\u001b[33m:\u001b[39m \u001b[33mResizeObserver\u001b[39m \u001b[33m|\u001b[39m \u001b[36mnull\u001b[39m \u001b[33m=\u001b[39m \u001b[36mnull\u001b[39m\u001b[33m;\u001b[39m\n \u001b[90m 46 |\u001b[39m   state \u001b[33m=\u001b[39m {\n \u001b[90m 47 |\u001b[39m     containerSize\u001b[33m:\u001b[39m \u001b[36mnull\u001b[39m\u001b[0m","Parsing error: Unexpected token, expected \"]\"\n\n\u001b[0m \u001b[90m 54 |\u001b[39m ]\u001b[33m;\u001b[39m\n \u001b[90m 55 |\u001b[39m\n\u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 56 |\u001b[39m \u001b[36mexport\u001b[39m \u001b[36mconst\u001b[39m colorPalettes\u001b[33m:\u001b[39m {[k \u001b[36min\u001b[39m \u001b[33mPaletteName\u001b[39m]\u001b[33m:\u001b[39m \u001b[33mRgb\u001b[39m[]} \u001b[33m=\u001b[39m {\n \u001b[90m    |\u001b[39m                                 \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n \u001b[90m 57 |\u001b[39m   \u001b[32m'petmate'\u001b[39m\u001b[33m:\u001b[39m palette\u001b[33m,\u001b[39m\n \u001b[90m 58 |\u001b[39m   \u001b[32m'colodore'\u001b[39m\u001b[33m:\u001b[39m colodore\u001b[33m.\u001b[39mmap(hexToRgb)\u001b[33m,\u001b[39m\n \u001b[90m 59 |\u001b[39m   \u001b[32m'pepto'\u001b[39m\u001b[33m:\u001b[39m pepto\u001b[33m.\u001b[39mmap(hexToRgb)\u001b[33m,\u001b[39m\u001b[0m","Parsing error: Unexpected token, expected \",\"\n\n\u001b[0m \u001b[90m 12 |\u001b[39m\n \u001b[90m 13 |\u001b[39m \u001b[36mconst\u001b[39m actionCreators \u001b[33m=\u001b[39m {\n\u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 14 |\u001b[39m   addCustomFont\u001b[33m:\u001b[39m (id\u001b[33m:\u001b[39m string\u001b[33m,\u001b[39m name\u001b[33m:\u001b[39m string\u001b[33m,\u001b[39m font\u001b[33m:\u001b[39m \u001b[33mFont\u001b[39m) \u001b[33m=>\u001b[39m createAction(\u001b[33mADD_CUSTOM_FONT\u001b[39m\u001b[33m,\u001b[39m { id\u001b[33m,\u001b[39m name\u001b[33m,\u001b[39m font  } \u001b[36mas\u001b[39m \u001b[33mAddCustomFontArgs\u001b[39m)\n \u001b[90m    |\u001b[39m                                                                                                              \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n \u001b[90m 15 |\u001b[39m }\u001b[33m;\u001b[39m\n \u001b[90m 16 |\u001b[39m\n \u001b[90m 17 |\u001b[39m \u001b[36mexport\u001b[39m \u001b[36mconst\u001b[39m actions \u001b[33m=\u001b[39m {\u001b[0m","Parsing error: Unexpected token, expected \",\"\n\n\u001b[0m \u001b[90m 94 |\u001b[39m }\n \u001b[90m 95 |\u001b[39m\n\u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 96 |\u001b[39m type \u001b[33mOmit\u001b[39m\u001b[33m<\u001b[39m\u001b[33mT\u001b[39m\u001b[33m,\u001b[39m \u001b[33mK\u001b[39m\u001b[33m>\u001b[39m \u001b[33m=\u001b[39m \u001b[33mPick\u001b[39m\u001b[33m<\u001b[39m\u001b[33mT\u001b[39m\u001b[33m,\u001b[39m \u001b[33mExclude\u001b[39m\u001b[33m<\u001b[39m\u001b[33mkeyof\u001b[39m \u001b[33mT\u001b[39m\u001b[33m,\u001b[39m \u001b[33mK\u001b[39m\u001b[33m>>\u001b[39m\u001b[33m;\u001b[39m\n \u001b[90m    |\u001b[39m                                         \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n \u001b[90m 97 |\u001b[39m\n \u001b[90m 98 |\u001b[39m \u001b[36mclass\u001b[39m \u001b[33mSelectableTool\u001b[39m \u001b[36mextends\u001b[39m \u001b[33mPureComponent\u001b[39m\u001b[33m<\u001b[39m\n \u001b[90m 99 |\u001b[39m   \u001b[33mSelectableToolProps\u001b[39m \u001b[33m&\u001b[39m \u001b[33mOmit\u001b[39m\u001b[33m<\u001b[39m\u001b[33mIconProps\u001b[39m\u001b[33m,\u001b[39m \u001b[32m\"onIconClick\"\u001b[39m \u001b[33m|\u001b[39m \u001b[32m\"bottom\"\u001b[39m\u001b[33m>\u001b[39m\u001b[0m","Parsing error: Missing semicolon.\n\n\u001b[0m \u001b[90m 93 |\u001b[39m\n \u001b[90m 94 |\u001b[39m   handleChange \u001b[33m=\u001b[39m (e\u001b[33m:\u001b[39m \u001b[33mReact\u001b[39m\u001b[33m.\u001b[39m\u001b[33mFormEvent\u001b[39m\u001b[33m<\u001b[39m\u001b[33mEventTarget\u001b[39m\u001b[33m>\u001b[39m) \u001b[33m=>\u001b[39m {\n\u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 95 |\u001b[39m     \u001b[36mlet\u001b[39m target \u001b[33m=\u001b[39m e\u001b[33m.\u001b[39mtarget \u001b[36mas\u001b[39m \u001b[33mHTMLInputElement\u001b[39m\u001b[33m;\u001b[39m\n \u001b[90m    |\u001b[39m                          \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n \u001b[90m 96 |\u001b[39m     \u001b[36mthis\u001b[39m\u001b[33m.\u001b[39msetState({ name\u001b[33m:\u001b[39m target\u001b[33m.\u001b[39mvalue })\u001b[33m;\u001b[39m\n \u001b[90m 97 |\u001b[39m   }\u001b[33m;\u001b[39m\n \u001b[90m 98 |\u001b[39m\u001b[0m","Parsing error: Missing semicolon.\n\n\u001b[0m \u001b[90m 140 |\u001b[39m   \u001b[36mconst\u001b[39m { width\u001b[33m,\u001b[39m height\u001b[33m,\u001b[39m matches\u001b[33m,\u001b[39m borderColor } \u001b[33m=\u001b[39m petscii\u001b[33m;\u001b[39m\n \u001b[90m 141 |\u001b[39m   \u001b[36mconst\u001b[39m match \u001b[33m=\u001b[39m findMatchByBackgroundColor(matches\u001b[33m,\u001b[39m selectedBackgroundColor)\u001b[33m;\u001b[39m\n\u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 142 |\u001b[39m   \u001b[36mconst\u001b[39m f \u001b[33m=\u001b[39m petscii\u001b[33m!\u001b[39m\u001b[33m;\u001b[39m\n \u001b[90m     |\u001b[39m                    \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n \u001b[90m 143 |\u001b[39m   \u001b[36mreturn\u001b[39m {\n \u001b[90m 144 |\u001b[39m     framebuf\u001b[33m:\u001b[39m convertScreencodes(width\u001b[33m,\u001b[39m height\u001b[33m,\u001b[39m match\u001b[33m.\u001b[39mscreencodes\u001b[33m,\u001b[39m match\u001b[33m.\u001b[39mcolors)\u001b[33m,\u001b[39m\n \u001b[90m 145 |\u001b[39m     width\u001b[33m:\u001b[39m f\u001b[33m.\u001b[39mwidth\u001b[33m,\u001b[39m\u001b[0m","Parsing error: Unexpected token, expected \",\"\n\n\u001b[0m \u001b[90m 430 |\u001b[39m\n \u001b[90m 431 |\u001b[39m \u001b[90m// Type to select one format branch from ExportModalState\u001b[39m\n\u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 432 |\u001b[39m type \u001b[33mState\u001b[39m\u001b[33m<\u001b[39m\u001b[33mT\u001b[39m \u001b[36mextends\u001b[39m keyof \u001b[33mExportModalState\u001b[39m\u001b[33m>\u001b[39m \u001b[33m=\u001b[39m {\n \u001b[90m     |\u001b[39m              \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n \u001b[90m 433 |\u001b[39m   state\u001b[33m:\u001b[39m \u001b[33mExportModalState\u001b[39m[\u001b[33mT\u001b[39m]\u001b[33m;\u001b[39m\n \u001b[90m 434 |\u001b[39m   setState\u001b[33m:\u001b[39m any\u001b[33m;\u001b[39m \u001b[90m// TODO ts\u001b[39m\n \u001b[90m 435 |\u001b[39m }\u001b[0m","Parsing error: Missing semicolon.\n\n\u001b[0m \u001b[90m 83 |\u001b[39m       \u001b[36mconst\u001b[39m files \u001b[33m=\u001b[39m event\u001b[33m.\u001b[39mdataTransfer\u001b[33m.\u001b[39mfiles\u001b[33m;\u001b[39m\n \u001b[90m 84 |\u001b[39m       \u001b[36mif\u001b[39m (files\u001b[33m.\u001b[39mlength \u001b[33m==\u001b[39m \u001b[35m1\u001b[39m) {\n\u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 85 |\u001b[39m         \u001b[36mconst\u001b[39m file0 \u001b[33m=\u001b[39m files[\u001b[35m0\u001b[39m] \u001b[36mas\u001b[39m any\u001b[33m;\u001b[39m\n \u001b[90m    |\u001b[39m                               \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n \u001b[90m 86 |\u001b[39m         \u001b[36mthis\u001b[39m\u001b[33m.\u001b[39mprops\u001b[33m.\u001b[39mloadDroppedFile(file0\u001b[33m.\u001b[39mpath)\u001b[33m;\u001b[39m\n \u001b[90m 87 |\u001b[39m       }\n \u001b[90m 88 |\u001b[39m     }\u001b[0m","Parsing error: Missing semicolon.\n\n\u001b[0m \u001b[90m 463 |\u001b[39m\n \u001b[90m 464 |\u001b[39m   dragMove \u001b[33m=\u001b[39m (coord\u001b[33m:\u001b[39m \u001b[33mCoord2\u001b[39m) \u001b[33m=>\u001b[39m {\n\u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 465 |\u001b[39m     \u001b[36mconst\u001b[39m prevDragPos \u001b[33m=\u001b[39m \u001b[36mthis\u001b[39m\u001b[33m.\u001b[39mprevDragPos\u001b[33m!\u001b[39m\u001b[33m;\u001b[39m \u001b[90m// set in dragStart\u001b[39m\n \u001b[90m     |\u001b[39m                                         \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n \u001b[90m 466 |\u001b[39m     \u001b[36mconst\u001b[39m { selectedTool\u001b[33m,\u001b[39m brush\u001b[33m,\u001b[39m brushRegion } \u001b[33m=\u001b[39m \u001b[36mthis\u001b[39m\u001b[33m.\u001b[39mprops\u001b[33m;\u001b[39m\n \u001b[90m 467 |\u001b[39m     \u001b[36mif\u001b[39m (\n \u001b[90m 468 |\u001b[39m       selectedTool \u001b[33m===\u001b[39m \u001b[33mTool\u001b[39m\u001b[33m.\u001b[39m\u001b[33mDraw\u001b[39m \u001b[33m||\u001b[39m\u001b[0m","Parsing error: Unexpected token, expected \"{\"\n\n\u001b[0m \u001b[90m 45 |\u001b[39m }\n \u001b[90m 46 |\u001b[39m\n\u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 47 |\u001b[39m \u001b[36mexport\u001b[39m \u001b[36mfunction\u001b[39m isError(v\u001b[33m:\u001b[39m \u001b[33mResult\u001b[39m\u001b[33m|\u001b[39m\u001b[33mErr\u001b[39m)\u001b[33m:\u001b[39m v is \u001b[33mErr\u001b[39m {\n \u001b[90m    |\u001b[39m                                           \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n \u001b[90m 48 |\u001b[39m   \u001b[36mreturn\u001b[39m v\u001b[33m.\u001b[39mhasOwnProperty(\u001b[32m'error'\u001b[39m)\u001b[33m;\u001b[39m\n \u001b[90m 49 |\u001b[39m }\n \u001b[90m 50 |\u001b[39m\u001b[0m","Parsing error: Unexpected token, expected \",\"\n\n\u001b[0m \u001b[90m 2 |\u001b[39m \u001b[36mimport\u001b[39m \u001b[33mReact\u001b[39m\u001b[33m,\u001b[39m { \u001b[33mComponent\u001b[39m } \u001b[36mfrom\u001b[39m \u001b[32m'react'\u001b[39m\u001b[33m;\u001b[39m\n \u001b[90m 3 |\u001b[39m\n\u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 4 |\u001b[39m type \u001b[33mOmit\u001b[39m\u001b[33m<\u001b[39m\u001b[33mT\u001b[39m\u001b[33m,\u001b[39m \u001b[33mK\u001b[39m\u001b[33m>\u001b[39m \u001b[33m=\u001b[39m \u001b[33mPick\u001b[39m\u001b[33m<\u001b[39m\u001b[33mT\u001b[39m\u001b[33m,\u001b[39m \u001b[33mExclude\u001b[39m\u001b[33m<\u001b[39m\u001b[33mkeyof\u001b[39m \u001b[33mT\u001b[39m\u001b[33m,\u001b[39m \u001b[33mK\u001b[39m\u001b[33m>>\u001b[39m\u001b[33m;\u001b[39m\n \u001b[90m   |\u001b[39m                                         \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n \u001b[90m 5 |\u001b[39m type \u001b[33mSubtract\u001b[39m\u001b[33m<\u001b[39m\u001b[33mT\u001b[39m\u001b[33m,\u001b[39m \u001b[33mK\u001b[39m\u001b[33m>\u001b[39m \u001b[33m=\u001b[39m \u001b[33mOmit\u001b[39m\u001b[33m<\u001b[39m\u001b[33mT\u001b[39m\u001b[33m,\u001b[39m keyof \u001b[33mK\u001b[39m\u001b[33m>\u001b[39m\u001b[33m;\u001b[39m\n \u001b[90m 6 |\u001b[39m\n \u001b[90m 7 |\u001b[39m \u001b[36minterface\u001b[39m \u001b[33mWithHoverInjectedProps\u001b[39m {\u001b[0m","Parsing error: Unexpected token\n\n\u001b[0m \u001b[90m 14 |\u001b[39m \u001b[90m// bug fixes like unregistering event handlers)\u001b[39m\n \u001b[90m 15 |\u001b[39m \u001b[36mexport\u001b[39m \u001b[36mdefault\u001b[39m \u001b[36mclass\u001b[39m \u001b[33mContextMenuArea\u001b[39m \u001b[36mextends\u001b[39m \u001b[33mComponent\u001b[39m\u001b[33m<\u001b[39m\u001b[33mContextMenuAreaProps\u001b[39m\u001b[33m>\u001b[39m {\n\u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 16 |\u001b[39m   \u001b[36mprivate\u001b[39m menu \u001b[33m=\u001b[39m \u001b[36mnew\u001b[39m \u001b[33mMenu\u001b[39m()\u001b[33m;\u001b[39m\n \u001b[90m    |\u001b[39m           \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n \u001b[90m 17 |\u001b[39m   \u001b[36mprivate\u001b[39m rootElement \u001b[33m=\u001b[39m \u001b[33mReact\u001b[39m\u001b[33m.\u001b[39mcreateRef\u001b[33m<\u001b[39m\u001b[33mHTMLDivElement\u001b[39m\u001b[33m>\u001b[39m()\u001b[33m;\u001b[39m\n \u001b[90m 18 |\u001b[39m\n \u001b[90m 19 |\u001b[39m   handleContextMenu \u001b[33m=\u001b[39m (e\u001b[33m:\u001b[39m \u001b[33mEvent\u001b[39m) \u001b[33m=>\u001b[39m {\u001b[0m","Parsing error: Unexpected token, expected \"}\"\n\n\u001b[0m \u001b[90m 165 |\u001b[39m               grid\u001b[33m=\u001b[39m{\u001b[36mtrue\u001b[39m}\n \u001b[90m 166 |\u001b[39m               opacity\u001b[33m=\u001b[39m{\u001b[35m0.5\u001b[39m}\n\u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 167 |\u001b[39m               charPos\u001b[33m=\u001b[39m{charPos\u001b[33m!\u001b[39m}\n \u001b[90m     |\u001b[39m                               \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n \u001b[90m 168 |\u001b[39m               borderOn\u001b[33m=\u001b[39m{\u001b[36mfalse\u001b[39m}\n \u001b[90m 169 |\u001b[39m             \u001b[33m/\u001b[39m\u001b[33m>\u001b[39m\n \u001b[90m 170 |\u001b[39m             \u001b[33m:\u001b[39m \u001b[36mnull\u001b[39m}\u001b[0m","Parsing error: Unexpected token\n\n\u001b[0m \u001b[90m  5 |\u001b[39m\n \u001b[90m  6 |\u001b[39m \u001b[36mclass\u001b[39m \u001b[33mCharsetCache\u001b[39m {\n\u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m  7 |\u001b[39m   \u001b[36mprivate\u001b[39m images\u001b[33m:\u001b[39m \u001b[33mImageData\u001b[39m[][] \u001b[33m=\u001b[39m \u001b[33mArray\u001b[39m(\u001b[35m17\u001b[39m)\u001b[33m;\u001b[39m\n \u001b[90m    |\u001b[39m           \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n \u001b[90m  8 |\u001b[39m\n \u001b[90m  9 |\u001b[39m   constructor (\n \u001b[90m 10 |\u001b[39m     ctx\u001b[33m:\u001b[39m \u001b[33mCanvasRenderingContext2D\u001b[39m\u001b[33m,\u001b[39m\u001b[0m","Parsing error: Missing semicolon.\n\n\u001b[0m \u001b[90m 33 |\u001b[39m \u001b[36mfunction\u001b[39m formatPetsciicode(num\u001b[33m:\u001b[39m number \u001b[33m|\u001b[39m \u001b[36mnull\u001b[39m) {\n \u001b[90m 34 |\u001b[39m\n\u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 35 |\u001b[39m     \u001b[36mlet\u001b[39m byte_char \u001b[33m=\u001b[39m num\u001b[33m!\u001b[39m\u001b[33m;\u001b[39m\n \u001b[90m    |\u001b[39m                        \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n \u001b[90m 36 |\u001b[39m   \u001b[36mif\u001b[39m ((byte_char \u001b[33m>=\u001b[39m \u001b[35m0\u001b[39m) \u001b[33m&&\u001b[39m (byte_char \u001b[33m<=\u001b[39m \u001b[35m0x1f\u001b[39m)) {\n \u001b[90m 37 |\u001b[39m     byte_char \u001b[33m=\u001b[39m byte_char \u001b[33m+\u001b[39m \u001b[35m0x40\u001b[39m\u001b[33m;\u001b[39m\n \u001b[90m 38 |\u001b[39m   }\u001b[0m","Parsing error: Unexpected token\n\n\u001b[0m \u001b[90m  8 |\u001b[39m\n \u001b[90m  9 |\u001b[39m \u001b[36mclass\u001b[39m \u001b[33mModalBase\u001b[39m \u001b[36mextends\u001b[39m \u001b[33mComponent\u001b[39m {\n\u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 10 |\u001b[39m   \u001b[36mprivate\u001b[39m el \u001b[33m=\u001b[39m document\u001b[33m.\u001b[39mcreateElement(\u001b[32m'div'\u001b[39m)\n \u001b[90m    |\u001b[39m           \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n \u001b[90m 11 |\u001b[39m\n \u001b[90m 12 |\u001b[39m   componentDidMount() {\n \u001b[90m 13 |\u001b[39m     \u001b[90m// The portal element is inserted in the DOM tree after\u001b[39m\u001b[0m","Parsing error: Identifier 'TextCursorOverlay' has already been declared.\n\n\u001b[0m \u001b[90m 78 |\u001b[39m }\n \u001b[90m 79 |\u001b[39m\n\u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 80 |\u001b[39m \u001b[36mexport\u001b[39m \u001b[36mconst\u001b[39m \u001b[33mTextCursorOverlay\u001b[39m \u001b[33m=\u001b[39m (props\u001b[33m:\u001b[39m \u001b[33mTextCursorOverlay\u001b[39m) \u001b[33m=>\u001b[39m {\n \u001b[90m    |\u001b[39m              \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n \u001b[90m 81 |\u001b[39m   \u001b[36mreturn\u001b[39m (\n \u001b[90m 82 |\u001b[39m     \u001b[33m<\u001b[39m\u001b[33mCharPosOverlay\u001b[39m {\u001b[33m...\u001b[39mprops} blink\u001b[33m=\u001b[39m{\u001b[36mtrue\u001b[39m} \u001b[33m/\u001b[39m\u001b[33m>\u001b[39m\n \u001b[90m 83 |\u001b[39m   )\u001b[0m","Parsing error: Missing semicolon.\n\n\u001b[0m \u001b[90m 54 |\u001b[39m\n \u001b[90m 55 |\u001b[39m \u001b[36mconst\u001b[39m groupByUndoId \u001b[33m=\u001b[39m (action\u001b[33m:\u001b[39m \u001b[33mAction\u001b[39m\u001b[33m<\u001b[39m\u001b[33many\u001b[39m\u001b[33m>\u001b[39m) \u001b[33m=>\u001b[39m {\n\u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 56 |\u001b[39m   \u001b[36mconst\u001b[39m tmpAction \u001b[33m=\u001b[39m action \u001b[36mas\u001b[39m framebuffer\u001b[33m.\u001b[39m\u001b[33mActions\u001b[39m\u001b[33m;\u001b[39m\n \u001b[90m    |\u001b[39m                           \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n \u001b[90m 57 |\u001b[39m   \u001b[36mif\u001b[39m (tmpAction\u001b[33m.\u001b[39mundoId \u001b[33m!==\u001b[39m undefined) {\n \u001b[90m 58 |\u001b[39m     \u001b[36mreturn\u001b[39m tmpAction\u001b[33m.\u001b[39mundoId\u001b[33m;\u001b[39m\n \u001b[90m 59 |\u001b[39m   }\u001b[0m","Parsing error: Unexpected token, expected \",\"\n\n\u001b[0m \u001b[90m 111 |\u001b[39m\n \u001b[90m 112 |\u001b[39m \u001b[36mfunction\u001b[39m maybeLabelName(name\u001b[33m:\u001b[39m string \u001b[33m|\u001b[39m undefined) {\n\u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 113 |\u001b[39m   \u001b[36mreturn\u001b[39m fp\u001b[33m.\u001b[39mmaybeDefault(name\u001b[33m,\u001b[39m \u001b[32m'untitled'\u001b[39m \u001b[36mas\u001b[39m string)\u001b[33m;\u001b[39m\n \u001b[90m     |\u001b[39m                                           \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n \u001b[90m 114 |\u001b[39m }\n \u001b[90m 115 |\u001b[39m\n \u001b[90m 116 |\u001b[39m \u001b[36mfunction\u001b[39m convertToAsm(lines\u001b[33m:\u001b[39m string[]\u001b[33m,\u001b[39m fb\u001b[33m:\u001b[39m \u001b[33mFramebufWithFont\u001b[39m\u001b[33m,\u001b[39m hex\u001b[33m:\u001b[39m boolean) {\u001b[0m","Parsing error: Unexpected token, expected \",\"\n\n\u001b[0m \u001b[90m 111 |\u001b[39m\n \u001b[90m 112 |\u001b[39m \u001b[36mfunction\u001b[39m maybeLabelName(name\u001b[33m:\u001b[39m string \u001b[33m|\u001b[39m undefined) {\n\u001b[31m\u001b[1m>\u001b[22m\u001b[39m\u001b[90m 113 |\u001b[39m   \u001b[36mreturn\u001b[39m fp\u001b[33m.\u001b[39mmaybeDefault(name\u001b[33m,\u001b[39m \u001b[32m'untitled'\u001b[39m \u001b[36mas\u001b[39m string)\u001b[33m;\u001b[39m\n \u001b[90m     |\u001b[39m                                           \u001b[31m\u001b[1m^\u001b[22m\u001b[39m\n \u001b[90m 114 |\u001b[39m }\n \u001b[90m 115 |\u001b[39m\n \u001b[90m 116 |\u001b[39m\u001b[0m"]